<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ΛLΞXΛNDRIΛ - A decentralized library of art, history, knowledge and memes</title>
    <link rel="icon" type="image/png" href="blue-alexandria-logo.png">
    <script src="/config.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            min-height: 100vh;
            color: #2d3748;
            margin: 0;
            padding: 0;
        }

        .header {
            background: #1a1a1a;
            color: white;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.8rem;
            font-weight: 100;
            letter-spacing: 3px;
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            text-transform: uppercase;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
        }

        .nav-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #a0a0a0;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            position: relative;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .nav-tab.active {
            color: white;
            background: rgba(255,255,255,0.15);
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .jwt-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .jwt-indicator {
            font-size: 14px;
        }

        .jwt-user-info {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .ai-drawer-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-drawer-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .ai-drawer-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        /* Header Search Styles */
        .header-search {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            max-width: 600px;
            margin: 0 20px;
        }

        .header-search input {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .header-search input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .header-search input:focus {
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.15);
        }

        .filters-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }

        .filters-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .filters-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        /* Filters Drawer Styles */
        .filters-drawer {
            position: fixed;
            top: 64px;
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 998;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            max-height: calc(100vh - 64px);
            overflow-y: auto;
        }

        .filters-drawer.open {
            transform: translateY(0);
        }

        .filters-drawer-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px 24px;
        }

        /* AI Drawer Styles */
        .ai-drawer {
            position: fixed;
            top: 64px;
            right: -50vw;
            width: 50vw;
            height: calc(100vh - 64px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-drawer.open {
            right: 0;
        }

        .ai-drawer-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            color: white;
            flex-shrink: 0;
        }

        .ai-drawer-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Main content with drawer */
        .main-content {
            transition: margin-right 0.3s ease;
            min-height: calc(100vh - 64px);
        }

        .main-content.drawer-open {
            margin-right: 50vw;
        }

        /* Welcome Interface Styles */
        .welcome-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 164px);
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        .welcome-title {
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            font-size: 4rem;
            font-weight: 100;
            letter-spacing: 4px;
            color: #2d3748;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: #718096;
            margin-bottom: 60px;
            font-weight: 400;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 30px;
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
        }

        .category-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
        }

        .category-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            color: inherit;
            text-decoration: none;
        }

        .category-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .category-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #4a5568;
        }

        /* Search Bar in Welcome */
        .welcome-search {
            max-width: 600px;
            width: 100%;
            margin-bottom: 40px;
        }

        .welcome-search input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .welcome-search input:focus {
            border-color: #667eea;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .advanced-search-toggle {
            margin-top: 20px;
        }

        .advanced-search-toggle button {
            background: transparent;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .advanced-search-toggle button:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: none;
            box-shadow: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        #publish-tab {
            position: relative;
            top: 0;
            padding-top: 20px;
            margin-top: 0;
        }

        .filters-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .filters-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .filter-group.wide {
            flex: 1;
            min-width: 180px;
        }

        .filter-group.compact {
            flex: 0 0 auto;
            min-width: 140px;
        }

        .search-container {
            flex: 3;
            min-width: 300px;
        }

        .records-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 600px;
        }

        /* Records Header Styles */
        #voice-records-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 20px;
        }

        .records-header-left {
            flex: 1;
        }

        .records-header-right {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .header-control-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .header-control-group label {
            font-size: 0.9rem;
            color: #555;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .header-control-group select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }

        /* Records Grid View */
        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* Records List View */
        .records-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .record-card.list-view {
            display: flex;
            gap: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
            transition: all 0.3s ease;
            max-height: 180px;
            overflow: hidden;
        }

        .record-card.list-view:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .record-card.list-view .media-preview {
            width: 140px;
            height: 100px;
            flex-shrink: 0;
            border-radius: 8px;
            overflow: hidden;
        }

        .record-card.list-view .record-content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .record-card.list-view .record-header {
            margin-bottom: 8px;
        }

        .record-card.list-view .record-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .record-card.list-view .record-description {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #666;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .record-card.list-view .list-meta-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .record-card.list-view .list-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .record-card.list-view .play-btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .record-card.list-view .tags-container {
            margin: 8px 0 0 0;
        }

        .record-card.list-view .tag-chip {
            font-size: 10px;
            padding: 2px 6px;
        }

        /* Podcast List View Specific */
        .podcast-show-card.list-view {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #667eea;
        }

        .podcast-show-card.list-view .podcast-show-header {
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .podcast-show-card.list-view .podcast-show-header img {
            width: 60px;
            height: 60px;
        }

        .record-card.list-view .podcast-date {
            font-size: 11px;
        }

        .record-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
            transition: all 0.3s ease;
        }

        .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-type {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .record-block {
            color: #666;
            font-size: 0.9rem;
        }

        .record-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .record-content {
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .record-meta {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.8rem;
            color: #999;
        }

        .tags-container {
            margin-top: 10px;
        }

        .tag {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin: 2px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag:hover {
            background: #667eea;
            color: white;
        }

        /* Media content styling */
        .media-content {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .media-item {
            margin: 10px 0;
        }

        .media-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .media-item img:hover {
            transform: scale(1.02);
        }

        .media-item audio,
        .media-item video {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .media-item button {
            transition: all 0.2s;
        }

        .media-item button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .text-content {
            border: 1px solid #dee2e6;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .media-item label {
            color: #495057;
            font-size: 14px;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        /* Upload Progress Styles */
        .upload-progress {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #45a049);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Media Preview Styles */
        .media-preview {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }

        .media-preview h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        /* Info Box Styles */
        .info-box {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .info-box li {
            margin-bottom: 5px;
        }

        /* GIF Reference Row Styles */
        .gif-ref-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fafafa;
        }

        .gif-ref-row:hover {
            background: #f0f0f0;
        }

        .gif-ref-row label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }

        .gif-ref-row input {
            font-size: 12px;
            padding: 4px 6px;
        }

        /* Button Group Styles */
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 120px;
        }

        /* Status Message Styles */
        .status-message {
            margin-top: 15px;
        }

        .success-message {
            padding: 10px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            border-radius: 4px;
            font-size: 14px;
        }

        .error-message {
            padding: 10px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            .gif-ref-row {
                flex-direction: column;
                gap: 8px;
            }
            
            .gif-ref-row > div {
                flex: none !important;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                min-width: auto;
            }
            
            .jwt-user-info {
                max-width: 80px;
            }
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 28px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .logged-in-user {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            font-size: 14px;
        }

        .dynamic-fields {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background: white;
        }

        .field-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .field-row > div {
            flex: 1;
        }

        .field-row button {
            margin: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .date-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-inputs input {
            width: 143px;
            min-width: 130px;
            flex: 0 0 auto;
        }

        .date-inputs span {
            color: #666;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .advanced-filters {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .toggle-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .load-more {
            text-align: center;
            margin: 20px 0;
        }

        .no-results {
            text-align: center;
            color: #999;
        }

        /* Multi-Tag Filter Styles */
        .multi-tag-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tag-mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-mode-selector label {
            font-size: 0.9rem;
            color: #666;
            margin: 0;
            font-weight: 500;
        }

        .tag-mode-selector select {
            padding: 4px 8px;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .tag-filters-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tag-filter-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-filter-select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .add-tag-btn, .remove-tag-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
        }

        .add-tag-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .remove-tag-btn {
            border-color: #dc3545;
            color: #dc3545;
        }

        .remove-tag-btn:hover {
            background: #dc3545;
            color: white;
            transform: translateY(-1px);
        }

        .tag-filter-row:first-child .remove-tag-btn {
            display: none; /* Hide remove button on first row */
        }

        /* Resolve hint styling */
        .resolve-hint {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px dashed #6c757d;
            color: #495057;
            text-align: center;
            padding: 20px;
            cursor: help;
        }

        .resolve-hint:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: none; /* Override hover transform */
        }

        /* Responsive Layout for Multi-Tag Filters */
        @media (max-width: 768px) {
            .filters-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .filter-group.compact,
            .filter-group.wide {
                min-width: 100%;
            }
            
            .date-inputs input {
                width: 156px;
            }
        }

        /* When many tag filters are present, optimize spacing */
        .tag-filters-container.has-many-tags {
            gap: 6px;
        }

        .tag-filters-container.has-many-tags .tag-filter-select {
            padding: 6px 10px;
            font-size: 13px;
        }

        .tag-filters-container.has-many-tags .add-tag-btn,
        .tag-filters-container.has-many-tags .remove-tag-btn {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }

        /* Master Audio Player */
        .master-audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .master-audio-player.visible {
            transform: translateY(0);
        }

        .audio-player-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .audio-info {
            flex: 1;
            min-width: 0;
        }

        .audio-title {
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .audio-meta {
            font-size: 12px;
            opacity: 0.8;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .audio-controls button:hover {
            background: rgba(255,255,255,0.3);
            transform: none;
            box-shadow: none;
        }

        .audio-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        .audio-progress-bar {
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .audio-time {
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .record-card .audio-play-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .record-card .audio-play-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .record-card .audio-play-btn.playing {
            background: #dc3545;
        }

        .record-card .audio-play-btn.playing:hover {
            background: #c82333;
        }

        .text-content-preview {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .toggle-text-btn {
            background: #17a2b8;
            font-size: 12px;
            padding: 4px 8px;
        }

        .toggle-text-btn:hover {
            background: #138496;
        }

        .record-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .record-image:hover {
            transform: scale(1.02);
        }

                    /* Ensure body has padding for fixed audio player */
        body {
            margin-bottom: 80px;
        }
        
        /* Main content adjustments for fixed header on mobile */
        @media (max-width: 768px) {
            .main-content {
                margin-top: 0;
                padding-top: 0;
            }
            
            .container {
                padding: 15px;
            }
        }

        /* AI Chat Integration Styles */
        .ai-chat-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 500px;
            max-height: 700px;
            overflow: hidden;
            contain: layout;
        }

        .chat-header {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 15px;
            flex-shrink: 0;
        }

        .chat-conversation {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            min-height: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .chat-message .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .message-avatar {
            background: rgba(59, 130, 246, 0.8);
        }

        .chat-message.assistant .message-avatar {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-avatar {
            background: rgba(239, 68, 68, 0.8);
        }

        .message-content {
            flex: 1;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            position: relative;
        }

        .chat-message.user .message-content {
            background: rgba(59, 130, 246, 0.8);
            margin-left: auto;
        }

        .chat-message.assistant .message-content {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-content {
            background: rgba(239, 68, 68, 0.8);
            font-style: italic;
        }

        .message-text {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.8;
        }

        .message-timestamp {
            font-size: 11px;
            opacity: 0.7;
        }

        .mic-btn {
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            padding: 16px 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 60px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-left: 20px;
        }

        .mic-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .mic-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .mic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .mic-btn.recording {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(239, 68, 68, 1);
            animation: pulse 1.5s infinite;
        }

        .mic-btn.listening {
            background: rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 1);
            animation: pulse 2s infinite;
        }

        .mic-btn.transcribing {
            background: rgba(59, 130, 246, 0.8);
            border-color: rgba(59, 130, 246, 1);
            animation: spin 1s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .message-sources {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
        }

        .source-count {
            font-weight: bold;
        }

        .chat-input-container {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        #ai-chat-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-height: 60px;
            resize: vertical;
            max-height: 200px;
            display: block !important;
            visibility: visible !important;
            font-family: inherit;
            line-height: 1.5;
        }

        #ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #ai-chat-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .chat-send-btn {
            padding: 16px 32px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(10px);
            min-height: 60px;
        }

        .chat-send-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-status {
            text-align: left;
            padding: 8px 8px 8px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            backdrop-filter: blur(10px);
            opacity: 0.9;
            font-size: 12px;
        }

        .chat-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            opacity: 0.8;
        }

        .chat-empty-state .emoji {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .chat-empty-state h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .chat-empty-state p {
            font-size: 14px;
            opacity: 0.8;
        }

        .ai-settings {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .ai-setting {
            flex: 1;
            min-width: 200px;
        }

        .ai-setting label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }

        .ai-setting select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .applied-filters {
            background: rgba(59, 130, 246, 0.15);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .filter-chip {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 16px;
            margin: 4px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .conversation-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .conversation-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .conversation-message.user {
            background: rgba(59, 130, 246, 0.3);
            margin-left: 20px;
        }

        .conversation-message.assistant {
            background: rgba(34, 197, 94, 0.3);
            margin-right: 20px;
        }

        .conversation-message .timestamp {
            font-size: 11px;
            opacity: 0.7;
            display: block;
            margin-top: 4px;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots:after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Microphone icon styles */
        .microphone-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .pagination-info {
            text-align: center;
            color: #666;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        /* Dynamic Template Debugging Styles */
        .template-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
            color: #1976d2;
        }

        .field-type-indicator {
            background: #f3e5f5;
            color: #7b1fa2;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        .dref-resolved {
            border-left: 3px solid #4caf50;
            margin-left: 10px;
            padding-left: 10px;
            background: #f1f8e9;
            border-radius: 0 4px 4px 0;
        }

        /* ========================================================================
           MODERN MEDIA-FOCUSED CARD STYLES (YouTube/SoundCloud/Flickr Style)
           ======================================================================== */
        
        /* Media Preview Styles */
        .media-preview {
            position: relative;
            width: 100%;
            height: 200px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .media-preview:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .preview-image, .preview-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        .preview-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 48px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .audio-artwork {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .audio-icon {
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-visualizer {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .audio-visualizer .bar {
            width: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 2px;
            animation: audio-bounce 1.5s infinite ease-in-out;
        }

        .audio-visualizer .bar:nth-child(1) { height: 20px; animation-delay: -0.32s; }
        .audio-visualizer .bar:nth-child(2) { height: 15px; animation-delay: -0.16s; }
        .audio-visualizer .bar:nth-child(3) { height: 25px; animation-delay: 0s; }
        .audio-visualizer .bar:nth-child(4) { height: 18px; animation-delay: -0.24s; }

        @keyframes audio-bounce {
            0%, 80%, 100% { transform: scaleY(0.6); opacity: 0.8; }
            40% { transform: scaleY(1); opacity: 1; }
        }

        .media-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }

        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .video-preview:hover .play-overlay, 
        .podcast-preview:hover .play-overlay {
            opacity: 1;
        }

        .play-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .play-button:hover {
            transform: scale(1.1);
        }

        /* Record Content Styles */
        .record-content {
            padding: 0 5px;
        }

        .record-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .record-description {
            color: #7f8c8d;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
        }

        /* Media Control Styles */
        .media-controls, .article-controls, .web-controls {
            margin: 12px 0;
        }

        .play-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            font-size: 14px;
        }

        .play-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .play-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .play-btn.primary.playing {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.3);
        }

        .play-btn.secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .play-btn.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .article-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }

        .article-btn:hover {
            background: #e9ecef;
            border-color: #dee2e6;
            transform: translateY(-1px);
        }

        .web-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .web-btn:hover {
            background: #218838;
            transform: translateY(-1px);
            color: white;
        }

        .media-count {
            color: #6c757d;
            font-size: 12px;
            margin-left: 10px;
        }

        /* Record Footer Styles */
        .record-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid #e9ecef;
        }

        .show-structure-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #dee2e6;
            border-radius: 15px;
            color: #6c757d;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .show-structure-btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
            color: #495057;
        }

        .record-did {
            font-size: 10px;
            color: #adb5bd;
            font-family: monospace;
        }

        /* Record Structure (Collapsible Technical Details) */
        .record-structure {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .structure-header {
            padding: 12px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
        }

        .structure-header h4 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 14px;
        }

        /* Article Content Styles */
        .article-content {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #fff;
            overflow: hidden;
        }

        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .article-header h4 {
            margin: 0;
            color: #495057;
            font-size: 14px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .article-text {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap;
        }

        .article-error {
            padding: 15px;
            color: #dc3545;
            text-align: center;
        }

        /* Modal Styles */
        .video-modal, .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }

        .video-modal-content, .image-modal-content {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 90vh;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .video-modal-header, .image-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .video-modal-header h3, .image-modal-header h3 {
            margin: 0;
            color: #495057;
            font-size: 16px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Record Header Updates */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .record-type {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .record-date {
            color: #6c757d;
            font-size: 12px;
        }

        /* Enhanced Tags */
        .tags-container {
            margin: 12px 0;
        }

        .tag-chip {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px 4px 2px 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag-chip:hover {
            background: #dee2e6;
            transform: translateY(-1px);
        }

        /* Podcast Specific Styles */
        .podcast-preview {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
        }

        .podcast-info {
            margin-bottom: 10px;
        }

        .podcast-show {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .podcast-date {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #6c757d;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .podcast-citations {
            border-top: 1px solid #e9ecef;
            padding-top: 12px;
            margin-top: 15px;
        }

        .podcast-sources {
            max-height: 300px;
            overflow-y: auto;
        }

        .source-item {
            transition: all 0.2s ease;
        }

        .source-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .field-debug {
            background: #fff3e0;
            border: 1px solid #ff9800;
            padding: 5px;
            margin: 2px 0;
            font-size: 10px;
            border-radius: 3px;
        }

        .unresolved-dref {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .header {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1001;
            }
            
            .header-content {
                flex-direction: row;
                height: 64px;
                padding: 8px 15px;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
            }
            
            .logo {
                font-size: 1.2rem;
                letter-spacing: 1px;
                flex: 1;
            }
            
            .logo-icon {
                width: 28px;
                height: 28px;
            }
            
            .nav-tabs {
                display: flex;
                gap: 4px;
                flex-shrink: 0;
            }
            
            .nav-tab {
                padding: 6px 12px;
                font-size: 13px;
            }
            
            .auth-section {
                flex-shrink: 0;
            }
            
            .ai-drawer-toggle {
                padding: 6px 10px;
                font-size: 12px;
                gap: 4px;
            }
            
            .ai-drawer-toggle svg {
                width: 14px;
                height: 14px;
            }
            
            /* Add padding to body to account for fixed header */
            body {
                padding-top: 64px;
            }
            
            /* Header Search Mobile */
            .header-search {
                flex: 1;
                margin: 0 10px;
                max-width: none;
            }
            
            /* AI Drawer Mobile */
            .ai-drawer {
                width: 100%;
                right: -100%;
                top: 64px;
                height: calc(100vh - 64px);
                position: fixed;
                z-index: 9999;
            }
            
            .main-content.drawer-open {
                margin-right: 0;
                transform: translateX(-100%);
            }
            
            /* Mobile AI drawer content adjustments */
            .ai-drawer-content {
                height: calc(100% - 160px); /* More space for header and input */
                display: flex;
                flex-direction: column;
            }
            
            .chat-conversation {
                flex: 1;
                min-height: 150px;
                max-height: calc(100vh - 400px); /* Reduced to make room for input */
                overflow-y: auto;
                margin-bottom: 20px;
            }
            
            .ai-drawer.open .chat-input-container {
                position: fixed;
                bottom: 100px; /* Move up from bottom */
                left: 0;
                right: 0;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 20px;
                border-top: 2px solid rgba(255, 255, 255, 0.3);
                flex-shrink: 0;
                z-index: 10000;
                backdrop-filter: blur(10px);
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            }
            
            /* Welcome Interface Mobile */
            .welcome-interface {
                padding: 20px 15px;
                min-height: calc(100vh - 64px);
                margin-top: 0;
            }
            
            .welcome-title {
                font-size: 2.5rem;
                letter-spacing: 2px;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
                margin-bottom: 40px;
            }
            
            .categories-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                max-width: 400px;
            }
            
            .category-item {
                padding: 15px 10px;
            }
            
            .category-icon {
                font-size: 2rem;
                margin-bottom: 8px;
            }
            
            .category-label {
                font-size: 0.8rem;
            }
            
            .welcome-search input {
                padding: 14px 18px;
                font-size: 16px;
            }
            
            /* Search Interface Mobile */
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group,
            .filter-group.wide,
            .search-container {
                min-width: auto;
                flex: none;
            }
            
            /* Records Header Mobile */
            #voice-records-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .records-header-right {
                justify-content: flex-end;
                gap: 10px;
            }
            
            .header-control-group {
                min-width: 100px;
            }
            
            .header-control-group select {
                font-size: 12px;
                padding: 5px 8px;
            }
            
            .records-grid {
                grid-template-columns: 1fr;
            }
            
            /* List View Mobile */
            .records-list {
                gap: 10px;
            }
            
            .record-card.list-view {
                flex-direction: column;
                max-height: none;
                gap: 15px;
            }
            
            .record-card.list-view .media-preview {
                width: 100%;
                height: 120px;
            }
            
            .record-card.list-view .list-meta-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .record-card.list-view .list-controls {
                justify-content: center;
            }
            
            .field-row {
                flex-direction: column;
                gap: 5px;
            }
            
            .date-inputs {
                flex-direction: column;
            }
            
            .toggle-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            /* Mobile adjustments for AI drawer */
            .ai-drawer-header {
                padding: 15px;
                position: sticky;
                top: 0;
                background: inherit;
                z-index: 10001;
            }
            
            .ai-settings {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .ai-setting {
                flex: 1;
                min-width: auto;
            }
            
            /* AI status area adjustments */
            .ai-drawer.open .ai-status {
                position: fixed;
                bottom: 200px; /* Above the input area */
                left: 20px;
                right: 20px;
                z-index: 9999;
                text-align: center;
                background: rgba(102, 126, 234, 0.9);
                border-radius: 8px;
                margin: 0;
            }
            
            .chat-input-row {
                flex-direction: row;
                align-items: flex-end;
                gap: 10px;
                margin-bottom: 0;
            }
            
            #ai-chat-input {
                flex: 1;
                min-height: 44px;
                max-height: 120px;
                font-size: 16px;
                padding: 12px 16px;
            }
            
            .chat-send-btn {
                flex-shrink: 0;
                min-width: 80px;
                height: 44px;
                padding: 8px 16px;
                white-space: nowrap;
                font-size: 14px;
            }
            
            .mic-btn {
                flex-shrink: 0;
                width: 44px;
                height: 44px;
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
                margin-left: 0;
                margin-right: 10px;
            }
            
            .mic-btn svg {
                width: 20px;
                height: 20px;
            }
            
            .message-content {
                max-width: 85%;
            }
            
            /* Ensure input area stays visible */
            .ai-drawer.open {
                height: 100vh;
                height: 100dvh; /* Use dvh for better mobile support */
            }
            
            /* Applied filters adjustments for mobile */
            .applied-filters-display {
                position: relative;
                margin-bottom: 15px;
                z-index: 9998;
            }
            
            /* Only apply fixed positioning on small screens */
            @media (max-width: 768px) and (max-height: 800px) {
                .ai-drawer.open .chat-input-container {
                    bottom: 120px; /* Even higher on smaller screens */
                }
                
                .ai-drawer.open .ai-status {
                    bottom: 220px;
                }
            }
            
            /* Fix for iOS Safari bottom bar */
            @supports (-webkit-touch-callout: none) {
                .ai-drawer.open {
                    height: calc(100vh - env(safe-area-inset-bottom));
                }
                
                .ai-drawer.open .chat-input-container {
                    bottom: calc(100px + env(safe-area-inset-bottom));
                }
            }
        }

        /* Publishing Interface Styles */
        .publish-form {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .publish-form h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .publish-form .form-group {
            margin-bottom: 20px;
        }

        .publish-form .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .publish-form input,
        .publish-form textarea,
        .publish-form select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .publish-form input:focus,
        .publish-form textarea:focus,
        .publish-form select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .publish-form textarea {
            resize: vertical;
            min-height: 120px;
            font-family: inherit;
            line-height: 1.5;
        }

        .publish-form small {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .media-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .media-section h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1rem;
        }

        .ingredient-row,
        .exercise-row {
            display: grid;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .ingredient-row {
            grid-template-columns: 80px 100px 1fr 40px;
        }

        .exercise-row {
            grid-template-columns: 1fr 80px 80px 80px 40px;
        }

        .ingredient-row input,
        .exercise-row input {
            margin-bottom: 0;
        }

        .ingredient-row button,
        .exercise-row button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid #dc3545;
            background: white;
            color: #dc3545;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ingredient-row button:hover,
        .exercise-row button:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }

        .publish-form input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            transform: scale(1.2);
        }

        .publish-form label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            font-weight: 500;
            cursor: pointer;
        }

        .publish-progress {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .publish-progress h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .publish-form {
                margin: 0;
                padding: 15px;
                border-radius: 0;
            }

            .ingredient-row {
                grid-template-columns: 60px 80px 1fr 35px;
                gap: 8px;
            }

            .exercise-row {
                grid-template-columns: 1fr 60px 60px 60px 35px;
                gap: 8px;
            }

            .ingredient-row input,
            .exercise-row input {
                font-size: 13px;
                padding: 8px 10px;
            }

            .media-section {
                margin: 15px 0;
                padding: 15px;
            }
        }

        /* Record View Interface Styles */
        .record-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e5e7eb;
        }

        .back-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .back-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .record-view-meta {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .record-type-badge {
            background: #f0f4ff;
            color: #3730a3;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .record-did-badge {
            background: #f3f4f6;
            color: #6b7280;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-family: monospace;
        }

        .record-view-content {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Post Article Layout Styles */
        .post-article-layout {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px 16px;
        }

        .post-article-header {
            margin-bottom: 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 16px;
        }

        .post-article-title {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1.2;
            color: #1f2937;
            margin-bottom: 16px;
        }

        .post-article-summary {
            font-size: 1.125rem;
            line-height: 1.6;
            color: #6b7280;
            margin-bottom: 8px;
            font-style: italic;
        }

        .post-article-summary.collapsed {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .keep-reading-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            padding: 4px 0;
            margin-top: 4px;
            margin-bottom: 8px;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .keep-reading-btn:hover {
            color: #5a67d8;
            text-decoration: underline;
        }

        .post-article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .post-article-byline {
            font-size: 14px;
            color: #374151;
        }

        .post-article-byline strong {
            color: #1f2937;
        }

        .post-article-date {
            font-size: 14px;
            color: #6b7280;
        }

        .post-featured-media {
            margin: 8px 0 8px 0;
        }

        .post-featured-image {
            float: left;
            width: 100%;
            max-width: 350px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin: 0 20px 12px 0;
            shape-outside: margin-box;
        }

        .post-featured-video {
            width: 100%;
            max-width: 600px;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .post-audio-section {
            margin: 6px 0 0 0;
            padding: 10px 14px;
            background: #f0f4ff;
            border-radius: 6px;
            border: 1px solid #c7d2fe;
            display: inline-block;
            max-width: 100%;
        }

        .post-audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .post-summary-with-audio {
            margin-bottom: 16px;
        }

        .post-content {
            font-size: 1.125rem;
            line-height: 1.8;
            color: #374151;
            margin-top: 12px;
        }

        .post-content-wrapper {
            overflow: hidden; /* Clearfix for floating image */
        }

        .post-content::after {
            content: "";
            display: table;
            clear: both;
        }

        .post-content p {
            margin-bottom: 20px;
        }

        .post-content h1, .post-content h2, .post-content h3,
        .post-content h4, .post-content h5, .post-content h6 {
            margin: 32px 0 16px 0;
            color: #1f2937;
        }

        .post-content h1 { font-size: 2rem; }
        .post-content h2 { font-size: 1.75rem; }
        .post-content h3 { font-size: 1.5rem; }

        .post-content blockquote {
            border-left: 4px solid #667eea;
            padding-left: 16px;
            margin: 24px 0;
            font-style: italic;
            color: #6b7280;
        }

        .post-content ul, .post-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .post-content li {
            margin-bottom: 8px;
        }

        .post-tags {
            margin-top: 32px;
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
        }

        .post-tags .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .post-tags .tag-chip {
            background: #e0e7ff;
            color: #3730a3;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Responsive adjustments for record view */
        @media (max-width: 768px) {
            .post-article-layout {
                padding: 16px 12px;
            }
            
            .post-article-title {
                font-size: 1.75rem;
            }
            
            .post-featured-image {
                float: none;
                max-width: 100%;
                margin: 0 0 16px 0;
                display: block;
            }
            
            .post-featured-media {
                margin: 12px 0;
            }
            
            .post-summary-with-audio {
                margin-bottom: 12px;
            }
            
            .record-view-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }
            
            .record-view-meta {
                align-self: flex-end;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo" onclick="showWelcomeInterface()" style="cursor: pointer;">
                <img src="blue-alexandria-logo.png" alt="ALEXANDRIA" class="logo-icon">
                ΛLΞXΛNDRIΛ
            </div>
            
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="showSearchInterface()">Browse</div>
                <div class="nav-tab" onclick="showPublishTab()">Publish</div>
            </div>
            
            <div id="header-search" class="header-search hidden">
                <input type="text" id="header-search-input" placeholder="Search the archive..." onkeydown="handleHeaderSearch(event)">
                <button id="filters-toggle" class="filters-toggle" onclick="toggleFiltersDrawer()" title="Show filters">⋯</button>
            </div>
            
            <div class="auth-section">
                <button id="ai-drawer-toggle" class="ai-drawer-toggle" onclick="toggleAIDrawer()">
                    <img src="alfred.gif" alt="ΛLFRED" style="width: 16px; height: 16px; margin-right: 6px;">
                    ΛLFRED
                </button>
                <div id="jwt-status" class="jwt-status">
                    <span id="jwt-indicator" class="jwt-indicator">🔓</span>
                    <span id="jwt-user-info" class="jwt-user-info">Not authenticated</span>
                </div>
                <div id="user-info" class="hidden">
                    <span id="logged-in-display" class="logged-in-user"></span>
                    <button onclick="logout()" class="btn-secondary btn-small">Logout</button>
                </div>
                <div id="auth-buttons">
                    <button onclick="showAuthModal()" class="btn-small">Login / Register</button>
                    <button onclick="showJWTModal()" class="btn-small btn-secondary">JWT Token</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filters Drawer -->
    <div id="filters-drawer" class="filters-drawer">
        <div class="filters-drawer-content">
            <!-- This will contain the moved filters content -->
        </div>
    </div>

    <!-- AI Drawer -->
    <div id="ai-drawer" class="ai-drawer">
        <div class="ai-drawer-header">
            <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                <img src="alfred.gif" alt="ΛLFRED" style="width: 20px; height: 20px;">
                ΛLFRED
            </h3>
            
            <div class="ai-settings" style="margin-top: 15px;">
                <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                    <label for="ai-model-select">AI Model</label>
                    <select id="ai-model-select">
                        <option value="llama3.2:3b">LLaMA 3.2 3B (Fast)</option>
                        <option value="mistral:latest">Mistral 7B (Balanced)</option>
                        <option value="llama2:latest">LLaMA 2 7B (Quality)</option>
                        <option value="tinyllama:latest" selected>TinyLlama (Ultra Fast)</option>
                        <option value="grok-4">Grok-4 (Premium Cloud)</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                    <label for="stt-language">Speech Language</label>
                    <select id="stt-language">
                        <option value="auto">Auto-detect</option>
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block;">
                    <label for="voice-engine">Voice Engine</label>
                    <select id="voice-engine" onchange="switchVoiceEngine()">
                        <option value="chatterbox">Chatterbox TTS (High Quality + Voice Cloning)</option>
                        <option value="edge_tts">Edge TTS (Fast + Many Voices)</option>
                        <option value="elevenlabs" selected>ElevenLabs (Premium + Ultra Fast)</option>
                    </select>
                </div>
            </div>

            <!-- Voice Selection -->
            <div class="ai-settings" style="margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 200px;">
                    <label for="voice-select" id="voice-select-label">Voice:</label>
                    <select id="voice-select" onchange="updateVoiceSelection()">
                        <option value="loading">Loading voices...</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block;">
                    <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: rgba(255, 255, 255, 0.8); cursor: pointer;">
                        <input type="checkbox" id="tts-enabled" checked style="accent-color: #3b82f6;" onchange="toggleTTSEnabled()">
                        <span id="tts-enable-label">Enable Voice Synthesis</span>
                    </label>
                </div>
            </div>

            <!-- Chatterbox-specific controls -->
            <div id="chatterbox-controls" class="ai-settings" style="margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">Chatterbox Voice Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="emotion-slider" style="font-size: 12px;">Emotion Level: <span id="emotion-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>😐</span>
                        <input type="range" id="emotion-slider" min="0" max="100" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateEmotion(this.value)">
                        <span>🎭</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="pacing-slider" style="font-size: 12px;">Speech Pacing: <span id="pacing-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🐌</span>
                        <input type="range" id="pacing-slider" min="30" max="70" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updatePacing(this.value)">
                        <span>🚀</span>
                    </div>
                </div>
            </div>

            <!-- Edge TTS-specific controls -->
            <div id="edge-controls" class="ai-settings" style="display: none; margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">Edge TTS Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="edge-speed" style="font-size: 12px;">Speech Speed: <span id="speed-value">100%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🐌</span>
                        <input type="range" id="edge-speed" min="50" max="200" value="100" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateSpeed(this.value)">
                        <span>🚀</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="edge-pitch" style="font-size: 12px;">Pitch: <span id="pitch-value">0Hz</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔽</span>
                        <input type="range" id="edge-pitch" min="-10" max="10" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updatePitch(this.value)">
                        <span>🔼</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="edge-volume" style="font-size: 12px;">Volume: <span id="volume-value">0%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔉</span>
                        <input type="range" id="edge-volume" min="-20" max="20" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateVolume(this.value)">
                        <span>🔊</span>
                    </div>
                </div>
            </div>

            <!-- ElevenLabs-specific controls -->
            <div id="elevenlabs-controls" class="ai-settings" style="display: none; margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">ElevenLabs Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-stability" style="font-size: 12px;">Stability: <span id="stability-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🎯</span>
                        <input type="range" id="elevenlabs-stability" min="0" max="100" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateStability(this.value)">
                        <span>🏔️</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-similarity" style="font-size: 12px;">Similarity Boost: <span id="similarity-value">75%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔀</span>
                        <input type="range" id="elevenlabs-similarity" min="0" max="100" value="75" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateSimilarity(this.value)">
                        <span>🎭</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-style" style="font-size: 12px;">Style Intensity: <span id="style-value">0%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>📖</span>
                        <input type="range" id="elevenlabs-style" min="0" max="100" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateStyle(this.value)">
                        <span>🎨</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="elevenlabs-model" style="font-size: 12px;">Model:</label>
                    <select id="elevenlabs-model" onchange="updateModel(this.value)">
                        <option value="eleven_turbo_v2" selected>Turbo v2 (Fastest)</option>
                        <option value="eleven_monolingual_v1">Monolingual v1 (Quality)</option>
                        <option value="eleven_multilingual_v2">Multilingual v2 (Multi-lang)</option>
                    </select>
                </div>
            </div>

            <div id="applied-filters-display" class="applied-filters hidden" style="margin-top: 15px; background: rgba(59, 130, 246, 0.2); border: 2px solid rgba(59, 130, 246, 0.5); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <div style="margin-bottom: 8px; font-weight: bold; color: #1e40af; background: rgba(255, 255, 255, 0.8); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(30, 64, 175, 0.3);">AI Applied Filters:</div>
                <div id="filter-chips-container"></div>
                <div id="filter-rationale" style="margin-top: 8px; font-size: 12px; color: #374151; opacity: 0.9;"></div>
            </div>
        </div>
        
        <div class="ai-drawer-content">
            <div id="chat-conversation" class="chat-conversation">
                <div id="chat-empty-state" class="chat-empty-state">
                    <h3>Start a conversation</h3>
                    <p>Ask questions about your data and I'll help you find answers!</p>
                </div>
                <div id="chat-messages"></div>
            </div>

            <div class="chat-input-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div class="ai-status" id="ai-status" style="flex: 1; margin-bottom: 0; margin-right: 10px;">
                        <div id="ai-status-text">Ready to answer questions!</div>
                    </div>
                    <button onclick="clearConversation()" class="btn-secondary btn-small" style="background: #6b7280; border: 1px solid #9ca3af; color: white; margin: 0;">
                        Clear Chat
                    </button>
                </div>
                
                <div class="chat-input-row">
                    <button id="mic-btn" onclick="toggleRecording()" class="mic-btn" title="Click to record voice message">
                        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <path d="M50,10 C43.373,10 38,15.373 38,22 L38,50 C38,56.627 43.373,62 50,62 C56.627,62 62,56.627 62,50 L62,22 C62,15.373 56.627,10 50,10 Z M50,15 C53.866,15 57,18.134 57,22 L57,50 C57,53.866 53.866,57 50,57 C46.134,57 43,53.866 43,50 L43,22 C43,18.134 46.134,15 50,15 Z M20,45 L20,50 C20,66.568 33.432,80 50,80 C66.568,80 80,66.568 80,50 L80,45 L85,45 L85,50 C85,69.33 69.33,85 50,85 L50,90 L60,90 L60,95 L40,95 L40,90 L50,90 L50,85 C30.67,85 15,69.33 15,50 L15,45 L20,45 Z"/>
                        </svg>
                    </button>
                    <textarea id="ai-chat-input" placeholder="Ask a question about your data or click the microphone..." onkeydown="handleChatKeydown(event)" rows="1"></textarea>
                    <button id="ai-chat-send-btn" onclick="sendChatMessage()" class="chat-send-btn">
                        <span>Ask AI</span>
                    </button>
                </div>
                <div style="margin-top: 8px; font-size: 12px; opacity: 0.9; display: flex; gap: 8px; align-items: center;">
                    <label for="alfred-pinned-did" style="min-width: 120px;">Pinned Record DID:</label>
                    <input id="alfred-pinned-did" type="text" placeholder="did:arweave:... (optional)" style="flex:1; padding:6px; border-radius:4px; border:1px solid #888;" onchange="onPinnedDidChange(this.value)" />
                    <button class="btn-small" onclick="clearPinnedDid()">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="main-content">
        <!-- Welcome Interface -->
        <div id="welcome-interface" class="welcome-interface">
            <h1 class="welcome-title">ΛLΞXΛNDRIΛ</h1>
            <p class="welcome-subtitle">A decentralized library of art, history, knowledge and memes.</p>
            
            <div class="welcome-search">
                <input type="text" id="welcome-search-input" placeholder="Search the archive..." onkeydown="handleWelcomeSearch(event)">
                <div class="advanced-search-toggle">
                    <button onclick="showAdvancedSearch()">Advanced Search</button>
                </div>
            </div>
            
            <div id="categories-grid" class="categories-grid">
                <!-- Categories will be populated dynamically from recordTypes -->
            </div>
        </div>

        <!-- Search Interface -->
        <div id="search-interface" class="container hidden">
            <!-- Filters Section (Enhanced Version) -->
            <div class="filters-section" style="position: relative; z-index: 1; background: white; border: 2px solid rgba(102, 126, 234, 0.1);">
                <!-- Hidden search input for backward compatibility -->
                <input type="hidden" id="voice-search-input" value="">
                
                <div class="filters-row">
                    <div class="filter-group">
                        <label for="voice-record-type-filter">Record Type</label>
                        <select id="voice-record-type-filter" onchange="applyVoiceFilters()">
                            <option value="">All Types</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-storage-filter">Storage Type</label>
                        <select id="voice-storage-filter" onchange="applyVoiceFilters()">
                            <option value="all">All Sources</option>
                            <option value="arweave">Arweave (Permanent)</option>
                            <option value="gun">GUN (Private/Drafts)</option>
                            <option value="irys">Irys (Permanent)</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-search-match-mode" title="Controls how search terms are matched">
                            Search Mode
                            <span style="opacity: 0.6; font-size: 0.8rem;">(?)</span>
                        </label>
                        <select id="voice-search-match-mode" onchange="applyVoiceFilters()" 
                                title="AND = all terms required, OR = any term matches">
                            <option value="AND">Match ALL terms</option>
                            <option value="OR">Match ANY term</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-resolve-depth" title="Higher values resolve more linked records. Set to 1+ to see recipe images.">
                            Resolve Depth
                            <span style="opacity: 0.6; font-size: 0.8rem;">(?)</span>
                        </label>
                        <input type="number" id="voice-resolve-depth" value="2" min="0" max="5" onchange="applyVoiceFilters()" 
                               title="2 recommended for images. 0=fastest, 5=most complete">
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-did-tx">DID TX</label>
                        <input type="text" id="voice-did-tx" placeholder="did:arweave:..." onchange="validateAndApplyDidTx()" oninput="clearDidTxError()">
                        <div id="did-tx-error" class="hidden" style="color: #dc3545; font-size: 0.8rem; margin-top: 4px;">Please provide a valid DID address</div>
                    </div>
                </div>
                
                <div class="filters-row">
                    <div class="filter-group compact">
                        <label>Date Range</label>
                        <div class="date-inputs">
                            <input type="date" id="voice-date-start" onchange="applyVoiceFilters()" placeholder="Start Date">
                            <span>to</span>
                            <input type="date" id="voice-date-end" onchange="applyVoiceFilters()" placeholder="End Date">
                        </div>
                    </div>
                    
                    <div class="filter-group wide">
                        <label for="multi-tag-container">Filter by Tags</label>
                        <div id="multi-tag-container" class="multi-tag-container">
                            <!-- Tag Match Mode Selector -->
                            <div class="tag-mode-selector">
                                <label for="tag-match-mode">Match:</label>
                                <select id="tag-match-mode" onchange="applyVoiceFilters()">
                                    <option value="OR">ANY tag (OR)</option>
                                    <option value="AND">ALL tags (AND)</option>
                                </select>
                            </div>
                            
                            <!-- Tag Filters Container -->
                            <div id="tag-filters-container" class="tag-filters-container">
                                <div class="tag-filter-row" data-tag-index="0">
                                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                                        <option value="">Select a tag...</option>
                                    </select>
                                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                                </div>
                            </div>
                            
                            <!-- Legacy single tag filter (hidden) for backward compatibility -->
                            <select id="voice-tag-filter" style="display: none;">
                                <option value="">All Tags</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="advanced-filters">
                    <div class="toggle-row">
                        <div class="toggle-group">
                            <label>Include Signatures:</label>
                            <div class="toggle-switch" id="voice-include-sigs-toggle" onclick="toggleVoiceSwitch('voice-include-sigs-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Include Public Keys:</label>
                            <div class="toggle-switch" id="voice-include-pubkeys-toggle" onclick="toggleVoiceSwitch('voice-include-pubkeys-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Includes Audio:</label>
                            <div class="toggle-switch" id="voice-includes-audio-toggle" onclick="toggleVoiceSwitch('voice-includes-audio-toggle')"></div>
                        </div>
                        
                        <button onclick="clearVoiceFilters()" class="btn-secondary btn-small">Clear Filters</button>
                        <button onclick="applyVoiceFilters()" class="btn-small">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Records Display (Enhanced Version) -->
            <div class="records-container">
                <div id="voice-records-header">
                    <div class="records-header-left">
                        <h2>OIP Records</h2>
                        <div id="voice-pagination-info" class="pagination-info"></div>
                    </div>
                    <div class="records-header-right">
                        <div class="header-control-group">
                            <label for="voice-sort-by">Sort By</label>
                            <select id="voice-sort-by" onchange="applyVoiceFilters()">
                                <option value="matchCount:desc" selected>Relevance (Highest)</option>
                                <option value="matchCount:asc">Relevance (Lowest)</option>
                                <option value="inArweaveBlock:desc">Block (Newest)</option>
                                <option value="inArweaveBlock:asc">Block (Oldest)</option>
                                <option value="date:desc">Date (Newest)</option>
                                <option value="date:asc">Date (Oldest)</option>
                            </select>
                        </div>
                        <div class="header-control-group">
                            <label for="voice-view-as">View As</label>
                            <select id="voice-view-as" onchange="changeViewMode()">
                                <option value="grid">Grid</option>
                                <option value="list">List</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div id="voice-loading-indicator" class="loading">
                    <div class="spinner"></div>
                    Loading records...
                </div>
                
                <div id="voice-records-grid" class="records-grid hidden"></div>
                
                <div id="voice-no-results" class="no-results hidden">
                    No records found matching your criteria.
                </div>
                
                <div id="voice-load-more-container" class="load-more hidden">
                    <button onclick="loadMoreVoiceRecords()" id="voice-load-more-btn">Load More Records</button>
                </div>
            </div>
        </div>

        <!-- Publish Tab Content -->
        <div id="publish-tab" class="container hidden">
            <div class="section">
                <h2>Publishing Platform</h2>
                <p>Please log in to access publishing features.</p>
                
                <div id="publishing-content" class="hidden">
                    <div class="filters-row">
                        <button onclick="showCreatorRegistration()">Register Creator</button>
                        <button onclick="showTemplateCreation()">Create Template</button>
                        <button onclick="showRecordPublishing()">Publish Record</button>
                    </div>
                </div>
            </div>

            <!-- Creator Registration -->
            <div id="creator-section" class="section hidden">
                <h2>Creator Registration</h2>
                <div class="form-group">
                    <label for="creator-name">Creator Name:</label>
                    <input type="text" id="creator-name" required>
                </div>
                <div class="form-group">
                    <label for="creator-description">Description:</label>
                    <textarea id="creator-description"></textarea>
                </div>
                <div class="form-group">
                    <label for="creator-email">Email:</label>
                    <input type="email" id="creator-email">
                </div>
                <div class="form-group">
                    <label for="creator-website">Website:</label>
                    <input type="url" id="creator-website">
                </div>
                <button onclick="registerCreator()">Register Creator</button>
                <div id="creator-status" class="error-message hidden"></div>
                <div id="creator-success" class="success-message hidden"></div>
            </div>

            <!-- Template Creation -->
            <div id="template-section" class="section hidden">
                <h2>Template Creation</h2>
                <div class="form-group">
                    <label for="template-name">Template Name:</label>
                    <input type="text" id="template-name" required>
                </div>
                <div class="form-group">
                    <label for="template-recordtype">Record Type:</label>
                    <input type="text" id="template-recordtype" required placeholder="e.g., post, recipe, workout">
                </div>
                <div class="dynamic-fields">
                    <h3>Template Fields</h3>
                    <div id="template-fields">
                        <div class="field-row">
                            <div>
                                <label>Field Name:</label>
                                <input type="text" class="field-name" placeholder="e.g., title, content">
                            </div>
                            <div>
                                <label>Field Type:</label>
                                <select class="field-type">
                                    <option value="string">String</option>
                                    <option value="number">Number</option>
                                    <option value="boolean">Boolean</option>
                                    <option value="enum">Enum</option>
                                    <option value="array">Array</option>
                                </select>
                            </div>
                            <div>
                                <button type="button" onclick="removeField(this)">Remove</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" onclick="addTemplateField()">Add Field</button>
                </div>
                <button onclick="createTemplate()">Create Template</button>
                <div id="template-status" class="error-message hidden"></div>
                <div id="template-success" class="success-message hidden"></div>
            </div>

            <!-- Record Publishing -->
            <div id="record-section" class="section hidden">
                <h2>Publish Record</h2>
                
                                    <!-- Record Type Selection -->
                    <div class="form-group">
                        <label for="publish-record-type">Record Type:</label>
                        <select id="publish-record-type" onchange="loadPublishInterface()">
                            <option value="">Select Record Type</option>
                            <option value="post">Post / Article</option>
                            <option value="video">Video</option>
                            <option value="audio">Audio / Podcast</option>
                            <option value="image">Image</option>
                            <option value="recipe">Recipe</option>
                            <option value="workout">Workout</option>
                            <option value="exercise">Exercise</option>
                            <option value="fitnessEquipment">Fitness Equipment</option>
                            <option value="media">Media File</option>
                            <option value="multiResolutionGif">Multi-Resolution GIF</option>
                            <option value="text">Text Document</option>
                            <option value="organization">Organization</option>
                        </select>
                    </div>

                    <!-- Storage Type Selection -->
                    <div class="form-group">
                        <label for="publish-storage-type">Storage Type:</label>
                        <select id="publish-storage-type">
                            <option value="arweave">Arweave (Permanent & Public)</option>
                            <option value="gun">GUN + BitTorrent (Private with P2P Distribution)</option>
                            <option value="irys">Irys (Permanent & Fast)</option>
                        </select>
                        <small>
                            <strong>Arweave:</strong> Permanent, public, immutable storage<br>
                            <strong>GUN + BitTorrent:</strong> Private storage with automatic BitTorrent distribution for P2P sharing<br>
                            <strong>Irys:</strong> Permanent, fast confirmation
                        </small>
                    </div>

                <!-- Dynamic Publishing Interface -->
                <div id="publish-interface" class="dynamic-fields">
                    <div class="loading">Select a record type to see publishing interface</div>
                </div>
                
                <div id="publish-status" class="error-message hidden"></div>
                <div id="publish-success" class="success-message hidden"></div>
            </div>
        </div>

        <!-- Individual Record View Interface -->
        <div id="record-view-interface" class="container hidden">
            <div class="record-view-header">
                <button onclick="goBackToBrowse()" class="back-btn">
                    ← Back to Browse
                </button>
                <div class="record-view-meta">
                    <span id="record-view-type" class="record-type-badge"></span>
                    <span id="record-view-did" class="record-did-badge"></span>
                </div>
            </div>
            
            <div id="record-view-content" class="record-view-content">
                <!-- Record content will be dynamically loaded here -->
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="auth-modal" class="modal hidden">
        <div class="modal-content">
            <div id="login-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" required>
                </div>
                <button onclick="login()">Login</button>
                <button onclick="showRegisterForm()" class="btn-secondary">Register Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="register-form" class="hidden">
                <h2>Register</h2>
                <div class="form-group">
                    <label for="register-email">Email:</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password:</label>
                    <input type="password" id="register-password" required>
                </div>
                <button onclick="register()">Register</button>
                <button onclick="showLoginForm()" class="btn-secondary">Login Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="auth-status" class="error-message hidden"></div>
            <div id="auth-success" class="success-message hidden"></div>
        </div>
    </div>

    <!-- JWT Token Modal -->
    <div id="jwt-modal" class="modal hidden">
        <div class="modal-content">
            <h2>JWT Token Authentication</h2>
            <p style="color: #666; margin-bottom: 20px;">
                Enter your JWT token to access private GUN records and media uploads.
                <br><small>Get your token by logging in via the API or registering a new account.</small>
            </p>
            
            <div class="form-group">
                <label for="jwt-token-input">JWT Token:</label>
                <textarea id="jwt-token-input" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." 
                         style="height: 80px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="jwt-remember" checked>
                    Remember token in localStorage
                </label>
            </div>
            
            <div class="button-group">
                <button onclick="setJWTToken()" class="btn-primary">Set Token</button>
                <button onclick="clearJWTToken()" class="btn-secondary">Clear Token</button>
                <button onclick="hideJWTModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="jwt-token-status" class="status-message" style="margin-top: 15px;"></div>
            
            <details style="margin-top: 20px;">
                <summary style="cursor: pointer; color: #666;">How to get a JWT token</summary>
                <div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px;">
                    <p><strong>Option 1: Register via API</strong></p>
                    <pre style="background: #fff; padding: 8px; border-radius: 4px; overflow-x: auto;">POST /api/user/completeRegistration
{
  "email": "your@email.com",
  "password": "your_password"
}</pre>
                    
                    <p style="margin-top: 15px;"><strong>Option 2: Login via API</strong></p>
                    <pre style="background: #fff; padding: 8px; border-radius: 4px; overflow-x: auto;">POST /api/user/login
{
  "email": "your@email.com", 
  "password": "your_password"
}</pre>
                    
                    <p style="margin-top: 10px; color: #666;">
                        The API will return a JWT token that includes your HD wallet public key for private record access.
                    </p>
                </div>
            </details>
        </div>
    </div>

    <!-- Master Audio Player -->
    <div id="master-audio-player" class="master-audio-player">
        <div class="audio-player-content">
            <div class="audio-info">
                <div class="audio-title" id="audio-title">No audio selected</div>
                <div class="audio-meta" id="audio-meta">Select an audio file to play</div>
            </div>
            
            <div class="audio-controls">
                <button onclick="toggleAudioPlayback()" id="master-play-btn">▶️</button>
                <button onclick="stopAudio()">⏹️</button>
                <div class="audio-progress" onclick="seekAudio(event)">
                    <div class="audio-progress-bar" id="audio-progress-bar"></div>
                </div>
                <div class="audio-time" id="audio-time">0:00 / 0:00</div>
                <button onclick="closeMasterPlayer()">✕</button>
            </div>
        </div>
        
        <audio id="master-audio" style="display: none;" 
               ontimeupdate="updateAudioProgress()" 
               onended="onAudioEnded()"
               onloadedmetadata="onAudioLoaded()">
        </audio>
    </div>

    <script>
        // State management
        let authToken = localStorage.getItem('oip-auth-token');
        let currentUser = localStorage.getItem('oip-user-email');
        let templates = {};
        let defaultTemplates = {};
        // Enhanced template system variables
        let allTemplates = {}; // Maps template names and TxIds to template objects
        let templateFieldMap = {}; // Maps template names and TxIds to field definitions
        let showDebugInfo = false; // Controls debug information display
        let recordTypes = [];
        let currentRecords = [];
        let currentPage = 1;
        let isLoading = false;
        let hasMoreRecords = true;
        let currentFilters = {
            search: '',
            recordType: '',
            sortBy: 'date:desc',
            resolveDepth: 2,
            dateStart: '',
            dateEnd: '',
            tag: '',
            includeSigs: false,
            includePubKeys: false
        };
        let availableTags = [];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            console.log('[App] Starting enhanced initialization with dynamic templates...');
            
            // Initialize JWT token from localStorage
            initializeJWTToken();
            
            // Always load templates first for dynamic rendering
            await loadTemplates();
            
            // Setup authentication state
            if (authToken && currentUser) {
                showLoggedInState();
            }
            
            // Load actual record types from the index
            await loadActualRecordTypes();
            
            // Force hide the old browse tab and ensure it stays hidden
            forcehideBrowseTab();
            
            // Initialize URL routing
            initializeRouting();
            
            // Don't show welcome interface by default anymore - let routing handle it
            // showWelcomeInterface();
            
            console.log('[App] Initialized with enhanced dynamic template system');
            
            // Set up periodic checks to ensure interface stays clean
            setInterval(() => {
                forcehideBrowseTab();
                
                // Quick check that chat input is still visible
                const chatInput = document.getElementById('ai-chat-input');
                if (chatInput && (chatInput.offsetHeight === 0 || chatInput.style.display === 'none')) {
                    console.log('[App] Detected hidden chat input, restoring...');
                    ensureChatInputReady();
                }
            }, 2000); // Check every 2 seconds
        }

        // Load actual record types from the index
        async function loadActualRecordTypes() {
            try {
                console.log('[App] Loading actual record types from index...');
                const response = await fetch('/api/records/recordTypes');
                const data = await response.json();
                
                if (response.ok && data.recordTypes) {
                    console.log('[App] Loaded record types:', data.recordTypes);
                    
                    // Store the actual record types with counts
                    recordTypes = data.recordTypes.map(rt => rt.recordType).sort();
                    
                    // Populate all record type dropdowns
                    populateAllRecordTypeDropdowns(data.recordTypes);
                    
                    console.log('[App] Populated record type dropdowns with', recordTypes.length, 'types');
                } else {
                    console.error('[App] Failed to load record types:', data.error || 'Unknown error');
                    // Fallback to basic types if API fails
                    recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                    populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
                }
            } catch (error) {
                console.error('[App] Error loading record types:', error);
                // Fallback to basic types if API fails
                recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
            }
        }

        // Populate all record type dropdowns with actual data
        function populateAllRecordTypeDropdowns(recordTypesData) {
            // Voice browse tab dropdown
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    voiceSelect.appendChild(option);
                });
                console.log('[App] Populated voice record type filter with', recordTypesData.length, 'types');
            }
            
            // Publishing record type dropdown
            const publishSelect = document.getElementById('record-type');
            if (publishSelect) {
                // Keep the first option as "Select Record Type"
                const firstOption = publishSelect.querySelector('option[value=""]');
                publishSelect.innerHTML = '';
                if (firstOption) {
                    publishSelect.appendChild(firstOption);
                } else {
                    publishSelect.innerHTML = '<option value="">Select Record Type</option>';
                }
                
                // Add actual record types
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    publishSelect.appendChild(option);
                });
                console.log('[App] Populated publishing record type filter with', recordTypesData.length, 'types');
            }
            
            // Populate categories grid
            populateCategoriesGrid(recordTypesData);
        }
        
        // Populate the categories grid dynamically from recordTypes
        function populateCategoriesGrid(recordTypesData) {
            const grid = document.getElementById('categories-grid');
            if (!grid) return;
            
            // Icon mapping for different record types - using SVG icons
            const iconMap = {
                'post': '<img src="noun-copywriting-4038314-9B9B9B.svg" alt="Post" style="width: 40px; height: 40px;">',
                'video': '📹', 
                'audio': '<img src="noun-speaker-1445776-9B9B9B.svg" alt="Audio" style="width: 40px; height: 40px;">',
                'recipe': '<img src="noun-plate-4303489-9B9B9B.svg" alt="Recipe" style="width: 40px; height: 40px;">',
                'workout': '💪',
                'podcast': '<img src="noun-podcast-7882058-9B9B9B.svg" alt="Podcast" style="width: 40px; height: 40px;">',
                'movie': '🎬',
                'music': '🎵',
                'book': '📚',
                'document': '📄',
                'software': '💻',
                'archive': '🗃️',
                'thing': '🏛️'
            };
            
            // Record types to exclude from home page buttons
            const excludedTypes = ['deletemessage', 'replyto', 'nutritionalinfo', 'image', 'text', 'audioitems', 'imageitems', 'videoitems', '0', 'featuredimage', 'delete'];
            
            grid.innerHTML = '';
            
            // If no recordTypes data, show default categories
            if (!recordTypesData || recordTypesData.length === 0) {
                const defaultTypes = [
                    { recordType: 'post', count: 0 },
                    { recordType: 'video', count: 0 },
                    { recordType: 'audio', count: 0 },
                    { recordType: 'recipe', count: 0 },
                    { recordType: 'workout', count: 0 }
                ];
                recordTypesData = defaultTypes;
            }
            
            // Filter out excluded types and sort by count (descending)
            const filteredTypes = recordTypesData
                .filter(rt => !excludedTypes.includes(rt.recordType.toLowerCase()))
                .sort((a, b) => b.count - a.count)
                .slice(0, 12); // Limit to 12 categories max
            
            filteredTypes.forEach(rt => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category-item';
                categoryDiv.onclick = () => searchByRecordType(rt.recordType);
                
                const icon = iconMap[rt.recordType] || '📋';
                const label = rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1);
                
                categoryDiv.innerHTML = `
                    <div class="category-icon">${icon}</div>
                    <div class="category-label">${label}</div>
                `;
                
                grid.appendChild(categoryDiv);
            });
            
            console.log('[App] Populated categories grid with', filteredTypes.length, 'categories (excluded:', excludedTypes.join(', '), ')');
        }

        // Legacy function - now redirects to new implementation
        async function loadRecordTypes() {
            console.log('[App] Legacy loadRecordTypes called - redirecting to loadActualRecordTypes');
            await loadActualRecordTypes();
        }

        // Legacy function - now uses new implementation
        function populateRecordTypeFilter() {
            console.log('[App] Legacy populateRecordTypeFilter called - record types already populated');
        }

        // Legacy function - now uses new implementation
        function populateVoiceRecordTypeFilter(recordTypes) {
            console.log('[App] Legacy populateVoiceRecordTypeFilter called - record types already populated');
        }

        // Force hide the old browse tab completely
        function forcehideBrowseTab() {
            const browseTab = document.getElementById('browse-tab');
            if (browseTab) {
                browseTab.style.display = 'none !important';
                browseTab.style.visibility = 'hidden !important';
                browseTab.style.height = '0 !important';
                browseTab.style.overflow = 'hidden !important';
                browseTab.style.position = 'absolute !important';
                browseTab.style.top = '-9999px !important';
                browseTab.classList.add('hidden');
                console.log('[App] Old browse tab forcefully hidden');
            }
        }

        // Navigation functions (Updated for new interface)
        function showWelcomeInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            // No tab should be active when on home/welcome
            
            document.getElementById('welcome-interface').classList.remove('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        function showSearchInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[0].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.remove('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Show header search when on browse tab
            showHeaderSearch();
            
            // Ensure filters start in drawer, not on page
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            const filtersSection = document.querySelector('.filters-section');
            
            if (filtersSection && !drawer.contains(filtersSection)) {
                // Move filters to drawer initially
                document.querySelector('.filters-drawer-content').appendChild(filtersSection);
                drawer.classList.remove('open');
                toggle.classList.remove('active');
            }
            
            // Sync search values
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                headerSearch.value = hiddenSearch.value;
            }
            
            // Initialize voice features when search interface is shown
            initializeVoiceFeatures();
        }

        // URL Routing Functions
        function initializeRouting() {
            // Handle browser back/forward buttons
            window.addEventListener('popstate', (event) => {
                console.log('[Routing] Handling popstate:', event.state);
                handleUrlChange();
            });
            
            // Handle initial page load
            handleUrlChange();
        }

        function handleUrlChange() {
            const hash = window.location.hash.substr(1); // Remove the #
            console.log('[Routing] Handling URL change:', hash);
            
            if (hash.startsWith('browse/record=')) {
                // Individual record view
                const truncatedDidTx = hash.replace('browse/record=', '');
                // We need to reconstruct the full DID since we only have the truncated version
                // For now, we'll try to find it from current records or load it
                handleRecordNavigation(truncatedDidTx);
            } else if (hash === 'browse' || hash === '') {
                // Browse/search interface
                showSearchInterface();
            } else {
                // Default to browse interface
                showSearchInterface();
            }
        }

        async function handleRecordNavigation(truncatedDidTx) {
            console.log('[Routing] Handling record navigation for:', truncatedDidTx);
            
            // First try to find the record in current records
            const foundRecord = currentRecords.find(record => {
                const didTx = record.oip?.did || record.oip?.didTx || '';
                const recordTruncated = didTx.replace('did:arweave:', '').substring(0, 7);
                return recordTruncated === truncatedDidTx;
            });
            
            if (foundRecord) {
                console.log('[Routing] Found record in current records');
                showRecordView(foundRecord.oip.didTx, foundRecord);
            } else {
                // Try to search for records that match this truncated DID
                console.log('[Routing] Searching for record with truncated DID:', truncatedDidTx);
                try {
                    const response = await fetch(`/api/records?limit=50&resolveDepth=3`);
                    const data = await response.json();
                    
                    if (data.records) {
                        const matchingRecord = data.records.find(record => {
                            const didTx = record.oip?.did || record.oip?.didTx || '';
                            const recordTruncated = didTx.replace('did:arweave:', '').substring(0, 7);
                            return recordTruncated === truncatedDidTx;
                        });
                        
                        if (matchingRecord) {
                            console.log('[Routing] Found matching record via search');
                            showRecordView(matchingRecord.oip.didTx, matchingRecord);
                        } else {
                            console.log('[Routing] No matching record found, redirecting to browse');
                            showSearchInterface();
                        }
                    } else {
                        console.log('[Routing] No records found, redirecting to browse');
                        showSearchInterface();
                    }
                } catch (error) {
                    console.error('[Routing] Error searching for record:', error);
                    showSearchInterface();
                }
            }
        }

        function showPublishTab() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[1].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.remove('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        // Record View Navigation Functions
        function showRecordView(didTx, record = null) {
            console.log('[RecordView] Showing record view for:', didTx);
            
            // Update URL
            const truncatedDidTx = didTx.replace('did:arweave:', '').substring(0, 7);
            window.history.pushState({ view: 'record', didTx: didTx }, '', `#browse/record=${truncatedDidTx}`);
            
            // Hide all interfaces and nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.remove('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Hide header search
            hideHeaderSearch();
            
            // Load record if not provided
            if (record) {
                displayRecordView(record);
            } else {
                loadRecordForView(didTx);
            }

            // If ALFRED drawer is open, set pinned record DID to this record
            try {
                const drawer = document.getElementById('ai-drawer');
                if (drawer && drawer.classList.contains('open')) {
                    window.__alfredPinnedDid = didTx;
                    const pinnedInput = document.getElementById('alfred-pinned-did');
                    if (pinnedInput) pinnedInput.value = didTx;
                }
            } catch (e) {
                console.warn('[RecordView] Unable to set pinned DID for ALFRED:', e);
            }
        }

        function goBackToBrowse() {
            console.log('[RecordView] Going back to browse');
            
            // Update URL
            window.history.pushState({ view: 'browse' }, '', '#browse');
            
            // Show search interface
            showSearchInterface();
        }

        async function loadRecordForView(didTx) {
            try {
                console.log('[RecordView] Loading record:', didTx);
                document.getElementById('record-view-content').innerHTML = '<div class="loading" style="text-align: center; padding: 40px;">Loading record...</div>';
                
                const response = await fetch(`/api/records?didTx=${encodeURIComponent(didTx)}&resolveDepth=3&limit=1`);
                const data = await response.json();
                
                if (data.records && data.records.length > 0) {
                    displayRecordView(data.records[0]);
                } else {
                    document.getElementById('record-view-content').innerHTML = '<div class="error" style="text-align: center; padding: 40px; color: #dc3545;">Record not found</div>';
                }
            } catch (error) {
                console.error('[RecordView] Error loading record:', error);
                document.getElementById('record-view-content').innerHTML = '<div class="error" style="text-align: center; padding: 40px; color: #dc3545;">Error loading record</div>';
            }
        }

        function displayRecordView(record) {
            console.log('[RecordView] Displaying record:', record);
            
            const recordType = record.oip?.recordType || 'unknown';
            const didTx = record.oip?.didTx || 'Unknown';
            const truncatedDidTx = didTx.replace('did:arweave:', '').substring(0, 7);
            
            // Update header meta
            document.getElementById('record-view-type').textContent = recordType;
            document.getElementById('record-view-did').textContent = `...${truncatedDidTx}`;
            
            // Render content based on record type
            if (recordType === 'post') {
                displayPostRecord(record);
            } else {
                // For now, show a generic view for other record types
                displayGenericRecord(record);
            }
        }

        function displayPostRecord(record) {
            console.log('[RecordView] Displaying post record:', record);
            
            const basicData = record.data?.basic || {};
            const postData = record.data?.post || {};
            
            // Extract title, description, and other basic info
            const title = basicData.name || postData.title || 'Untitled Post';
            const description = basicData.description || postData.summary || '';
            const date = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            const byline = postData.bylineWriter || 'Unknown Author';
            const tags = basicData.tagItems || [];
            
            // Extract media content
            const mediaContent = extractMediaContent(record);
            
            let html = `<div class="post-article-layout">`;
            
            // Article Header
            html += `<div class="post-article-header">`;
            html += `<h1 class="post-article-title">${escapeHtml(title)}</h1>`;
            
            html += `<div class="post-article-meta">
                <div class="post-article-byline">By <strong>${escapeHtml(byline)}</strong></div>
                <div class="post-article-date">${escapeHtml(date)}</div>
            </div>`;
            html += `</div>`;
            
            // Content wrapper with floating image and text wrap
            html += `<div class="post-content-wrapper">`;
            
            // Featured Media Section - Image floated left
            if (mediaContent.featuredImage) {
                const img = mediaContent.featuredImage;
                html += `<div class="post-featured-media">
                    <img src="${img.url}" alt="${escapeHtml(img.alt || 'Featured Image')}" 
                         class="post-featured-image" 
                         onerror="this.style.display='none';">
                </div>`;
            }
            
            // Summary with attached audio section
            html += `<div class="post-summary-with-audio">`;
            
            // Collapsible summary with "Keep Reading" button
            if (description) {
                const summaryId = `summary-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}`;
                html += `<div class="post-article-summary collapsed" id="${summaryId}">${escapeHtml(description)}</div>`;
                html += `<button class="keep-reading-btn" onclick="toggleSummary('${summaryId}', this)" id="${summaryId}-btn">Keep Reading</button>`;
            }
            
            // Featured Audio Section - Attached to summary
            if (mediaContent.featuredAudio || mediaContent.audioItems?.length > 0) {
                const audio = mediaContent.featuredAudio || mediaContent.audioItems[0];
                if (audio) {
                    html += `<div class="post-audio-section">
                        <div class="post-audio-controls">
                            <button class="play-btn primary" 
                                    onclick="playAudioInMaster('${audio.url}', '${escapeHtml(audio.title || title)}', 'post', 'record-view')"
                                    id="record-view-audio-btn">
                                ▶ Play Summary
                            </button>
                            ${audio.duration ? `<span class="audio-duration">${audio.duration}</span>` : ''}
                        </div>
                    </div>`;
                }
            }
            
            html += `</div>`; // End post-summary-with-audio
            
            // Featured Video Section (if present, below summary)
            if (mediaContent.featuredVideo) {
                const video = mediaContent.featuredVideo;
                html += `<div style="clear: both; margin: 20px 0;">
                    <video src="${video.url}" controls class="post-featured-video" 
                           poster="${video.thumbnail || ''}">
                        Your browser does not support the video tag.
                    </video>
                </div>`;
            }
            
            // Article Content - Auto-load article text
            html += `<div class="post-content" id="post-content-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}">`;
            
            // Try to get article text content and load it automatically
            let articleContent = '';
            let shouldLoadArticle = false;
            let articleUrl = '';
            
            if (postData.articleText) {
                if (typeof postData.articleText === 'string') {
                    articleContent = postData.articleText;
                } else if (postData.articleText.data?.text?.webUrl) {
                    // This is a dref to a text record - load it automatically
                    articleUrl = postData.articleText.data.text.webUrl;
                    shouldLoadArticle = true;
                    html += `<div class="article-loading">📄 Loading full article text...</div>`;
                } else if (postData.articleText.webUrl) {
                    // Direct text URL - load it automatically
                    articleUrl = postData.articleText.webUrl;
                    shouldLoadArticle = true;
                    html += `<div class="article-loading">📄 Loading full article text...</div>`;
                }
            }
            
            if (articleContent) {
                // Convert plain text to HTML with basic formatting
                const formattedContent = articleContent
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');
                html += `<div class="article-text"><p>${formattedContent}</p></div>`;
            } else if (!postData.articleText) {
                html += `<p><em>No article content available.</em></p>`;
            }
            
            html += `</div>`; // End post-content
            
            html += `</div>`; // End post-content-wrapper
            
            // Tags Section
            if (tags && tags.length > 0) {
                html += `<div class="post-tags" style="clear: both;">
                    <div class="tags-container">
                        ${tags.map(tag => `<span class="tag-chip">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>`;
            }
            
            html += `</div>`; // End post-article-layout
            
            document.getElementById('record-view-content').innerHTML = html;
            
            // Auto-load article text if needed
            if (shouldLoadArticle && articleUrl) {
                const contentId = `post-content-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}`;
                loadArticleTextInRecordViewById(articleUrl, contentId);
            }
        }

        function displayGenericRecord(record) {
            console.log('[RecordView] Displaying generic record:', record);
            
            const recordType = record.oip?.recordType || 'unknown';
            const basicData = record.data?.basic || {};
            const title = basicData.name || 'Untitled Record';
            const description = basicData.description || '';
            const date = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            let html = `<div class="post-article-layout">
                <div class="post-article-header">
                    <h1 class="post-article-title">${escapeHtml(title)}</h1>
                    ${description ? `<div class="post-article-summary">${escapeHtml(description)}</div>` : ''}
                    <div class="post-article-meta">
                        <div class="post-article-byline">Record Type: <strong>${escapeHtml(recordType)}</strong></div>
                        <div class="post-article-date">${escapeHtml(date)}</div>
                    </div>
                </div>
                
                <div class="post-content">
                    <p><em>Detailed view for ${recordType} records is not yet implemented. This is the generic record view.</em></p>
                    
                    <h3>Record Data Structure:</h3>
                    <pre style="background: #f8f9fa; padding: 20px; border-radius: 8px; overflow-x: auto; font-size: 14px;">${escapeHtml(JSON.stringify(record, null, 2))}</pre>
                </div>
            </div>`;
            
            document.getElementById('record-view-content').innerHTML = html;
        }

        async function loadArticleTextInRecordView(textUrl) {
            try {
                console.log('[RecordView] Loading article text from:', textUrl);
                
                const response = await fetch(textUrl);
                const text = await response.text();
                
                // Find the loader div and replace it with the content
                const loader = document.querySelector('.article-text-loader');
                if (loader) {
                    const formattedContent = text
                        .replace(/\n\n/g, '</p><p>')
                        .replace(/\n/g, '<br>');
                    loader.innerHTML = `<div class="loaded-article-text"><p>${formattedContent}</p></div>`;
                }
            } catch (error) {
                console.error('[RecordView] Error loading article text:', error);
                const loader = document.querySelector('.article-text-loader');
                if (loader) {
                    loader.innerHTML = `<div class="error" style="color: #dc3545; padding: 16px;">Failed to load article text</div>`;
                }
            }
        }

        async function loadArticleTextInRecordViewById(textUrl, contentId) {
            try {
                console.log('[RecordView] Auto-loading article text from:', textUrl);
                
                const response = await fetch(textUrl);
                const text = await response.text();
                
                // Find the content div and replace loading message with the content
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    const loadingDiv = contentDiv.querySelector('.article-loading');
                    if (loadingDiv) {
                        const formattedContent = text
                            .replace(/\n\n/g, '</p><p>')
                            .replace(/\n/g, '<br>');
                        loadingDiv.outerHTML = `<div class="article-text"><p>${formattedContent}</p></div>`;
                    }
                }
            } catch (error) {
                console.error('[RecordView] Error auto-loading article text:', error);
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    const loadingDiv = contentDiv.querySelector('.article-loading');
                    if (loadingDiv) {
                        loadingDiv.innerHTML = `<div class="error" style="color: #dc3545; padding: 16px;">Failed to load article text</div>`;
                    }
                }
            }
        }

        function toggleSummary(summaryId, button) {
            const summaryDiv = document.getElementById(summaryId);
            if (summaryDiv) {
                if (summaryDiv.classList.contains('collapsed')) {
                    summaryDiv.classList.remove('collapsed');
                    button.textContent = 'Show Less';
                } else {
                    summaryDiv.classList.add('collapsed');
                    button.textContent = 'Keep Reading';
                }
            }
        }

        // AI Drawer Functions
        function toggleAIDrawer() {
            const drawer = document.getElementById('ai-drawer');
            const mainContent = document.getElementById('main-content');
            const toggle = document.getElementById('ai-drawer-toggle');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                mainContent.classList.remove('drawer-open');
                toggle.classList.remove('active');
            } else {
                drawer.classList.add('open');
                mainContent.classList.add('drawer-open');
                toggle.classList.add('active');
                
                // Initialize AI features when drawer is first opened
                if (!chatState.isInitialized) {
                    initializeVoiceFeatures();
                }
            }
        }

        // Welcome Interface Functions
        function handleWelcomeSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                if (searchTerm) {
                    // Set the search term in both search inputs
                    document.getElementById('voice-search-input').value = searchTerm;
                    document.getElementById('header-search-input').value = searchTerm;
                    // Switch to search interface
                    showSearchInterface();
                    // Apply the search
                    applyVoiceFilters();
                }
            }
        }

        function searchByRecordType(recordType) {
            // Clear current search field (don't put record type name in search)
            document.getElementById('voice-search-input').value = '';
            
            // Special handling for audio - search for records with audio content, not audio record type
            if (recordType === 'audio') {
                console.log('[Search] 🎵 Searching for records with embedded audio content (any record type that contains audio)');
                // Don't set record type filter for audio
                document.getElementById('voice-record-type-filter').value = '';
                // Enable the "Includes Audio" toggle
                document.getElementById('voice-includes-audio-toggle').classList.add('active');
            } else {
                // Set the record type filter for other types
                document.getElementById('voice-record-type-filter').value = recordType;
                // Clear the "Includes Audio" toggle
                document.getElementById('voice-includes-audio-toggle').classList.remove('active');
            }
            
            // Clear other filters to get clean results for this record type
            document.getElementById('voice-sort-by').value = 'matchCount:desc';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-did-tx').value = '';
            clearDidTxError();
            clearAllTagFilters();
            
            // Switch to search interface
            showSearchInterface();
            
            // Apply the search (ensure we wait for UI to be ready)
            setTimeout(() => {
                // Ensure voice features are initialized first
                if (!chatState.isInitialized) {
                    initializeVoiceFeatures().then(() => {
                        applyVoiceFilters();
                    });
                } else {
                    applyVoiceFilters();
                }
            }, 200);
        }
        
        // Legacy function for backward compatibility
        function searchByCategory(category) {
            searchByRecordType(category);
        }

        function showAdvancedSearch() {
            showSearchInterface();
        }

        // Legacy function for compatibility
        function showVoiceBrowseTab() {
            showSearchInterface();
        }

        // Authentication Modal functions
        function showAuthModal() {
            document.getElementById('auth-modal').classList.remove('hidden');
            showLoginForm();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.add('hidden');
            clearAuthForms();
        }

        function showLoginForm() {
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('register-form').classList.add('hidden');
        }

        function showRegisterForm() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.remove('hidden');
        }

        function clearAuthForms() {
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
            document.getElementById('register-email').value = '';
            document.getElementById('register-password').value = '';
            hideElement('auth-status');
            hideElement('auth-success');
        }

        // Authentication functions
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    
                    // Also store in the JWT token localStorage for consistency
                    localStorage.setItem('oip-jwt-token', authToken);
                    
                    // Update JWT status display
                    try {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            updateJWTStatus(payload);
                        }
                    } catch (error) {
                        console.error('Error updating JWT status after login:', error);
                    }
                    
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Login successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function register() {
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    
                    // Also store in the JWT token localStorage for consistency
                    localStorage.setItem('oip-jwt-token', authToken);
                    
                    // Update JWT status display
                    try {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            updateJWTStatus(payload);
                        }
                    } catch (error) {
                        console.error('Error updating JWT status after registration:', error);
                    }
                    
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Registration successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            localStorage.removeItem('oip-auth-token');
            localStorage.removeItem('oip-user-email');
            localStorage.removeItem('oip-jwt-token');
            
            // Update JWT status display
            updateJWTStatus(null);
            
            showLoginState();
        }

        function showLoggedInState() {
            document.getElementById('user-info').classList.remove('hidden');
            document.getElementById('auth-buttons').classList.add('hidden');
            document.getElementById('publishing-content').classList.remove('hidden');
            document.getElementById('logged-in-display').textContent = currentUser;
        }

        function showLoginState() {
            document.getElementById('user-info').classList.add('hidden');
            document.getElementById('auth-buttons').classList.remove('hidden');
            document.getElementById('publishing-content').classList.add('hidden');
            hideAllPublishingSections();
        }

        // JWT Token Management Functions
        function showJWTModal() {
            document.getElementById('jwt-modal').classList.remove('hidden');
            // Pre-fill if token exists
            const existingToken = localStorage.getItem('oip-jwt-token');
            if (existingToken) {
                document.getElementById('jwt-token-input').value = existingToken;
            }
        }

        function hideJWTModal() {
            document.getElementById('jwt-modal').classList.add('hidden');
            document.getElementById('jwt-token-status').innerHTML = '';
        }

        function setJWTToken() {
            const tokenInput = document.getElementById('jwt-token-input').value.trim();
            const rememberToken = document.getElementById('jwt-remember').checked;
            
            if (!tokenInput) {
                showJWTStatus('Please enter a JWT token', 'error');
                return;
            }

            try {
                // Basic JWT validation - check if it has 3 parts
                const parts = tokenInput.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }

                // Try to decode the payload (without verification)
                const payload = JSON.parse(atob(parts[1]));
                
                // Set the token
                authToken = tokenInput;
                
                // Store in localStorage if requested
                if (rememberToken) {
                    localStorage.setItem('oip-jwt-token', tokenInput);
                } else {
                    localStorage.removeItem('oip-jwt-token');
                }

                // Update UI
                updateJWTStatus(payload);
                showJWTStatus(`Token set successfully! User: ${payload.email || 'Unknown'}`, 'success');
                
                // Auto-hide modal after success
                setTimeout(() => {
                    hideJWTModal();
                }, 2000);
                
            } catch (error) {
                showJWTStatus('Invalid JWT token format: ' + error.message, 'error');
            }
        }

        function clearJWTToken() {
            authToken = null;
            localStorage.removeItem('oip-jwt-token');
            document.getElementById('jwt-token-input').value = '';
            updateJWTStatus(null);
            showJWTStatus('Token cleared', 'success');
        }

        function updateJWTStatus(payload) {
            const indicator = document.getElementById('jwt-indicator');
            const userInfo = document.getElementById('jwt-user-info');
            
            if (payload && authToken) {
                indicator.textContent = '🔐';
                const userEmail = payload.email || 'Unknown';
                const publicKey = payload.publicKey ? `...${payload.publicKey.slice(-6)}` : 'No key';
                userInfo.textContent = `${userEmail} (${publicKey})`;
                userInfo.title = `Email: ${userEmail}\\nPublic Key: ${payload.publicKey || 'None'}`;
            } else {
                indicator.textContent = '🔓';
                userInfo.textContent = 'Not authenticated';
                userInfo.title = '';
            }
        }

        function showJWTStatus(message, type) {
            const statusElement = document.getElementById('jwt-token-status');
            statusElement.innerHTML = `<div class="${type === 'success' ? 'success-message' : 'error-message'}">${message}</div>`;
        }

        // Initialize JWT token from localStorage on page load
        function initializeJWTToken() {
            // Check both token storage locations for consistency
            const savedToken = localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
            if (savedToken) {
                try {
                    const parts = savedToken.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        authToken = savedToken;
                        
                        // Ensure both storage locations are synchronized
                        localStorage.setItem('oip-jwt-token', savedToken);
                        localStorage.setItem('oip-auth-token', savedToken);
                        
                        updateJWTStatus(payload);
                        console.log('JWT token initialized from localStorage:', payload.email);
                    }
                } catch (error) {
                    console.warn('Invalid saved JWT token, clearing:', error);
                    localStorage.removeItem('oip-jwt-token');
                    localStorage.removeItem('oip-auth-token');
                }
            }
        }

        // Core browsing functionality (DISABLED - redirected to voice version)
        async function loadRecords(reset = false) {
            console.log('[App] loadRecords called but redirected to loadVoiceRecords');
            // Redirect to the voice version instead
            return await loadVoiceRecords(reset);
        }

        // OLD loadRecords function (disabled)
        async function loadRecordsOLD(reset = false) {
            if (isLoading) return;
            
            isLoading = true;
            const loadingEl = document.getElementById('loading-indicator');
            const recordsGrid = document.getElementById('records-grid');
            const noResults = document.getElementById('no-results');
            
            if (reset) {
                currentPage = 1;
                currentRecords = [];
                recordsGrid.innerHTML = '';
                loadingEl.classList.remove('hidden');
                recordsGrid.classList.add('hidden');
                noResults.classList.add('hidden');
            }

            try {
                const params = buildApiParams();
                const base = (typeof window !== 'undefined' && window.API_BASE_URL) ? window.API_BASE_URL : '';
                const response = await fetch(`${base}/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    displayRecords(data.records, !reset);
                    updatePaginationInfo(data);
                    
                    // Update tags if available
                    if (data.tagSummary) {
                        updateTagFilter(data.tagSummary);
                    }
                    
                    hasMoreRecords = data.records.length === 12; // Check if we got a full page
                } else {
                    if (reset) {
                        showNoResults();
                    }
                }
                
            } catch (error) {
                console.error('Error loading records:', error);
                showMessage('records-header', 'Error loading records: ' + error.message, 'error');
            } finally {
                isLoading = false;
                loadingEl.classList.add('hidden');
                updateLoadMoreButton();
            }
        }

        function buildApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.searchMatchMode) {
                params.append('searchMatchMode', currentFilters.searchMatchMode);
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.tag) {
                params.append('tags', currentFilters.tag);
            }

            return params.toString();
        }

        // Display and utility functions
        function displayRecords(records, append = false) {
            const grid = document.getElementById('records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = currentRecords.length - records.length;
            records.forEach((record, index) => {
                const card = createRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
        }

        // Media rendering functions (excluding images and audio which are handled separately)
        function renderOtherMediaContent(record, recordType, specificData) {
            let mediaHtml = '';
            
            // Handle direct media records (video, text only - images and audio handled separately)
            if (['video', 'text'].includes(recordType)) {
                mediaHtml += renderDirectMedia(specificData, recordType);
            }
            
            // Handle post records with embedded media (excluding featured image and audio)
            if (recordType === 'post' && specificData) {
                mediaHtml += renderPostVideoAndText(specificData);
            }
            
            // Handle recipe and workout records with media in ingredients/exercises
            if (['recipe', 'workout'].includes(recordType) && specificData) {
                mediaHtml += renderRecipeWorkoutNonAudioMedia(specificData, recordType);
            }
            
            return mediaHtml ? `<div class="media-content">${mediaHtml}</div>` : '';
        }

        function renderPostVideoAndText(postData) {
            let html = '';
            
            // Article text (dref resolved) - but not if it's already shown in the text toggle
            if (postData.articleText?.data?.text?.webUrl && !postData.articleText) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }

        function renderRecipeWorkoutNonAudioMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media (excluding audio/images)
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has video or text media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        function renderDirectMedia(data, type) {
            if (!data || !data.webUrl) return '';
            
            const webUrl = data.webUrl;
            const contentType = data.contentType || '';
            
            switch (type) {
                case 'image':
                    return `<div class="media-item">
                        <img src="${webUrl}" alt="Image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <audio controls style="width: 100%; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <video controls style="width: 100%; max-height: 300px; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <div class="text-preview" style="margin: 10px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }
        
        function renderPostMedia(postData) {
            let html = '';
            
            // Main article web URL (external link) - this should open in new tab
            if (postData.webUrl) {
                html += `<div class="media-item">
                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Read Original Article
                    </a>
                </div>`;
            }
            
            // Article text (dref resolved)
            if (postData.articleText?.data?.text?.webUrl) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Featured image (dref resolved)
            if (postData.featuredImage?.data?.image?.webUrl) {
                html += renderDirectMedia(postData.featuredImage.data.image, 'image');
            }
            
            // Audio items array
            if (postData.audioItems && Array.isArray(postData.audioItems)) {
                postData.audioItems.forEach((audioItem, index) => {
                    if (audioItem?.data?.audio?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Audio ${index + 1}:</label>
                            ${renderDirectMedia(audioItem.data.audio, 'audio')}
                        </div>`;
                    }
                });
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            // Image items array
            if (postData.imageItems && Array.isArray(postData.imageItems)) {
                postData.imageItems.forEach((imageItem, index) => {
                    if (imageItem?.data?.image?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Image ${index + 1}:</label>
                            ${renderDirectMedia(imageItem.data.image, 'image')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }
        
        function renderRecipeWorkoutMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['image', 'audio', 'video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        // Load text content dynamically
        async function loadTextContent(url, button) {
            const contentDiv = button.nextElementSibling;
            
            if (contentDiv.style.display === 'none') {
                try {
                    button.textContent = 'Loading...';
                    button.disabled = true;
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    
                    contentDiv.innerHTML = `
                        <div style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 14px;">
                            ${escapeHtml(text)}
                        </div>
                        <button onclick="this.parentElement.style.display='none'; this.parentElement.previousElementSibling.textContent='📄 View Text Content'; this.parentElement.previousElementSibling.disabled=false;" 
                                style="margin-top: 10px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Hide
                        </button>
                    `;
                    contentDiv.style.display = 'block';
                    button.textContent = '📄 Text Loaded';
                } catch (error) {
                    contentDiv.innerHTML = `<div style="color: #dc3545;">Error loading text content: ${error.message}</div>`;
                    contentDiv.style.display = 'block';
                    button.textContent = '❌ Failed to Load';
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Truncate text to specified length with ellipsis
         */
        function truncateText(text, maxLength) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength).trim() + '...';
        }

        /**
         * Filter records by tag (called when clicking tag chips)
         */
        function filterByTag(tag) {
            document.getElementById('voice-search-input').value = tag;
            applyVoiceFilters();
        }

        // ====== ENHANCED TEMPLATE SYSTEM TEST FUNCTIONS ======
        
        /**
         * Test function to verify dynamic template system is working
         */
        function testTemplateSystem() {
            console.log('[Test] Testing Enhanced Dynamic Template System');
            console.log('[Test] Templates loaded:', Object.keys(allTemplates).length / 2);
            console.log('[Test] Field mappings available:', Object.keys(templateFieldMap).length / 2);
            console.log('[Test] Debug mode:', showDebugInfo);
            console.log('[Test] Sample template field mapping:', templateFieldMap['post'] || 'No post template found');
            
            if (currentRecords.length > 0) {
                const sampleRecord = currentRecords[0];
                const templatesUsed = analyzeRecordTemplates(sampleRecord);
                console.log('[Test] Sample record uses templates:', templatesUsed);
            }
            
            console.log('[Test] Enhanced template system is active!');
        }

        // Make test function available globally for console testing
        window.testTemplateSystem = testTemplateSystem;

        // Header Search and Filters Drawer Functions
        function handleHeaderSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                // Update the hidden search input
                document.getElementById('voice-search-input').value = searchTerm;
                // Switch to browse interface and apply filters
                showSearchInterface();
                applyVoiceFilters();
            }
        }

        function toggleFiltersDrawer() {
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            const filtersSection = document.querySelector('.filters-section');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                document.getElementById('search-interface').appendChild(filtersSection);
            } else {
                drawer.classList.add('open');
                toggle.classList.add('active');
                // Move filters to drawer
                document.querySelector('.filters-drawer-content').appendChild(filtersSection);
            }
        }

        function showHeaderSearch() {
            document.getElementById('header-search').classList.remove('hidden');
        }

        function hideHeaderSearch() {
            document.getElementById('header-search').classList.add('hidden');
            // Close filters drawer when hiding search
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                const filtersSection = document.querySelector('.filters-section');
                document.getElementById('search-interface').appendChild(filtersSection);
            }
        }

        // ========================================================================
        // MODERN MEDIA-FOCUSED RECORD CARDS (YouTube/SoundCloud/Flickr Style)
        // ========================================================================
        
        /**
         * Create a podcast show card that groups multiple episodes
         */
        function createPodcastShowCard(showName, episodes, baseIndex) {
            const card = document.createElement('div');
            card.className = 'record-card podcast-show-card';
            card.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
            card.style.border = '2px solid #667eea';
            
            // Sort episodes by date (newest first)
            episodes.sort((a, b) => (b.data?.basic?.date || 0) - (a.data?.basic?.date || 0));
            
            const showArtwork = showName === 'The Light of Inquiry' ? 'TheLightOfInquiry-v2.png' : 'icons/noun-microphone-7907572.svg';
            const episodeCount = episodes.length;
            const latestEpisode = episodes[0];
            
            card.innerHTML = `
                <div class="podcast-show-header" style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #667eea;">
                    <img src="${showArtwork}" alt="${showName}" style="width: 80px; height: 80px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);" onerror="this.src='icons/noun-microphone-7907572.svg'">
                    <div style="flex: 1;">
                        <h2 style="margin: 0 0 5px 0; color: #667eea; font-size: 1.4rem; font-weight: 700;">🎙️ ${showName}</h2>
                        <div style="color: #6c757d; font-size: 14px; margin-bottom: 5px;">${episodeCount} Episode${episodeCount === 1 ? '' : 's'}</div>
                        <div style="color: #495057; font-size: 13px;">Latest: ${formatDate(latestEpisode.data?.basic?.date)}</div>
                    </div>
                    <button onclick="toggleShowEpisodes('${showName.replace(/'/g, "\\'")}')" class="show-toggle-btn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer;">
                        Show Episodes
                    </button>
                </div>
                
                <div id="episodes-${showName.replace(/[^a-zA-Z0-9]/g, '_')}" class="episodes-container" style="display: none;">
                    ${episodes.map((episode, index) => createEpisodeCard(episode, baseIndex + index, showName)).join('')}
                </div>
            `;
            
            return card;
        }

        /**
         * Create an individual episode card within a show
         */
        function createEpisodeCard(episode, episodeIndex, showName) {
            const basicData = episode.data?.basic || {};
            const podcastData = episode.data?.podcast || {};
            const audioData = episode.data?.audio || {};
            
            const episodeTitle = basicData.name || 'Untitled Episode';
            const episodeDescription = basicData.description || '';
            const episodeDate = formatDate(basicData.date);
            const episodeTime = formatTime(basicData.date);
            const citations = basicData.citations || [];
            const citationCount = Array.isArray(citations) ? citations.length : 0;
            
            return `
                <div class="episode-card" style="margin: 15px 0; padding: 15px; border: 1px solid #e9ecef; border-radius: 8px; background: white;">
                    <div class="episode-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 5px 0; color: #333; font-size: 1.1rem;">${episodeTitle}</h4>
                            <div style="color: #6c757d; font-size: 12px; margin-bottom: 8px;">
                                📅 ${episodeDate} • 🕐 ${episodeTime}
                            </div>
                        </div>
                    </div>
                    
                    ${episodeDescription ? `<p style="color: #666; font-size: 14px; line-height: 1.4; margin-bottom: 12px;">${truncateText(episodeDescription, 200)}</p>` : ''}
                    
                    <div class="episode-controls" style="display: flex; gap: 10px; align-items: center; margin-bottom: 12px;">
                        ${audioData.webUrl ? `
                            <button class="play-btn primary" onclick="playAudioInMaster('${audioData.webUrl}', '${episodeTitle}', 'podcast', ${episodeIndex})" id="audioBtn-${episodeIndex}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 10px 20px;">
                                <span class="play-icon">🎙️</span>
                                <span class="play-text">Play Episode</span>
                            </button>
                        ` : ''}
                        ${podcastData.duration ? `<span style="color: #667eea; font-size: 12px;">Duration: ${podcastData.duration}</span>` : ''}
                    </div>
                    
                    ${citationCount > 0 ? `
                        <div class="episode-sources" style="border-top: 1px solid #e9ecef; padding-top: 10px;">
                            <button class="article-btn" onclick="toggleEpisodeSources(${episodeIndex})" id="episodeSourcesBtn-${episodeIndex}" style="background: #e3f2fd; border-color: #2196f3; color: #1976d2; font-size: 12px; padding: 6px 12px;">
                                📚 ${citationCount} Source${citationCount === 1 ? '' : 's'}
                            </button>
                            <div id="episodeSources-${episodeIndex}" class="episode-sources-content hidden" style="margin-top: 10px;">
                                <div id="episodeSourcesContent-${episodeIndex}">Loading sources...</div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        /**
         * Toggle show episodes visibility
         */
        function toggleShowEpisodes(showName) {
            const containerId = 'episodes-' + showName.replace(/[^a-zA-Z0-9]/g, '_');
            const container = document.getElementById(containerId);
            const button = event.target;
            
            if (container.style.display === 'none') {
                container.style.display = 'block';
                button.textContent = 'Hide Episodes';
            } else {
                container.style.display = 'none';
                button.textContent = 'Show Episodes';
            }
        }

        /**
         * Toggle episode sources
         */
        function toggleEpisodeSources(episodeIndex) {
            const sourcesDiv = document.getElementById(`episodeSources-${episodeIndex}`);
            const button = document.getElementById(`episodeSourcesBtn-${episodeIndex}`);
            const contentDiv = document.getElementById(`episodeSourcesContent-${episodeIndex}`);
            
            if (sourcesDiv.classList.contains('hidden')) {
                sourcesDiv.classList.remove('hidden');
                button.textContent = button.textContent.replace(/\d+ Source/, 'Hide Source');
                
                if (contentDiv.textContent === 'Loading sources...') {
                    loadEpisodeSources(episodeIndex);
                }
            } else {
                sourcesDiv.classList.add('hidden');
                button.textContent = button.textContent.replace('Hide Source', currentRecords[episodeIndex]?.data?.basic?.citations?.length + ' Source');
            }
        }

        /**
         * Load episode sources
         */
        function loadEpisodeSources(episodeIndex) {
            const record = currentRecords[episodeIndex];
            if (!record?.data?.basic?.citations) return;
            
            const contentDiv = document.getElementById(`episodeSourcesContent-${episodeIndex}`);
            const citations = record.data.basic.citations;
            let sourcesHtml = '';
            
            citations.forEach((citation, index) => {
                if (typeof citation === 'string') {
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 8px; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; background: #f8f9fa; font-size: 11px;">
                            <div style="color: #6c757d; font-family: monospace;">DID: ${citation}</div>
                        </div>
                    `;
                } else if (citation?.data?.basic) {
                    const citationData = citation.data.basic;
                    const postData = citation.data.post || {};
                    
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 8px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: white; font-size: 12px;">
                            <div style="font-weight: 600; margin-bottom: 4px; color: #333;">
                                ${citationData.name || 'Untitled Source'}
                            </div>
                            ${citationData.description ? `
                                <div style="color: #666; margin-bottom: 6px; line-height: 1.3;">
                                    ${truncateText(citationData.description, 100)}
                                </div>
                            ` : ''}
                            ${postData.webUrl ? `
                                <div style="margin-top: 6px;">
                                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="color: #1976d2; text-decoration: none; font-size: 11px;">
                                        🔗 Read Original
                                    </a>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            });
            
            if (sourcesHtml) {
                contentDiv.innerHTML = sourcesHtml;
            } else {
                contentDiv.innerHTML = '<div style="color: #666; font-style: italic; font-size: 12px;">No sources available</div>';
            }
        }

        /**
         * Format time from unix timestamp
         */
        function formatTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        /**
         * Create a modern, media-focused record card with collapsible technical details
         */
        function createRecordCard(record, recordIndex, isListView = false) {
            const card = document.createElement('div');
            card.className = isListView ? 'record-card list-view' : 'record-card';
            
            // Store record data for clickable elements (removed whole-card click handler)
            const didTx = record.oip?.did || record.oip?.didTx;
            
            const recordType = record.oip?.recordType || 'unknown';
            const basicData = record.data?.basic || {};
            const templatesUsed = analyzeRecordTemplates(record);
            
            // Extract media and content for modern display
            const mediaContent = extractMediaContent(record);
            const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            if (isListView) {
                // List view layout - horizontal layout with thumbnail on left
                card.innerHTML = `
                    ${renderMediaPreview(mediaContent, recordIndex, record)}
                    
                    <div class="record-content-area">
                        <div class="record-header">
                            <div class="record-type">${recordType}</div>
                            <div class="record-date">${dateDisplay}</div>
                        </div>
                        
                        ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                        
                        <div class="list-meta-row">
                            <div class="list-controls">
                                ${renderMediaControls(mediaContent, record, recordIndex)}
                                ${renderArticleTextButton(mediaContent, recordIndex)}
                                ${renderWebUrlButton(mediaContent)}
                            </div>
                            <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                🔧
                            </button>
                        </div>
                        
                        ${createTagsDisplay(basicData.tagItems)}
                        ${renderPodcastCitations(mediaContent, recordIndex)}
                    </div>
                    
                    <div id="structure-${recordIndex}" class="record-structure hidden">
                        <div class="structure-header">
                            <h4>🔧 Technical Record Structure</h4>
                            <div class="template-info">
                                <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                <strong>Record Type:</strong> ${recordType}<br>
                                <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                            </div>
                        </div>
                        ${renderAllTemplateData(record, templatesUsed)}
                    </div>
                `;
            } else {
                // Grid view layout - vertical layout (original)
                card.innerHTML = `
                    <div class="record-header">
                        <div class="record-type">${recordType}</div>
                        <div class="record-date">${dateDisplay}</div>
                    </div>
                    
                    ${renderMediaPreview(mediaContent, recordIndex, record)}
                    
                    <div class="record-content">
                        ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                        
                        ${renderMediaControls(mediaContent, record, recordIndex)}
                        ${renderArticleTextButton(mediaContent, recordIndex)}
                        ${renderWebUrlButton(mediaContent)}
                        ${renderPodcastCitations(mediaContent, recordIndex)}
                    </div>
                    
                    ${createTagsDisplay(basicData.tagItems)}
                    
                    <div class="record-footer">
                        <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                            <span class="structure-icon">🔧</span> Show Record Structure
                        </button>
                        <div class="record-did">DID: ${truncateText(record.oip?.did || record.oip?.didTx || 'Unknown', 20)}</div>
                    </div>
                    
                    <div id="structure-${recordIndex}" class="record-structure hidden">
                        <div class="structure-header">
                            <h4>🔧 Technical Record Structure</h4>
                            <div class="template-info">
                                <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                <strong>Record Type:</strong> ${recordType}<br>
                                <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                            </div>
                        </div>
                        ${renderAllTemplateData(record, templatesUsed)}
                    </div>
                `;
            }
            
            return card;
        }

        /**
         * Extract all media content from a record for modern display
         */
        function extractMediaContent(record) {
            const content = {
                featuredImage: null,
                audioItems: [],
                videoItems: [],
                articleText: null,
                webUrl: null,
                podcastData: null // Add podcast-specific data
            };
            
            const recordType = record.oip?.recordType || 'unknown';
            const recordName = record.data?.basic?.name || 'Unnamed';
            
            // Handle podcast records specifically
            if (recordType === 'podcast') {
                content.podcastData = {
                    show: record.data?.podcast?.show || 'Unknown Show',
                    duration: record.data?.podcast?.duration,
                    episodeAudio: record.data?.audio?.webUrl || null,
                    episodeTitle: record.data?.basic?.name || 'Untitled Episode',
                    episodeDescription: record.data?.basic?.description || '',
                    citations: record.data?.basic?.citations || [],
                    date: record.data?.basic?.dateReadable || formatDate(record.data?.basic?.date) || 'Unknown Date'
                };
                
                // Add the main podcast audio as an audio item
                if (record.data?.audio?.webUrl) {
                    content.audioItems.push({
                        url: record.data.audio.webUrl,
                        title: content.podcastData.episodeTitle,
                        contentType: record.data.audio.contentType || 'audio/mp3'
                    });
                }
                
                // Set show artwork as featured image for "The Light of Inquiry"
                if (content.podcastData.show === 'The Light of Inquiry') {
                    content.featuredImage = {
                        url: 'TheLightOfInquiry-v2.png',
                        title: 'The Light of Inquiry',
                        contentType: 'image/png'
                    };
                }
            }
            
            // Extract from all data sections
            if (record.data) {
                Object.keys(record.data).forEach(sectionName => {
                    if (sectionName === 'basic') return;
                    
                    const section = record.data[sectionName];
                    extractMediaFromSection(section, content, sectionName, record);
                });
            }
            
            // Fallback: If no featured image found, search more aggressively
            if (!content.featuredImage && record.data) {
                console.log(`[Media Detection] No image found in primary extraction for ${recordType}: "${recordName}". Trying fallback search...`);
                const fallbackResult = findFirstImageInRecord(record);
                
                if (fallbackResult) {
                    if (fallbackResult.type === 'unresolved_dref') {
                        console.log(`[Media Detection] ⚠️ Found unresolved image dref for "${recordName}". Increase resolve depth to see images.`);
                        content.unresolvedImageDref = fallbackResult.dref;
                    } else {
                        content.featuredImage = fallbackResult;
                        console.log(`[Media Detection] ✅ Fallback found image for "${recordName}": ${content.featuredImage.url}`);
                    }
                } else {
                    console.log(`[Media Detection] ❌ No image found for "${recordName}" even after fallback search`);
                }
            } else if (content.featuredImage) {
                console.log(`[Media Detection] ✅ Primary extraction found image for "${recordName}": ${content.featuredImage.url}`);
            }
            
            return content;
        }

        /**
         * Aggressively search for any image URL in a record (fallback method)
         */
        function findFirstImageInRecord(record) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const basicData = record.data?.basic || {};
            
            // Priority order for field names (most likely to be main images first)
            const priorityFields = ['image', 'photo', 'picture', 'thumbnail', 'featured', 'cover', 'avatar', 'img', 'imageurl', 'photourl'];
            
            // First pass: Look for priority fields
            for (const priorityField of priorityFields) {
                const result = searchForImageInSection(record.data, priorityField);
                if (result) {
                    console.log(`[Media Detection] Found priority image in field containing "${priorityField}": ${result}`);
                    return {
                        url: result,
                        title: basicData.name || 'Image',
                        contentType: 'image/jpeg'
                    };
                }
            }
            
            // Second pass: Search all fields recursively
            const anyImageUrl = searchForImageUrl(record.data);
            if (anyImageUrl) {
                console.log(`[Media Detection] Found image URL in fallback search: ${anyImageUrl}`);
                return {
                    url: anyImageUrl,
                    title: basicData.name || 'Image',
                    contentType: 'image/jpeg'
                };
            }
            
            // Third pass: Look for unresolved image drefs
            const unresolvedImageDref = searchForUnresolvedImageDref(record.data);
            if (unresolvedImageDref) {
                console.log(`[Media Detection] Found unresolved image dref: ${unresolvedImageDref}`);
                return {
                    type: 'unresolved_dref',
                    dref: unresolvedImageDref
                };
            }
            
            return null;
            
            // Helper function to search for images in fields with priority names
            function searchForImageInSection(obj, priorityField, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl && path.toLowerCase().includes(priorityField.toLowerCase())) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageInSection(value, priorityField, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageInSection(obj[i], priorityField, `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function for general image URL search
            function searchForImageUrl(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageUrl(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageUrl(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function to search for unresolved image drefs
            function searchForUnresolvedImageDref(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('did:arweave:')) {
                    // Check if the field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => path.toLowerCase().includes(name.toLowerCase()));
                    
                    if (isImageField) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForUnresolvedImageDref(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForUnresolvedImageDref(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
        }

        /**
         * Extract media from a specific data section
         */
        function extractMediaFromSection(section, content, sectionName, record = null) {
            if (!section || typeof section !== 'object') return;
            
            // Get basic data for image titles
            const basicData = record?.data?.basic || {};
            
            Object.keys(section).forEach(fieldName => {
                const value = section[fieldName];
                
                // Handle resolved drefs
                if (value && typeof value === 'object' && value.data && value.oip) {
                    const embedType = value.oip.recordType;
                    const embedData = value.data[embedType];
                    
                    if (embedType === 'image' && embedData?.webUrl) {
                        if (!content.featuredImage) {
                            content.featuredImage = {
                                url: embedData.webUrl,
                                title: value.data.basic?.name || 'Image',
                                contentType: embedData.contentType
                            };
                            console.log(`[Media Detection] ✅ Found resolved image dref at ${sectionName}.${fieldName}: ${embedData.webUrl}`);
                        }
                    } else if (embedType === 'audio' && embedData?.webUrl) {
                        content.audioItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Audio',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'video' && embedData?.webUrl) {
                        content.videoItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Video',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'text' && embedData?.webUrl && fieldName === 'articleText') {
                        content.articleText = {
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Article Text',
                            contentType: embedData.contentType
                        };
                    }
                }
                
                // Handle arrays of resolved drefs
                else if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                    value.forEach(item => {
                        const embedType = item.oip.recordType;
                        const embedData = item.data[embedType];
                        
                        if (embedType === 'audio' && embedData?.webUrl) {
                            content.audioItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Audio',
                                contentType: embedData.contentType
                            });
                        } else if (embedType === 'video' && embedData?.webUrl) {
                            content.videoItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Video',
                                contentType: embedData.contentType
                            });
                        }
                    });
                }
                
                // Handle direct URLs
                else if (fieldName === 'webUrl' && typeof value === 'string') {
                    content.webUrl = value;
                }
                
                // Enhanced image URL detection for recipes and other records
                else if (typeof value === 'string' && value.startsWith('http')) {
                    // Check if it's an image URL by extension
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    // Check if field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => fieldName.toLowerCase().includes(name));
                    
                                         // For recipes, be even more permissive - any URL ending in image extension
                     const isRecipeContext = sectionName === 'recipe' || sectionName === 'food';
                     
                     // Additional recipe-specific field names
                     const recipeImageFields = ['photo', 'picture', 'img', 'imageurl', 'photourl', 'pictureurl'];
                     const isRecipeImageField = recipeImageFields.some(name => fieldName.toLowerCase().includes(name));
                    
                                                              if ((isImageUrl && (isImageField || isRecipeImageField || isRecipeContext)) || 
                         ((isImageField || isRecipeImageField) && isImageUrl)) {
                        if (!content.featuredImage) content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    }
                }
                
                // Handle webUrl fields that point to images (common in recipes)
                else if (fieldName === 'webUrl' && typeof value === 'string' && value.startsWith('http')) {
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    if (isImageUrl && !content.featuredImage) {
                        content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    } else {
                        content.webUrl = value;
                    }
                }
            });
        }

        /**
         * Render media preview (featured image or video thumbnail)
         */
        function renderMediaPreview(mediaContent, recordIndex, record = null) {
            const didTx = record?.oip?.didTx;
            const recordViewClick = didTx ? `onclick="showRecordView('${didTx}', currentRecords[${recordIndex}]); event.stopPropagation();"` : '';
            const clickableStyle = didTx ? 'cursor: pointer;' : '';
            // Handle podcast records with specialized interface
            if (mediaContent.podcastData) {
                const podcast = mediaContent.podcastData;
                const showArtwork = mediaContent.featuredImage?.url || 'icons/noun-microphone-7907572.svg';
                
                return `
                    <div class="media-preview podcast-preview" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); ${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="podcast-artwork" style="position: relative; height: 100%; display: flex; align-items: center; justify-content: center;">
                            <img src="${showArtwork}" 
                                 alt="${podcast.show}"
                                 class="preview-image"
                                 style="max-height: 80%; max-width: 80%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div class="podcast-icon" style="display: none; font-size: 48px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">🎙️</div>
                            
                            <div class="play-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4); opacity: 0; transition: opacity 0.2s;">
                                <div class="play-button" style="width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">▶️</div>
                            </div>
                        </div>
                        <div class="media-badge" style="background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);">🎙️ Podcast</div>
                    </div>
                `;
            }
            // Priority: Video thumbnail > Featured Image > First Video > Placeholder
            else if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                return `
                    <div class="media-preview video-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <video class="preview-video" poster="" onclick="event.stopPropagation(); playVideoFullscreen('${video.url}', '${video.title}')">
                            <source src="${video.url}" type="${video.contentType || 'video/mp4'}">
                        </video>
                        <div class="play-overlay" onclick="event.stopPropagation(); playVideoFullscreen('${video.url}', '${video.title}')">
                            <div class="play-button">▶️</div>
                        </div>
                        <div class="media-badge">📹 Video</div>
                    </div>
                `;
            } else if (mediaContent.featuredImage) {
                return `
                    <div class="media-preview image-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <img src="${mediaContent.featuredImage.url}" 
                             alt="${mediaContent.featuredImage.title}"
                             class="preview-image"
                             onerror="this.parentElement.innerHTML='<div class=\\"preview-placeholder\\">🖼️ Image</div>'">
                        <div class="media-badge">📷 Image</div>
                    </div>
                `;
            } else if (mediaContent.audioItems.length > 0) {
                return `
                    <div class="media-preview audio-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="audio-artwork">
                            <div class="audio-icon">🎵</div>
                            <div class="audio-visualizer">
                                <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
                            </div>
                        </div>
                        <div class="media-badge">🎵 Audio</div>
                    </div>
                `;
            } else if (mediaContent.unresolvedImageDref) {
                return `
                    <div class="media-preview placeholder-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="preview-placeholder resolve-hint">
                            🖼️ Image<br>
                            <small style="font-size: 0.7rem; opacity: 0.8;">Increase Resolve Depth to see image</small>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="media-preview placeholder-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="preview-placeholder">📄 Text</div>
                    </div>
                `;
            }
        }

        /**
         * Render record title and description with podcast-specific formatting
         */
        function renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex = null, record = null) {
            const didTx = record?.oip?.didTx;
            const recordViewClick = didTx ? `onclick="showRecordView('${didTx}', currentRecords[${recordIndex}]); event.stopPropagation();"` : '';
            const clickableStyle = didTx ? 'cursor: pointer;' : '';
            if (mediaContent.podcastData) {
                const podcast = mediaContent.podcastData;
                return `
                    <div class="podcast-info">
                        <div class="podcast-show" style="color: #667eea; font-weight: 600; font-size: 14px; margin-bottom: 5px;">
                            🎙️ ${podcast.show}
                        </div>
                        <h3 class="record-title" style="margin-bottom: 8px; ${clickableStyle}" ${recordViewClick} title="Click to view full record">${podcast.episodeTitle}</h3>
                        <div class="podcast-date" style="color: #6c757d; font-size: 12px; margin-bottom: 10px;">
                            📅 ${podcast.date}
                        </div>
                        ${podcast.episodeDescription ? `<p class="record-description" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${truncateText(podcast.episodeDescription, 200)}</p>` : ''}
                    </div>
                `;
            } else {
                return `
                    <h3 class="record-title" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${basicData.name || 'Unnamed Record'}</h3>
                    ${basicData.description ? `<p class="record-description" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${truncateText(basicData.description, 150)}</p>` : ''}
                `;
            }
        }

        /**
         * Render media controls (play buttons, etc.)
         */
        function renderMediaControls(mediaContent, record, recordIndex) {
            let controls = '';
            
            // Podcast controls (specialized for podcast episodes)
            if (mediaContent.podcastData && mediaContent.audioItems.length > 0) {
                const podcast = mediaContent.podcastData;
                const audio = mediaContent.audioItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn primary" onclick="playAudioInMaster('${audio.url}', '${podcast.episodeTitle}', 'podcast', ${recordIndex})" id="audioBtn-${recordIndex}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 12px 24px;">
                            <span class="play-icon">🎙️</span>
                            <span class="play-text">Play Episode</span>
                        </button>
                        ${podcast.duration ? `<span class="media-count" style="color: #667eea;">Duration: ${podcast.duration}</span>` : ''}
                    </div>
                `;
            }
            // Audio controls (for non-podcast audio)
            else if (mediaContent.audioItems.length > 0) {
                const audio = mediaContent.audioItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn primary" onclick="playAudioInMaster('${audio.url}', '${audio.title}', '${record.oip?.recordType || 'audio'}', ${recordIndex})" id="audioBtn-${recordIndex}">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Audio</span>
                        </button>
                        ${mediaContent.audioItems.length > 1 ? `<span class="media-count">+${mediaContent.audioItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            // Video controls  
            if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn secondary" onclick="playVideoFullscreen('${video.url}', '${video.title}')">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Video</span>
                        </button>
                        ${mediaContent.videoItems.length > 1 ? `<span class="media-count">+${mediaContent.videoItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            return controls;
        }

        /**
         * Render podcast citations and sources
         */
        function renderPodcastCitations(mediaContent, recordIndex) {
            if (!mediaContent.podcastData || !mediaContent.podcastData.citations || mediaContent.podcastData.citations.length === 0) {
                return '';
            }
            
            const citations = mediaContent.podcastData.citations;
            const citationCount = Array.isArray(citations) ? citations.length : (typeof citations === 'object' ? Object.keys(citations).length : 0);
            
            if (citationCount === 0) return '';
            
            return `
                <div class="podcast-citations" style="margin-top: 15px;">
                    <button class="article-btn" onclick="togglePodcastSources(${recordIndex})" id="sourcesBtn-${recordIndex}" style="background: #e3f2fd; border-color: #2196f3; color: #1976d2;">
                        📚 Show ${citationCount} Source${citationCount === 1 ? '' : 's'}
                    </button>
                    <div id="podcastSources-${recordIndex}" class="podcast-sources hidden" style="margin-top: 15px; border: 1px solid #e9ecef; border-radius: 8px; background: #f8f9fa; padding: 15px;">
                        <div style="font-weight: bold; margin-bottom: 10px; color: #495057;">📚 Episode Sources & Citations</div>
                        <div id="sourcesContent-${recordIndex}">Loading sources...</div>
                    </div>
                </div>
            `;
        }

        /**
         * Toggle podcast sources display
         */
        function togglePodcastSources(recordIndex) {
            const sourcesDiv = document.getElementById(`podcastSources-${recordIndex}`);
            const button = document.getElementById(`sourcesBtn-${recordIndex}`);
            const contentDiv = document.getElementById(`sourcesContent-${recordIndex}`);
            
            if (sourcesDiv.classList.contains('hidden')) {
                sourcesDiv.classList.remove('hidden');
                button.textContent = button.textContent.replace('Show', 'Hide');
                
                // Load sources if not already loaded
                if (contentDiv.textContent === 'Loading sources...') {
                    loadPodcastSources(recordIndex);
                }
            } else {
                sourcesDiv.classList.add('hidden');
                button.textContent = button.textContent.replace('Hide', 'Show');
            }
        }

        /**
         * Load and display podcast sources
         */
        function loadPodcastSources(recordIndex) {
            const record = currentRecords[recordIndex];
            if (!record?.data?.basic?.citations) return;
            
            const contentDiv = document.getElementById(`sourcesContent-${recordIndex}`);
            const citations = record.data.basic.citations;
            let sourcesHtml = '';
            
            citations.forEach((citation, index) => {
                if (typeof citation === 'string') {
                    // Simple DID reference
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 10px; padding: 10px; border: 1px solid #dee2e6; border-radius: 6px; background: white;">
                            <div style="font-size: 12px; color: #6c757d; font-family: monospace;">DID: ${citation}</div>
                        </div>
                    `;
                } else if (citation?.data?.basic) {
                    // Resolved citation with post data
                    const citationData = citation.data.basic;
                    const postData = citation.data.post || {};
                    
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 10px; padding: 12px; border: 1px solid #dee2e6; border-radius: 6px; background: white;">
                            <div style="font-weight: 600; margin-bottom: 5px; color: #333;">
                                ${citationData.name || 'Untitled Source'}
                            </div>
                            ${citationData.description ? `
                                <div style="font-size: 13px; color: #666; margin-bottom: 8px; line-height: 1.4;">
                                    ${truncateText(citationData.description, 120)}
                                </div>
                            ` : ''}
                            ${postData.webUrl ? `
                                <div style="margin-top: 8px;">
                                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="color: #1976d2; text-decoration: none; font-size: 12px;">
                                        🔗 Read Original Article
                                    </a>
                                </div>
                            ` : ''}
                            <div style="font-size: 11px; color: #999; margin-top: 5px;">
                                DID: ${citation.oip?.did || citation.oip?.didTx || 'Unknown'}
                            </div>
                        </div>
                    `;
                }
            });
            
            if (sourcesHtml) {
                contentDiv.innerHTML = sourcesHtml;
            } else {
                contentDiv.innerHTML = '<div style="color: #666; font-style: italic;">No sources available</div>';
            }
        }

        /**
         * Render article text button for posts
         */
        function renderArticleTextButton(mediaContent, recordIndex) {
            if (mediaContent.articleText) {
                return `
                    <div class="article-controls">
                        <button class="article-btn" onclick="loadArticleText('${mediaContent.articleText.url}', ${recordIndex})">
                            📄 Full Article Text
                        </button>
                        <div id="articleText-${recordIndex}" class="article-content hidden">
                            <div class="article-loading">Loading article...</div>
                        </div>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Render web URL button (skip for podcast records)
         */
        function renderWebUrlButton(mediaContent) {
            if (mediaContent.webUrl && !mediaContent.podcastData) {
                return `
                    <div class="web-controls">
                        <a href="${mediaContent.webUrl}" target="_blank" rel="noopener noreferrer" class="web-btn">
                            🌐 View Original
                        </a>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Toggle record structure visibility
         */
        function toggleRecordStructure(recordIndex) {
            const structure = document.getElementById(`structure-${recordIndex}`);
            const button = structure.previousElementSibling.querySelector('.show-structure-btn');
            
            if (structure.classList.contains('hidden')) {
                structure.classList.remove('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Hide Record Structure';
            } else {
                structure.classList.add('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Show Record Structure';
            }
        }

        /**
         * Load article text content
         */
        async function loadArticleText(url, recordIndex) {
            const container = document.getElementById(`articleText-${recordIndex}`);
            const button = container.previousElementSibling;
            
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                button.textContent = '📄 Full Article Text';
                return;
            }
            
            try {
                button.textContent = '📄 Loading...';
                button.disabled = true;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                
                container.innerHTML = `
                    <div class="article-header">
                        <h4>📄 Full Article Text</h4>
                        <button onclick="toggleRecordStructure(${recordIndex}); document.getElementById('articleText-${recordIndex}').classList.add('hidden'); document.querySelector('[onclick*=\\"loadArticleText\\"]').textContent='📄 Full Article Text'; document.querySelector('[onclick*=\\"loadArticleText\\"]').disabled=false;" class="close-btn">✕</button>
                    </div>
                    <div class="article-text">${escapeHtml(text)}</div>
                `;
                container.classList.remove('hidden');
                button.textContent = '📄 Hide Article Text';
                
            } catch (error) {
                container.innerHTML = `<div class="article-error">Error loading article: ${error.message}</div>`;
                container.classList.remove('hidden');
                button.textContent = '❌ Failed to Load';
            } finally {
                button.disabled = false;
            }
        }

        /**
         * Play video in fullscreen modal
         */
        function playVideoFullscreen(url, title) {
            // Create simple video modal
            const modal = document.createElement('div');
            modal.className = 'video-modal';
            modal.innerHTML = `
                <div class="video-modal-content">
                    <div class="video-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.video-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <video controls autoplay style="width: 100%; max-height: 70vh;">
                        <source src="${url}">
                        Your browser doesn't support video playback.
                    </video>
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Open image in modal
         */
        function openImageModal(url, title) {
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="image-modal-content">
                    <div class="image-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.image-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <img src="${url}" alt="${escapeHtml(title)}" style="max-width: 100%; max-height: 80vh;">
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Render basic information section
         */
        function renderBasicInfo(basicData) {
            let html = '';
            
            if (basicData.description) {
                html += `<div class="record-content">${truncateText(basicData.description, 200)}</div>`;
            }
            
            return html;
        }

        /**
         * Dynamically render all template data sections
         */
        function renderAllTemplateData(record, templatesUsed) {
            let html = '';
            
            if (!record.data) return html;
            
            Object.keys(record.data).forEach(templateName => {
                if (templateName === 'basic') return; // Skip basic - handled separately
                
                const templateData = record.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `data.${templateName}`);
            });
            
            return html ? `<div class="media-content">${html}</div>` : '';
        }

        /**
         * Render data for a specific template section
         */
        function renderTemplateSectionData(templateName, data, path = '') {
            if (!data || typeof data !== 'object') return '';
            
            let html = '';
            const fieldsMap = templateFieldMap[templateName];
            
            if (showDebugInfo && fieldsMap) {
                html += `<div class="field-debug">Template: ${templateName}, Fields: ${Object.keys(fieldsMap).length}</div>`;
            }
            
            Object.keys(data).forEach(fieldName => {
                const value = data[fieldName];
                const fieldDef = getFieldDefinition(templateName, fieldName);
                const fieldPath = path ? `${path}.${fieldName}` : fieldName;
                
                html += renderFieldByType(templateName, fieldName, value, fieldDef, fieldPath);
            });
            
            return html;
        }

        /**
         * Render a field based on its type definition
         */
        function renderFieldByType(templateName, fieldName, value, fieldDef, path) {
            if (!value) return '';
            
            let html = '';
            const mediaType = getMediaType(templateName, fieldName, value);
            
            // Debug info
            if (showDebugInfo) {
                const typeInfo = fieldDef ? `${fieldDef.type} (${fieldDef.index})` : 'unknown type';
                html += `<div class="field-debug">Field: ${fieldName} <span class="field-type-indicator">${typeInfo}</span></div>`;
            }
            
            // Handle resolved drefs (embedded records)
            if (value && typeof value === 'object' && value.data && value.oip) {
                return renderResolvedDref(fieldName, value, path);
            }
            
            // Handle arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                return renderResolvedDrefArray(fieldName, value, path);
            }
            
            // Handle direct media URLs based on detected type
            if (mediaType) {
                return renderMediaField(fieldName, value, mediaType);
            }
            
            // Handle simple web URLs
            if (fieldName === 'webUrl' && typeof value === 'string') {
                html += `<div class="media-item">
                    <a href="${value}" target="_blank" rel="noopener noreferrer" 
                       style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Visit ${fieldName}
                    </a>
                </div>`;
            }
            
            // Handle unresolved drefs
            if (isDrefField(fieldDef, value)) {
                html += renderUnresolvedDref(fieldName, value);
            }
            
            return html;
        }

        /**
         * Render resolved dref (embedded record)
         */
        function renderResolvedDref(fieldName, resolvedRecord, path) {
            const embedTemplates = Object.keys(resolvedRecord.data).filter(k => k !== 'basic');
            const recordType = resolvedRecord.oip?.recordType || embedTemplates[0] || 'unknown';
            
            let html = `<div class="dref-resolved">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                    📎 ${fieldName} (${recordType}):
                </label>`;
            
            // Render basic info from embedded record
            if (resolvedRecord.data.basic) {
                const basicData = resolvedRecord.data.basic;
                if (basicData.name) {
                    html += `<div style="font-weight: 500; margin-bottom: 5px;">${basicData.name}</div>`;
                }
                if (basicData.description) {
                    html += `<div style="font-size: 13px; color: #666; margin-bottom: 8px;">${truncateText(basicData.description, 100)}</div>`;
                }
            }
            
            // Render each template section in the embedded record
            embedTemplates.forEach(templateName => {
                const templateData = resolvedRecord.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `${path}.data.${templateName}`);
            });
            
            if (showDebugInfo) {
                html += `<div class="field-debug">Resolved: ${resolvedRecord.oip?.did || resolvedRecord.oip?.didTx}</div>`;
            }
            
            html += '</div>';
            return html;
        }

        /**
         * Render array of resolved drefs
         */
        function renderResolvedDrefArray(fieldName, resolvedArray, path) {
            let html = `<div style="margin: 10px 0;">
                <label style="font-weight: bold; display: block; margin-bottom: 5px;">
                    📎 ${fieldName} (${resolvedArray.length} items):
                </label>`;
            
            resolvedArray.forEach((resolvedRecord, index) => {
                html += renderResolvedDref(`${fieldName}[${index}]`, resolvedRecord, `${path}[${index}]`);
            });
            
            html += '</div>';
            return html;
        }

        /**
         * Render media field based on detected type
         */
        function renderMediaField(fieldName, value, mediaType) {
            const webUrl = value.webUrl || value;
            if (!webUrl) return '';
            
            switch (mediaType) {
                case 'image':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <img src="${webUrl}" alt="${fieldName}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 5px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <audio controls style="width: 100%; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'audio/mpeg'}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <video controls style="width: 100%; max-height: 300px; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'video/mp4'}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <div class="text-preview" style="margin: 5px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }

        /**
         * Render unresolved dref
         */
        function renderUnresolvedDref(fieldName, value) {
            const didValue = Array.isArray(value) ? value[0] : value;
            if (!didValue || !didValue.startsWith('did:arweave:')) return '';
            
            return `<div class="media-item">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName} (unresolved):</label>
                <div class="unresolved-dref">
                    📋 ${didValue}
                    <br><em>Increase resolve depth to see content</em>
                </div>
            </div>`;
        }

        function getRecordType(record) {
            // First, check the authoritative source: oip.recordType
            if (record.oip && record.oip.recordType) {
                return record.oip.recordType;
            }
            
            // Fallback: Try to get from data structure
            if (record.data) {
                const keys = Object.keys(record.data);
                for (const key of keys) {
                    if (key !== 'basic' && typeof record.data[key] === 'object') {
                        return key;
                    }
                }
            }
            
            return 'unknown';
        }

        function getContentPreview(data) {
            if (!data) return '';
            
            // Try common content fields
            if (data.content) return truncateText(data.content, 150);
            if (data.articleText) return truncateText(data.articleText, 150);
            if (data.description) return truncateText(data.description, 150);
            
            return '';
        }

        function createTagsDisplay(tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) return '';
            
            const tagsHtml = tags.slice(0, 5).map(tag => 
                `<span class="tag-chip" onclick="filterByTag('${escapeHtml(tag)}')" title="Filter by ${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
            ).join('');
            
            return `<div class="tags-container">${tagsHtml}</div>`;
        }



        // ========================================================================
        // ENHANCED DYNAMIC TEMPLATE SYSTEM
        // ========================================================================
        // 
        // This system dynamically renders OIP records based on their actual 
        // template definitions from the /api/templates endpoint, eliminating 
        // the need for hardcoded field names and types.
        //
        // Key Features:
        // - Loads all templates and builds field type mappings at startup
        // - Analyzes records to identify all templates used (including nested DREFs)
        // - Renders fields based on their actual template type definitions
        // - Handles resolved and unresolved DREF fields automatically
        // - Supports unlimited nesting depth with resolveDepth parameter
        // - Includes debug mode to show template analysis information
        // - Works with any new templates/fields without code changes
        //
        // Usage: Enable "Debug Templates" checkbox to see template analysis
        // Test: Run testTemplateSystem() in browser console to verify functionality
        // ========================================================================
        
        /**
         * Load all templates and build enhanced field mapping
         */
        async function loadTemplates() {
            try {
                console.log('[Templates] Loading all templates with enhanced mapping...');
                const response = await fetch('/api/templates?limit=1000');
                const data = await response.json();
                
                if (data.templates) {
                    // Clear existing mappings
                    templates = {};
                    allTemplates = {};
                    templateFieldMap = {};
                    
                    data.templates.forEach(template => {
                        const templateName = template.data.template || template.data.recordType || 'unknown';
                        const templateTxId = template.oip.did || template.oip.didTx;
                        const recordType = template.data.recordType || template.data.template || 'unknown';
                        
                        // Store in legacy format for compatibility
                        if (!templates[recordType]) {
                            templates[recordType] = [];
                        }
                        templates[recordType].push(template);
                        
                        // Store in enhanced format by name and TxId
                        allTemplates[templateName] = template;
                        allTemplates[templateTxId] = template;
                        
                        // Build field mapping for this template
                        if (template.data.fieldsInTemplate) {
                            templateFieldMap[templateName] = template.data.fieldsInTemplate;
                            templateFieldMap[templateTxId] = template.data.fieldsInTemplate;
                            
                            if (showDebugInfo) {
                                console.log(`[Templates] Mapped fields for ${templateName}:`, template.data.fieldsInTemplate);
                            }
                        }
                    });
                    
                    // Load default templates from config/templates.config.js
                    const defaultTemplates = require('../config/templates.config.js');

                    // defaultTemplates = {
                    //     basic: "did:arweave:-9DirnjVO1FlbEW1lN8jITBESrTsQKEM_BoZ1ey_0mk",
                    //     creatorRegistration: "did:arweave:BKVvTSXmmJni-L82irZfPFXWWJLBcdvbxS34jP1FTG8",
                    //     associatedUrlOnWeb: "did:arweave:_RJtiNMr1Ls9NG3G9-6rvbI5Sn0ccSnRTnrQCZi3ABE",
                    //     text: "did:arweave:of_eh0kGy65uYD0xsTh7Qe6JVTfJ2oFoA7xp4H7t7YI",
                    //     image: "did:arweave:AkZnE1VckJJlRamgNJuIGE7KrYwDcCciWOMrMh68V4o",
                    //     audio: "did:arweave:9MrI8kJvBJ-u7uvgngMZ-gMo5RREDwey8G7mJEUOpdo",
                    //     video: "did:arweave:G73WplyxpNDOgDSFO6CP3O6hZXq8kNJXxkCqx3sgd1s",
                    //     post: "did:arweave:op6y-d_6bqivJ2a2oWQnbylD4X_LH6eQyR6rCGqtVZ8",
                    //     recipe: "did:arweave:46Ui_ifw5LnrRmf_o2zWwikNxgXsXk3sswPtbcJCzlc",
                    //     workout: "did:arweave:T_16JOpyRKt0dmuZikHPpDcIhwh4DR1ZspHU4BKa-qE"
                    // };
                    
                    console.log(`[Templates] Loaded ${Object.keys(allTemplates).length / 2} templates`);
                    console.log(`[Templates] Field mappings for:`, Object.keys(templateFieldMap));
                }
            } catch (error) {
                console.error('[Templates] Error loading templates:', error);
            }
        }

        /**
         * Analyze a record to find all templates used (including nested drefs)
         */
        function analyzeRecordTemplates(record) {
            const templatesFound = new Set();
            
            function analyzeDataSection(data, path = '') {
                if (!data || typeof data !== 'object') return;
                
                Object.keys(data).forEach(key => {
                    if (key === 'basic' || key === 'oip') return; // Skip these
                    
                    const value = data[key];
                    const currentPath = path ? `${path}.${key}` : key;
                    
                    // This is a template section (e.g., 'post', 'image', etc.)
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        // Check if this looks like a template data section
                        if (value.webUrl || value.contentType || Object.keys(value).some(k => !k.startsWith('_'))) {
                            templatesFound.add(key);
                            if (showDebugInfo) {
                                console.log(`[Templates] Found template section: ${key} at ${currentPath}`);
                            }
                        }
                        
                        // Recursively analyze nested objects
                        analyzeDataSection(value, currentPath);
                    } else if (Array.isArray(value)) {
                        // Analyze array items (might be dref resolved objects)
                        value.forEach((item, index) => {
                            if (item && typeof item === 'object' && item.data) {
                                if (showDebugInfo) {
                                    console.log(`[Templates] Found resolved dref in array at ${currentPath}[${index}]`);
                                }
                                analyzeDataSection(item.data, `${currentPath}[${index}].data`);
                            }
                        });
                    } else if (typeof value === 'object' && value !== null && value.data) {
                        // This is a resolved dref
                        if (showDebugInfo) {
                            console.log(`[Templates] Found resolved dref at ${currentPath}`);
                        }
                        analyzeDataSection(value.data, `${currentPath}.data`);
                    }
                });
            }
            
            // Analyze the main data section
            if (record.data) {
                analyzeDataSection(record.data);
            }
            
            // Always include the main record type
            if (record.oip && record.oip.recordType) {
                templatesFound.add(record.oip.recordType);
            }
            
            return Array.from(templatesFound);
        }

        /**
         * Get field definition for a specific field in a template
         */
        function getFieldDefinition(templateName, fieldName) {
            const fieldsMap = templateFieldMap[templateName];
            if (!fieldsMap) return null;
            
            return fieldsMap[fieldName] || null;
        }

        /**
         * Determine if a field is a DREF based on its type and content
         */
        function isDrefField(fieldDef, value) {
            if (!fieldDef) return false;
            
            // Check type definition
            if (fieldDef.type === 'dref' || fieldDef.type === 'repeated dref') {
                return true;
            }
            
            // Check value pattern (did:arweave:...)
            if (typeof value === 'string' && value.startsWith('did:arweave:')) {
                return true;
            }
            
            // Check if it's an array of DIDs
            if (Array.isArray(value) && value.length > 0 && 
                typeof value[0] === 'string' && value[0].startsWith('did:arweave:')) {
                return true;
            }
            
            return false;
        }

        /**
         * Determine media type from field definition and content
         */
        function getMediaType(templateName, fieldName, value) {
            const fieldDef = getFieldDefinition(templateName, fieldName);
            
            // If it's a resolved dref, look at the embedded data
            if (value && typeof value === 'object' && value.data) {
                const embedTemplates = Object.keys(value.data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0]; // Return the template type (image, audio, video, text, etc.)
                }
            }
            
            // Check for arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data) {
                const embedTemplates = Object.keys(value[0].data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0];
                }
            }
            
            // Check field name patterns
            if (fieldName.toLowerCase().includes('image')) return 'image';
            if (fieldName.toLowerCase().includes('audio')) return 'audio';
            if (fieldName.toLowerCase().includes('video')) return 'video';
            if (fieldName.toLowerCase().includes('text')) return 'text';
            
            // Check content patterns
            if (value && typeof value === 'object') {
                if (value.webUrl) {
                    if (value.contentType) {
                        if (value.contentType.startsWith('image/')) return 'image';
                        if (value.contentType.startsWith('audio/')) return 'audio';
                        if (value.contentType.startsWith('video/')) return 'video';
                        if (value.contentType.startsWith('text/')) return 'text';
                    }
                }
            }
            
            return null;
        }

        async function loadRecordTypes() {
            try {
                const base = (typeof window !== 'undefined' && window.API_BASE_URL) ? window.API_BASE_URL : '';
                const response = await fetch(`${base}/api/templates?limit=25&page=1`);
                const data = await response.json();
                
                if (data.templates) {
                    const typeSet = new Set();
                    data.templates.forEach(template => {
                        if (template.data?.template) {
                            typeSet.add(template.data.template);
                        }
                    });
                    
                    recordTypes = Array.from(typeSet).sort();
                    populateRecordTypeFilter();
                }
            } catch (error) {
                console.error('Error loading record types:', error);
            }
        }

        function populateRecordTypeFilter() {
            // Populate voice record type filter (Browse + AI Chat tab)
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                
                recordTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    voiceSelect.appendChild(option);
                });
            }
        }

        // Utility functions
        function truncateText(text, length) {
            if (!text) return '';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function dateToUnixTime(dateString) {
            if (!dateString) return '';
            return Math.floor(new Date(dateString).getTime() / 1000).toString();
        }



        function setupInfiniteScroll() {
            window.addEventListener('scroll', () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
                    loadMoreRecords();
                }
            });
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = type === 'error' ? 'error-message' : 'success-message';
            element.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => element.classList.add('hidden'), 3000);
            }
        }

        function hideElement(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        // Publishing navigation functions
        function hideAllPublishingSections() {
            document.getElementById('creator-section').classList.add('hidden');
            document.getElementById('template-section').classList.add('hidden');
            document.getElementById('record-section').classList.add('hidden');
        }

        function showCreatorRegistration() {
            hideAllPublishingSections();
            document.getElementById('creator-section').classList.remove('hidden');
        }

        function showTemplateCreation() {
            hideAllPublishingSections();
            document.getElementById('template-section').classList.remove('hidden');
        }

        function showRecordPublishing() {
            hideAllPublishingSections();
            document.getElementById('record-section').classList.remove('hidden');
        }

        // Creator registration
        async function registerCreator() {
            const name = document.getElementById('creator-name').value;
            const description = document.getElementById('creator-description').value;
            const email = document.getElementById('creator-email').value;
            const website = document.getElementById('creator-website').value;

            if (!name) {
                showMessage('creator-status', 'Please enter a creator name', 'error');
                return;
            }

            const creatorData = {
                basic: {
                    name: name,
                    description: description,
                    language: 'en',
                    date: Math.floor(Date.now() / 1000),
                    nsfw: false
                },
                creatorRegistration: {
                    email: email || currentUser,
                    website: website,
                    verified: false
                }
            };

            try {
                const response = await fetch('/api/creators/newCreator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(creatorData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('creator-success', `Creator registered successfully! Transaction ID: ${data.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('creator-name').value = '';
                    document.getElementById('creator-description').value = '';
                    document.getElementById('creator-email').value = '';
                    document.getElementById('creator-website').value = '';
                } else {
                    showMessage('creator-status', data.error || 'Failed to register creator', 'error');
                }
            } catch (error) {
                showMessage('creator-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Template creation functions
        function addTemplateField() {
            const fieldsContainer = document.getElementById('template-fields');
            const fieldRow = document.createElement('div');
            fieldRow.className = 'field-row';
            fieldRow.innerHTML = `
                <div>
                    <label>Field Name:</label>
                    <input type="text" class="field-name" placeholder="e.g., title, content">
                </div>
                <div>
                    <label>Field Type:</label>
                    <select class="field-type">
                        <option value="string">String</option>
                        <option value="number">Number</option>
                        <option value="boolean">Boolean</option>
                        <option value="enum">Enum</option>
                        <option value="array">Array</option>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="removeField(this)">Remove</button>
                </div>
            `;
            fieldsContainer.appendChild(fieldRow);
        }

        function removeField(button) {
            button.closest('.field-row').remove();
        }

        async function createTemplate() {
            const templateName = document.getElementById('template-name').value;
            const recordType = document.getElementById('template-recordtype').value;

            if (!templateName || !recordType) {
                showMessage('template-status', 'Please fill in template name and record type', 'error');
                return;
            }

            const fieldRows = document.querySelectorAll('#template-fields .field-row');
            const templateFields = {};

            fieldRows.forEach(row => {
                const fieldName = row.querySelector('.field-name').value;
                const fieldType = row.querySelector('.field-type').value;
                
                if (fieldName && fieldType) {
                    templateFields[fieldName] = fieldType;
                }
            });

            if (Object.keys(templateFields).length === 0) {
                showMessage('template-status', 'Please add at least one field', 'error');
                return;
            }

            const templateData = {
                template: templateName,
                recordType: recordType,
                fields: JSON.stringify(templateFields)
            };

            try {
                const response = await fetch('/api/templates/newTemplate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(templateData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('template-success', `Template created successfully! Transaction ID: ${data.newTemplate.transactionId}`, 'success');
                    // Clear form and reload templates
                    document.getElementById('template-name').value = '';
                    document.getElementById('template-recordtype').value = '';
                    await loadTemplates();
                } else {
                    showMessage('template-status', data.error || 'Failed to create template', 'error');
                }
            } catch (error) {
                showMessage('template-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Enhanced Record Publishing Functions
        function loadPublishInterface() {
            const recordType = document.getElementById('publish-record-type').value;
            const interfaceContainer = document.getElementById('publish-interface');
            
            if (!recordType) {
                interfaceContainer.innerHTML = '<div class="loading">Select a record type to see publishing interface</div>';
                return;
            }

            // Create tailored interface based on record type
            switch (recordType) {
                case 'post':
                    interfaceContainer.innerHTML = createPostInterface();
                    // Initialize storage type handler after interface is created
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                    }, 100);
                    break;
                case 'video':
                    interfaceContainer.innerHTML = createVideoInterface();
                    break;
                case 'audio':
                    interfaceContainer.innerHTML = createAudioInterface();
                    break;
                case 'image':
                    interfaceContainer.innerHTML = createImageInterface();
                    break;
                case 'recipe':
                    interfaceContainer.innerHTML = createRecipeInterface();
                    break;
                case 'workout':
                    interfaceContainer.innerHTML = createWorkoutInterface();
                    break;
                case 'exercise':
                    interfaceContainer.innerHTML = createExerciseInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                    }, 100);
                    break;
                case 'fitnessEquipment':
                    interfaceContainer.innerHTML = createFitnessEquipmentInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize equipment access level
                        updateEquipmentAccessLevel();
                    }, 100);
                    break;
                case 'media':
                    interfaceContainer.innerHTML = createMediaInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize organization field visibility
                        updateMediaAccessLevel();
                    }, 100);
                    break;
                case 'multiResolutionGif':
                    interfaceContainer.innerHTML = createMultiResolutionGifInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize GIF input method and access level
                        updateGifInputMethod();
                        updateGifAccessLevel();
                    }, 100);
                    break;
                case 'text':
                    interfaceContainer.innerHTML = createTextInterface();
                    break;
                case 'organization':
                    interfaceContainer.innerHTML = createOrganizationInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                    }, 100);
                    break;
                default:
                    interfaceContainer.innerHTML = '<div class="loading">Unknown record type</div>';
            }
        }

        function createPostInterface() {
            return `
                <div class="publish-form">
                    <h3>📝 Post / Article Publishing</h3>
                    
                    <!-- Post Source Selection -->
                    <div class="form-group">
                        <label for="post-source">Post Source:</label>
                        <select id="post-source" onchange="updatePostSource()">
                            <option value="manual">Create New Post</option>
                            <option value="archive-x">Archive X/Twitter Post</option>
                            <option value="archive-web">Archive Web Article</option>
                        </select>
                    </div>

                    <!-- Manual Post Creation Interface -->
                    <div id="manual-post-interface">
                        <!-- Post Type Selection -->
                        <div class="form-group">
                            <label for="post-type">Post Type:</label>
                            <select id="post-type" onchange="updatePostInterface()">
                                <option value="microblog">Microblog Post (Twitter-style)</option>
                                <option value="article">News Article</option>
                                <option value="blog">Blog Post</option>
                            </select>
                        </div>

                        <!-- Basic Information -->
                        <div class="form-group">
                            <label for="post-title">Title:</label>
                            <input type="text" id="post-title" required placeholder="Enter post title...">
                        </div>

                        <div class="form-group">
                            <label for="post-description">Description:</label>
                            <textarea id="post-description" placeholder="Brief description of the post..." rows="2"></textarea>
                        </div>

                        <!-- Article Content -->
                        <div class="form-group">
                            <label for="post-content">Content:</label>
                            <textarea id="post-content" required placeholder="Write your post content here..." rows="8"></textarea>
                            <small>Supports markdown formatting</small>
                        </div>

                        <!-- Author Information (for articles) -->
                        <div id="author-section">
                            <div class="form-group">
                                <label for="post-author">Author:</label>
                                <input type="text" id="post-author" placeholder="Author name">
                            </div>
                            <div class="form-group">
                                <label for="post-author-title">Author Title:</label>
                                <input type="text" id="post-author-title" placeholder="e.g., Senior Reporter">
                            </div>
                            <div class="form-group">
                                <label for="post-author-location">Author Location:</label>
                                <input type="text" id="post-author-location" placeholder="e.g., New York">
                            </div>
                        </div>

                        <!-- Media Attachments -->
                        <div class="media-section">
                            <h4>📎 Media Attachments</h4>
                            
                            <div class="form-group">
                                <label for="post-featured-image">Featured Image URL:</label>
                                <input type="url" id="post-featured-image" placeholder="https://example.com/image.jpg">
                            </div>

                            <div class="form-group">
                                <label for="post-web-url">Source URL:</label>
                                <input type="url" id="post-web-url" placeholder="Original article URL (if reposting)">
                            </div>

                            <div class="form-group">
                                <label for="post-reply-to">Reply To (DID):</label>
                                <input type="text" id="post-reply-to" placeholder="did:arweave:... (if replying to another post)">
                            </div>
                        </div>

                        <!-- Tags -->
                        <div class="form-group">
                            <label for="post-tags">Tags:</label>
                            <input type="text" id="post-tags" placeholder="tag1, tag2, tag3">
                            <small>Comma-separated tags</small>
                        </div>

                        <!-- NSFW Toggle -->
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="post-nsfw"> NSFW Content
                            </label>
                        </div>

                        <!-- GUN-specific options -->
                        <div id="gun-options" class="form-group" style="display: none; background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                            <h4 style="margin: 0 0 10px 0; color: #3730a3;">🔒 GUN Private Storage Options</h4>
                            
                            <div class="form-group">
                                <label for="gun-local-id">Local ID (optional):</label>
                                <input type="text" id="gun-local-id" placeholder="draft-001, my-recipe, etc.">
                                <small>Provide a custom identifier for this record. If empty, a content hash will be used.</small>
                            </div>

                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="gun-private"> Private Record (Encrypted)
                                </label>
                                <small>Check to encrypt this record. Only you will be able to read it.</small>
                            </div>
                        </div>
                    </div>

                    <!-- X Post Archival Interface -->
                    <div id="x-post-interface" class="hidden">
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                            <strong>💡 Tip:</strong> For reliable X post archiving, configure X API access. 
                            <a href="docs/X_API_SETUP.md" target="_blank" style="color: #1da1f2;">See setup guide</a>
                        </div>
                        
                        <div class="form-group">
                            <label for="x-post-url">X/Twitter Post URL:</label>
                            <input type="url" id="x-post-url" placeholder="https://x.com/username/status/1234567890" required>
                            <button type="button" onclick="scrapeXPost()" style="margin-top: 10px; width: 100%;">
                                🔍 Fetch Post Data
                            </button>
                        </div>

                        <div id="x-post-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #1da1f2;">
                            <h4>📱 Post Preview</h4>
                            <div id="x-post-content"></div>
                            <div id="x-post-meta" style="margin-top: 10px; font-size: 0.9rem; color: #666;"></div>
                        </div>

                        <div id="x-post-status" class="hidden" style="margin-top: 15px; padding: 10px; border-radius: 6px;"></div>
                    </div>

                    <!-- Web Article Archival Interface -->
                    <div id="web-article-interface" class="hidden">
                        <div class="form-group">
                            <label for="web-article-url">Article URL:</label>
                            <input type="url" id="web-article-url" placeholder="https://example.com/article-title" required>
                            <button type="button" onclick="scrapeWebArticle()" style="margin-top: 10px; width: 100%;">
                                📰 Archive Article
                            </button>
                        </div>

                        <div id="web-article-progress" class="hidden" style="margin-top: 20px;">
                            <div class="publish-progress">
                                <h4 id="web-article-progress-title">📰 Archiving Web Article...</h4>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="web-article-progress-bar" style="width: 0%;"></div>
                                </div>
                                <div id="web-article-status" style="margin-top: 10px; font-size: 0.9rem;">Initializing...</div>
                            </div>
                        </div>

                        <div id="web-article-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
                            <h4>📰 Article Preview</h4>
                            <div id="web-article-content"></div>
                            <div id="web-article-meta" style="margin-top: 10px; font-size: 0.9rem; color: #666;"></div>
                        </div>

                        <div id="web-article-result" class="hidden" style="margin-top: 15px; padding: 10px; border-radius: 6px;"></div>
                    </div>

                    <button onclick="publishPost()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="post-publish-text">📤 Publish Post</span>
                    </button>
                </div>
            `;
        }

        function createVideoInterface() {
            return `
                <div class="publish-form">
                    <h3>🎥 Video Publishing</h3>
                    
                    <!-- Video Source -->
                    <div class="form-group">
                        <label for="video-source">Video Source:</label>
                        <select id="video-source" onchange="updateVideoInterface()">
                            <option value="manual">Manual Entry</option>
                            <option value="youtube-archive">Archive YouTube Video</option>
                            <option value="direct">Direct Video URL</option>
                            <option value="upload">Upload Video File</option>
                        </select>
                    </div>

                    <div id="video-input-section">
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    </div>

                    <!-- Video Information -->
                    <div class="form-group">
                        <label for="video-title">Title:</label>
                        <input type="text" id="video-title" required placeholder="Video title">
                    </div>

                    <div class="form-group">
                        <label for="video-description">Description:</label>
                        <textarea id="video-description" placeholder="Video description..." rows="4"></textarea>
                    </div>

                    <!-- Video Metadata -->
                    <div class="form-group">
                        <label for="video-duration">Duration (minutes):</label>
                        <input type="number" id="video-duration" placeholder="e.g., 15">
                    </div>

                    <div class="form-group">
                        <label for="video-channel">Channel/Creator:</label>
                        <input type="text" id="video-channel" placeholder="Channel or creator name">
                    </div>

                    <div class="form-group">
                        <label for="video-thumbnail">Thumbnail URL:</label>
                        <input type="url" id="video-thumbnail" placeholder="https://example.com/thumbnail.jpg">
                    </div>

                    <!-- Tags and Categories -->
                    <div class="form-group">
                        <label for="video-category">Category:</label>
                        <select id="video-category">
                            <option value="">Select category</option>
                            <option value="education">Education</option>
                            <option value="entertainment">Entertainment</option>
                            <option value="music">Music</option>
                            <option value="news">News</option>
                            <option value="sports">Sports</option>
                            <option value="technology">Technology</option>
                            <option value="gaming">Gaming</option>
                            <option value="howto">How-to & Style</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="video-tags">Tags:</label>
                        <input type="text" id="video-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="video-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="video-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="video-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishVideo()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="video-publish-text">🎥 Publish Video</span>
                    </button>
                </div>
            `;
        }

        function createAudioInterface() {
            return `
                <div class="publish-form">
                    <h3>🎵 Audio / Podcast Publishing</h3>
                    
                    <!-- Audio Source -->
                    <div class="form-group">
                        <label for="audio-source">Audio Source:</label>
                        <select id="audio-source" onchange="updateAudioInterface()">
                            <option value="url">Audio URL</option>
                            <option value="upload">Upload Audio File</option>
                        </select>
                    </div>

                    <div id="audio-input-section">
                        <div class="form-group">
                            <label for="audio-url">Audio URL:</label>
                            <input type="url" id="audio-url" placeholder="https://example.com/audio.mp3">
                        </div>
                    </div>

                    <!-- Audio Information -->
                    <div class="form-group">
                        <label for="audio-title">Title:</label>
                        <input type="text" id="audio-title" required placeholder="Audio title">
                    </div>

                    <div class="form-group">
                        <label for="audio-description">Description:</label>
                        <textarea id="audio-description" placeholder="Audio description..." rows="4"></textarea>
                    </div>

                    <!-- Audio Metadata -->
                    <div class="form-group">
                        <label for="audio-duration">Duration (minutes):</label>
                        <input type="number" id="audio-duration" placeholder="e.g., 45">
                    </div>

                    <div class="form-group">
                        <label for="audio-artist">Artist/Creator:</label>
                        <input type="text" id="audio-artist" placeholder="Artist or creator name">
                    </div>

                    <div class="form-group">
                        <label for="audio-album">Album/Series:</label>
                        <input type="text" id="audio-album" placeholder="Album or podcast series name">
                    </div>

                    <!-- Cover Art -->
                    <div class="form-group">
                        <label for="audio-cover">Cover Art URL:</label>
                        <input type="url" id="audio-cover" placeholder="https://example.com/cover.jpg">
                    </div>

                    <!-- Genre and Tags -->
                    <div class="form-group">
                        <label for="audio-genre">Genre:</label>
                        <select id="audio-genre">
                            <option value="">Select genre</option>
                            <option value="podcast">Podcast</option>
                            <option value="music">Music</option>
                            <option value="audiobook">Audiobook</option>
                            <option value="interview">Interview</option>
                            <option value="education">Education</option>
                            <option value="comedy">Comedy</option>
                            <option value="news">News</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="audio-tags">Tags:</label>
                        <input type="text" id="audio-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="audio-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="audio-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="audio-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishAudio()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🎵 Publish Audio
                    </button>
                </div>
            `;
        }

        function createImageInterface() {
            return `
                <div class="publish-form">
                    <h3>📷 Image Publishing</h3>
                    
                    <!-- Image Source -->
                    <div class="form-group">
                        <label for="image-source">Image Source:</label>
                        <select id="image-source" onchange="updateImageInterface()">
                            <option value="url">Image URL</option>
                            <option value="upload">Upload Image File</option>
                        </select>
                    </div>

                    <div id="image-input-section">
                        <div class="form-group">
                            <label for="image-url">Image URL:</label>
                            <input type="url" id="image-url" placeholder="https://example.com/image.jpg">
                            <button type="button" onclick="previewImage()" style="margin-top: 5px;">Preview</button>
                        </div>
                    </div>

                    <!-- Image Preview -->
                    <div id="image-preview" class="hidden" style="margin: 15px 0;">
                        <img id="preview-img" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
                    </div>

                    <!-- Image Information -->
                    <div class="form-group">
                        <label for="image-title">Title:</label>
                        <input type="text" id="image-title" required placeholder="Image title">
                    </div>

                    <div class="form-group">
                        <label for="image-description">Description:</label>
                        <textarea id="image-description" placeholder="Image description..." rows="3"></textarea>
                    </div>

                    <!-- Image Metadata -->
                    <div class="form-group">
                        <label for="image-alt-text">Alt Text:</label>
                        <input type="text" id="image-alt-text" placeholder="Accessibility description">
                    </div>

                    <div class="form-group">
                        <label for="image-photographer">Photographer/Creator:</label>
                        <input type="text" id="image-photographer" placeholder="Creator name">
                    </div>

                    <div class="form-group">
                        <label for="image-location">Location:</label>
                        <input type="text" id="image-location" placeholder="Where the image was taken">
                    </div>

                    <!-- Categories and Tags -->
                    <div class="form-group">
                        <label for="image-category">Category:</label>
                        <select id="image-category">
                            <option value="">Select category</option>
                            <option value="photography">Photography</option>
                            <option value="art">Art</option>
                            <option value="nature">Nature</option>
                            <option value="architecture">Architecture</option>
                            <option value="portrait">Portrait</option>
                            <option value="landscape">Landscape</option>
                            <option value="abstract">Abstract</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="image-tags">Tags:</label>
                        <input type="text" id="image-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="image-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="image-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="image-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishImage()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📷 Publish Image
                    </button>
                </div>
            `;
        }

        function createRecipeInterface() {
            return `
                <div class="publish-form">
                    <h3>🍳 Recipe Publishing</h3>
                    
                    <!-- Recipe Basic Info -->
                    <div class="form-group">
                        <label for="recipe-title">Recipe Name:</label>
                        <input type="text" id="recipe-title" required placeholder="e.g., Mediterranean Grilled Chicken">
                    </div>

                    <div class="form-group">
                        <label for="recipe-description">Description:</label>
                        <textarea id="recipe-description" placeholder="Brief description of the recipe..." rows="3"></textarea>
                    </div>

                    <!-- Recipe Image -->
                    <div class="form-group">
                        <label for="recipe-image">Recipe Image URL:</label>
                        <input type="url" id="recipe-image" placeholder="https://example.com/recipe-image.jpg">
                    </div>

                    <!-- Recipe Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-prep-time">Prep Time (minutes):</label>
                            <input type="number" id="recipe-prep-time" placeholder="e.g., 15">
                        </div>
                        <div class="form-group">
                            <label for="recipe-cook-time">Cook Time (minutes):</label>
                            <input type="number" id="recipe-cook-time" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="recipe-servings">Servings:</label>
                            <input type="number" id="recipe-servings" placeholder="e.g., 4">
                        </div>
                        <div class="form-group">
                            <label for="recipe-difficulty">Difficulty:</label>
                            <select id="recipe-difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                    </div>

                    <!-- Cuisine and Course -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-cuisine">Cuisine:</label>
                            <input type="text" id="recipe-cuisine" placeholder="e.g., Mediterranean, Italian">
                        </div>
                        <div class="form-group">
                            <label for="recipe-course">Course:</label>
                            <select id="recipe-course">
                                <option value="">Select course</option>
                                <option value="appetizer">Appetizer</option>
                                <option value="main">Main Course</option>
                                <option value="side">Side Dish</option>
                                <option value="dessert">Dessert</option>
                                <option value="drink">Drink</option>
                                <option value="snack">Snack</option>
                            </select>
                        </div>
                    </div>

                    <!-- Ingredients -->
                    <div class="form-group">
                        <label>Ingredients:</label>
                        <div id="ingredients-container">
                            <div class="ingredient-row" style="display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Amount" class="ingredient-amount">
                                <input type="text" placeholder="Unit" class="ingredient-unit">
                                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                                <button type="button" onclick="removeIngredient(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addIngredient()" style="margin-top: 10px;">+ Add Ingredient</button>
                    </div>

                    <!-- Instructions -->
                    <div class="form-group">
                        <label for="recipe-instructions">Instructions:</label>
                        <textarea id="recipe-instructions" required placeholder="1. First step...
2. Second step...
3. Third step..." rows="8"></textarea>
                        <small>Write each step on a new line</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="recipe-notes">Notes:</label>
                        <textarea id="recipe-notes" placeholder="Additional notes, tips, or variations..." rows="3"></textarea>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="recipe-tags">Tags:</label>
                        <input type="text" id="recipe-tags" placeholder="vegetarian, quick, healthy">
                    </div>

                    <button onclick="publishRecipe()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🍳 Publish Recipe
                    </button>
                </div>
            `;
        }

        function createWorkoutInterface() {
            return `
                <div class="publish-form">
                    <h3>💪 Workout Publishing</h3>
                    
                    <!-- Workout Basic Info -->
                    <div class="form-group">
                        <label for="workout-title">Workout Name:</label>
                        <input type="text" id="workout-title" required placeholder="e.g., Full Body HIIT Workout">
                    </div>

                    <div class="form-group">
                        <label for="workout-description">Description:</label>
                        <textarea id="workout-description" placeholder="Brief description of the workout..." rows="3"></textarea>
                    </div>

                    <!-- Workout Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-duration">Duration (minutes):</label>
                            <input type="number" id="workout-duration" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="workout-difficulty">Difficulty:</label>
                            <select id="workout-difficulty">
                                <option value="beginner">Beginner</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="advanced">Advanced</option>
                            </select>
                        </div>
                    </div>

                    <!-- Workout Type and Equipment -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-category">Category:</label>
                            <select id="workout-category">
                                <option value="">Select category</option>
                                <option value="strength">Strength Training</option>
                                <option value="cardio">Cardio</option>
                                <option value="hiit">HIIT</option>
                                <option value="yoga">Yoga</option>
                                <option value="pilates">Pilates</option>
                                <option value="flexibility">Flexibility</option>
                                <option value="sports">Sports</option>
                                <option value="mixed">Mixed</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="workout-equipment">Equipment Required:</label>
                            <input type="text" id="workout-equipment" placeholder="dumbbells, resistance bands">
                        </div>
                    </div>

                    <!-- Target Muscle Groups -->
                    <div class="form-group">
                        <label for="workout-muscles">Target Muscle Groups:</label>
                        <input type="text" id="workout-muscles" placeholder="chest, shoulders, legs">
                    </div>

                    <!-- Exercises -->
                    <div class="form-group">
                        <label>Exercises:</label>
                        <div id="exercises-container">
                            <div class="exercise-row" style="display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Exercise name" class="exercise-name">
                                <input type="text" placeholder="Sets" class="exercise-sets">
                                <input type="text" placeholder="Reps" class="exercise-reps">
                                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                                <button type="button" onclick="removeExercise(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addExercise()" style="margin-top: 10px;">+ Add Exercise</button>
                    </div>

                    <!-- Workout Type Toggle -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="workout-non-standard"> Non-standard workout (custom exercises)
                        </label>
                        <small>Check this if your exercises are not in our database</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="workout-notes">Notes:</label>
                        <textarea id="workout-notes" placeholder="Additional notes, tips, or modifications..." rows="3"></textarea>
                    </div>

                    <!-- Goal Tags -->
                    <div class="form-group">
                        <label for="workout-goals">Goal Tags:</label>
                        <input type="text" id="workout-goals" placeholder="weight loss, muscle gain, endurance">
                    </div>

                    <button onclick="publishWorkout()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        💪 Publish Workout
                    </button>
                </div>
            `;
        }

        function createTextInterface() {
            return `
                <div class="publish-form">
                    <h3>📄 Text Document Publishing</h3>
                    
                    <!-- Text Document Info -->
                    <div class="form-group">
                        <label for="text-title">Document Title:</label>
                        <input type="text" id="text-title" required placeholder="Document title">
                    </div>

                    <div class="form-group">
                        <label for="text-description">Description:</label>
                        <textarea id="text-description" placeholder="Brief description..." rows="2"></textarea>
                    </div>

                    <!-- Content -->
                    <div class="form-group">
                        <label for="text-content">Content:</label>
                        <textarea id="text-content" required placeholder="Enter your text content here..." rows="15"></textarea>
                        <small>Supports plain text and markdown</small>
                    </div>

                    <!-- Document Type -->
                    <div class="form-group">
                        <label for="text-type">Document Type:</label>
                        <select id="text-type">
                            <option value="document">Document</option>
                            <option value="article">Article</option>
                            <option value="essay">Essay</option>
                            <option value="story">Story</option>
                            <option value="poem">Poem</option>
                            <option value="tutorial">Tutorial</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Author Information -->
                    <div class="form-group">
                        <label for="text-author">Author:</label>
                        <input type="text" id="text-author" placeholder="Author name">
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="text-language">Language:</label>
                        <select id="text-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="text-tags">Tags:</label>
                        <input type="text" id="text-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="text-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishText()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📄 Publish Text
                    </button>
                </div>
            `;
        }

        function createOrganizationInterface() {
            return `
                <div class="publish-form">
                    <h3>🏢 Organization Registration</h3>
                    
                    <div class="info-box" style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>🔐 Organization Ownership</h4>
                        <p>Organizations are created using your HD wallet identity:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>🔑 <strong>Your public key</strong> will be set as the organization public key</li>
                            <li>👑 <strong>You will be the admin</strong> with full management rights</li>
                            <li>🏢 <strong>Organization handle</strong> must be unique across the network</li>
                            <li>📋 <strong>Membership policy</strong> controls how users can join</li>
                        </ul>
                    </div>

                    <!-- Organization Basic Info -->
                    <div class="form-group">
                        <label for="org-name">Organization Name:</label>
                        <input type="text" id="org-name" required placeholder="e.g., ALEXANDRIA Research Foundation">
                        <small>The full, human-readable name of your organization</small>
                    </div>

                    <div class="form-group">
                        <label for="org-description">Description:</label>
                        <textarea id="org-description" required placeholder="Brief description of your organization's mission and activities..." rows="4"></textarea>
                        <small>Describe what your organization does and its goals</small>
                    </div>

                    <!-- Organization Handle -->
                    <div class="form-group">
                        <label for="org-handle">Organization Handle:</label>
                        <input type="text" id="org-handle" required placeholder="e.g., alexandria-research" pattern="[a-z0-9-]+" style="font-family: monospace;">
                        <small>Unique identifier (lowercase letters, numbers, and hyphens only). This cannot be changed later.</small>
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="org-language">Primary Language:</label>
                        <select id="org-language">
                            <option value="en">English</option>
                            <option value="es">Spanish; Castilian</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="pt">Portuguese</option>
                            <option value="ru">Russian</option>
                            <option value="it">Italian</option>
                            <option value="ko">Korean</option>
                            <option value="tr">Turkish</option>
                            <option value="pl">Polish</option>
                            <option value="nl">Dutch; Flemish</option>
                            <option value="sv">Swedish</option>
                            <option value="da">Danish</option>
                            <option value="no">Norwegian</option>
                            <option value="fi">Finnish</option>
                            <option value="el">Greek, Modern (1453-)</option>
                            <option value="he">Hebrew</option>
                            <option value="th">Thai</option>
                            <option value="vi">Vietnamese</option>
                            <option value="cs">Czech</option>
                            <option value="hu">Hungarian</option>
                            <option value="ro">Romanian; Moldavian; Moldovan</option>
                            <option value="bg">Bulgarian</option>
                            <option value="hr">Croatian</option>
                            <option value="sk">Slovak</option>
                            <option value="sl">Slovenian</option>
                            <option value="et">Estonian</option>
                            <option value="lv">Latvian</option>
                            <option value="lt">Lithuanian</option>
                            <option value="uk">Ukrainian</option>
                            <option value="be">Belarusian</option>
                            <option value="mk">Macedonian</option>
                            <option value="sq">Albanian</option>
                            <option value="sr">Serbian</option>
                            <option value="bs">Bosnian</option>
                            <option value="mt">Maltese</option>
                            <option value="ga">Irish</option>
                            <option value="cy">Welsh</option>
                            <option value="is">Icelandic</option>
                            <option value="fo">Faroese</option>
                            <option value="eu">Basque</option>
                            <option value="ca">Catalan; Valencian</option>
                            <option value="gl">Galician</option>
                            <option value="oc">Occitan (post 1500)</option>
                            <option value="br">Breton</option>
                            <option value="gd">Gaelic; Scomttish Gaelic</option>
                            <option value="gv">Manx</option>
                            <option value="kw">Cornish</option>
                            <option value="cy">Welsh</option>
                            <option value="af">Afrikaans</option>
                            <option value="zu">Zulu</option>
                            <option value="xh">Xhosa</option>
                            <option value="sw">Swahili</option>
                            <option value="am">Amharic</option>
                            <option value="ti">Tigrinya</option>
                            <option value="so">Somali</option>
                            <option value="om">Oromo</option>
                            <option value="ha">Hausa</option>
                            <option value="yo">Yoruba</option>
                            <option value="ig">Igbo</option>
                            <option value="aa">Afar</option>
                            <option value="ab">Abkhazian</option>
                            <option value="ae">Avestan</option>
                            <option value="ak">Akan</option>
                            <option value="an">Aragonese</option>
                            <option value="as">Assamese</option>
                            <option value="av">Avaric</option>
                            <option value="ay">Aymara</option>
                            <option value="az">Azerbaijani</option>
                            <option value="ba">Bashkir</option>
                            <option value="bh">Bihari languages</option>
                            <option value="bi">Bislama</option>
                            <option value="bm">Bambara</option>
                            <option value="bn">Bengali</option>
                            <option value="bo">Tibetan</option>
                            <option value="ce">Chechen</option>
                            <option value="ch">Chamorro</option>
                            <option value="co">Corsican</option>
                            <option value="cr">Cree</option>
                            <option value="cu">Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic</option>
                            <option value="cv">Chuvash</option>
                            <option value="dv">Divehi; Dhivehi; Maldivian</option>
                            <option value="dz">Dzongkha</option>
                            <option value="ee">Ewe</option>
                            <option value="eo">Esperanto</option>
                            <option value="et">Estonian</option>
                            <option value="fa">Persian</option>
                            <option value="ff">Fulah</option>
                            <option value="fj">Fijian</option>
                            <option value="fy">Western Frisian</option>
                            <option value="gn">Guarani</option>
                            <option value="gu">Gujarati</option>
                            <option value="ht">Haitian; Haitian Creole</option>
                            <option value="hy">Armenian</option>
                            <option value="hz">Herero</option>
                            <option value="ia">Interlingua (International Auxiliary Language Association)</option>
                            <option value="id">Indonesian</option>
                            <option value="ie">Interlingue; Occidental</option>
                            <option value="ii">Sichuan Yi; Nuosu</option>
                            <option value="ik">Inupiaq</option>
                            <option value="io">Ido</option>
                            <option value="iu">Inuktitut</option>
                            <option value="jv">Javanese</option>
                            <option value="ka">Georgian</option>
                            <option value="kg">Kongo</option>
                            <option value="ki">Kikuyu; Gikuyu</option>
                            <option value="kj">Kuanyama; Kwanyama</option>
                            <option value="kk">Kazakh</option>
                            <option value="kl">Kalaallisut; Greenlandic</option>
                            <option value="km">Central Khmer</option>
                            <option value="kn">Kannada</option>
                            <option value="kr">Kanuri</option>
                            <option value="ks">Kashmiri</option>
                            <option value="ku">Kurdish</option>
                            <option value="kv">Komi</option>
                            <option value="ky">Kirghiz; Kyrgyz</option>
                            <option value="la">Latin</option>
                            <option value="lb">Luxembourgish; Letzeburgesch</option>
                            <option value="lg">Ganda</option>
                            <option value="li">Limburgan; Limburger; Limburgish</option>
                            <option value="ln">Lingala</option>
                            <option value="lo">Lao</option>
                            <option value="lu">Luba-Katanga</option>
                            <option value="mg">Malagasy</option>
                            <option value="mh">Marshallese</option>
                            <option value="mi">Maori</option>
                            <option value="ml">Malayalam</option>
                            <option value="mn">Mongolian</option>
                            <option value="mr">Marathi</option>
                            <option value="ms">Malay</option>
                            <option value="my">Burmese</option>
                            <option value="na">Nauru</option>
                            <option value="nb">Bokmål, Norwegian; Norwegian Bokmål</option>
                            <option value="nd">Ndebele, North; North Ndebele</option>
                            <option value="ne">Nepali</option>
                            <option value="ng">Ndonga</option>
                            <option value="nn">Norwegian Nynorsk; Nynorsk, Norwegian</option>
                            <option value="nr">Ndebele, South; South Ndebele</option>
                            <option value="nv">Navajo; Navaho</option>
                            <option value="ny">Chichewa; Chewa; Nyanja</option>
                            <option value="oj">Ojibwa</option>
                            <option value="or">Oriya</option>
                            <option value="os">Ossetian; Ossetic</option>
                            <option value="pa">Panjabi; Punjabi</option>
                            <option value="pi">Pali</option>
                            <option value="ps">Pushto; Pashto</option>
                            <option value="qu">Quechua</option>
                            <option value="rm">Romansh</option>
                            <option value="rn">Rundi</option>
                            <option value="rw">Kinyarwanda</option>
                            <option value="sa">Sanskrit</option>
                            <option value="sc">Sardinian</option>
                            <option value="sd">Sindhi</option>
                            <option value="se">Northern Sami</option>
                            <option value="sg">Sango</option>
                            <option value="si">Sinhala; Sinhalese</option>
                            <option value="sm">Samoan</option>
                            <option value="sn">Shona</option>
                            <option value="ss">Swati</option>
                            <option value="st">Sotho, Southern</option>
                            <option value="su">Sundanese</option>
                            <option value="ta">Tamil</option>
                            <option value="te">Telugu</option>
                            <option value="tg">Tajik</option>
                            <option value="ti">Tigrinya</option>
                            <option value="tk">Turkmen</option>
                            <option value="tl">Tagalog</option>
                            <option value="tn">Tswana</option>
                            <option value="to">Tonga (Tonga Islands)</option>
                            <option value="ts">Tsonga</option>
                            <option value="tt">Tatar</option>
                            <option value="tw">Twi</option>
                            <option value="ty">Tahitian</option>
                            <option value="ug">Uighur; Uyghur</option>
                            <option value="ur">Urdu</option>
                            <option value="uz">Uzbek</option>
                            <option value="ve">Venda</option>
                            <option value="vo">Volapük</option>
                            <option value="wa">Walloon</option>
                            <option value="wo">Wolof</option>
                            <option value="yi">Yiddish</option>
                            <option value="za">Zhuang; Chuang</option>
                        </select>
                        <small>Primary language for organization communications</small>
                    </div>

                    <!-- Website URL -->
                    <div class="form-group">
                        <label for="org-web-url">Website URL:</label>
                        <input type="url" id="org-web-url" placeholder="https://example.com">
                        <small>Official website or main online presence</small>
                    </div>

                    <!-- Organization Handle -->
                    <div class="form-group">
                        <label for="org-handle">Organization Handle:</label>
                        <input type="text" id="org-handle" required placeholder="e.g., alexandria-research" pattern="[a-z0-9-]+" style="font-family: monospace;">
                        <small>Unique identifier (lowercase letters, numbers, and hyphens only). This cannot be changed later.</small>
                    </div>

                    <!-- Membership Policy -->
                    <div class="form-group">
                        <label for="org-membership-policy">Membership Policy:</label>
                        <select id="org-membership-policy" required>
                            <option value="">Select membership policy</option>
                            <option value="invite-only">Invite Only - Members must be invited by admins</option>
                            <option value="app-user-auto">Auto-Enroll App Users - All app users automatically join</option>
                            <option value="token-gated">Token-Gated Membership - Requires specific tokens/NFTs</option>
                            <option value="open-join">Open Join - Anyone can join freely</option>
                        </select>
                        <small>Controls how users can become members of your organization</small>
                    </div>

                    <!-- Ownership Information (Read-Only) -->
                    <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745;">
                        <h4 style="margin: 0 0 10px 0; color: #28a745;">🔐 Ownership Details</h4>
                        <div style="font-family: monospace; font-size: 12px; color: #666;">
                            <div><strong>Organization Public Key:</strong> <span id="org-public-key-display">Loading from JWT...</span></div>
                            <div><strong>Admin Public Key:</strong> <span id="org-admin-key-display">Loading from JWT...</span></div>
                        </div>
                        <small>These are automatically derived from your authenticated HD wallet</small>
                    </div>

                    <!-- GUN-specific options -->
                    <div id="gun-options" class="form-group" style="display: none; background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <h4 style="margin: 0 0 10px 0; color: #3730a3;">🔒 GUN Private Storage Options</h4>
                        
                        <div class="form-group">
                            <label for="gun-local-id">Local ID (optional):</label>
                            <input type="text" id="gun-local-id" placeholder="my-org-001, foundation-draft, etc.">
                            <small>Provide a custom identifier for this organization. If empty, the org handle will be used.</small>
                        </div>

                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="gun-private"> Private Organization (Encrypted)
                            </label>
                            <small>Check to encrypt this organization record. Only you will be able to read it.</small>
                        </div>
                    </div>

                    <button onclick="publishOrganization()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏢 Register Organization
                    </button>
                </div>
            `;
        }

        function createExerciseInterface() {
            return `
                <div class="publish-form">
                    <h3>🏋️ Exercise Publishing</h3>
                    
                    <!-- Exercise Basic Info -->
                    <div class="form-group">
                        <label for="exercise-name">Exercise Name:</label>
                        <input type="text" id="exercise-name" required placeholder="e.g., Barbell Bench Press">
                    </div>

                    <div class="form-group">
                        <label for="exercise-description">Description:</label>
                        <textarea id="exercise-description" placeholder="Brief description of the exercise..." rows="3"></textarea>
                    </div>

                    <!-- Exercise Category -->
                    <div class="form-group">
                        <label for="exercise-category">Category:</label>
                        <select id="exercise-category">
                            <option value="strength">Strength</option>
                            <option value="cardio">Cardio</option>
                            <option value="flexibility">Flexibility</option>
                            <option value="balance">Balance</option>
                            <option value="functional">Functional</option>
                            <option value="rehabilitation">Rehabilitation</option>
                        </select>
                    </div>

                    <!-- Exercise Type -->
                    <div class="form-group">
                        <label for="exercise-type">Exercise Type:</label>
                        <select id="exercise-type">
                            <option value="main">Main Exercise</option>
                            <option value="warmup">Warm-up</option>
                            <option value="cooldown">Cool-down</option>
                        </select>
                    </div>

                    <!-- Difficulty Level -->
                    <div class="form-group">
                        <label for="exercise-difficulty">Difficulty:</label>
                        <select id="exercise-difficulty">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="advanced">Advanced</option>
                        </select>
                    </div>

                    <!-- Muscle Groups -->
                    <div class="form-group">
                        <label for="exercise-muscle-groups">Muscle Groups (comma-separated):</label>
                        <input type="text" id="exercise-muscle-groups" placeholder="chest, shoulders, triceps">
                        <small>Primary muscle groups targeted by this exercise</small>
                    </div>

                    <!-- Equipment Required -->
                    <div class="form-group">
                        <label for="exercise-equipment">Equipment Required (comma-separated):</label>
                        <input type="text" id="exercise-equipment" placeholder="barbell, weight-bench, weight-plates">
                        <small>Equipment needed to perform this exercise</small>
                    </div>

                    <!-- Alternative Equipment -->
                    <div class="form-group">
                        <label for="exercise-alternative-equipment">Alternative Equipment (comma-separated):</label>
                        <input type="text" id="exercise-alternative-equipment" placeholder="dumbbells, smith-machine">
                        <small>Alternative equipment that can be used</small>
                    </div>

                    <!-- Instructions -->
                    <div class="form-group">
                        <label for="exercise-instructions">Instructions (one per line):</label>
                        <textarea id="exercise-instructions" placeholder="1. Set up on the bench with your eyes under the barbell&#10;2. Grip the bar with hands slightly wider than shoulder-width&#10;3. Lower the bar slowly to your chest..." rows="8"></textarea>
                        <small>Step-by-step instructions for performing the exercise</small>
                    </div>

                    <!-- Exercise Settings -->
                    <div class="form-group">
                        <label for="exercise-measurement-type">Measurement Type:</label>
                        <select id="exercise-measurement-type">
                            <option value="reps">Reps</option>
                            <option value="time">Time (seconds)</option>
                            <option value="distance">Distance</option>
                        </select>
                    </div>

                    <div class="form-group" style="display: flex; gap: 15px;">
                        <div style="flex: 1;">
                            <label for="exercise-recommended-sets">Recommended Sets:</label>
                            <input type="number" id="exercise-recommended-sets" min="1" max="10" value="3">
                        </div>
                        <div style="flex: 1;">
                            <label for="exercise-recommended-reps">Recommended Reps:</label>
                            <input type="number" id="exercise-recommended-reps" min="1" max="100" value="10">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="exercise-duration">Estimated Duration (minutes):</label>
                        <input type="number" id="exercise-duration" min="1" max="60" value="8">
                    </div>

                    <!-- Media Reference -->
                    <div class="form-group">
                        <label for="exercise-avatar">Avatar/Demo Media DID:</label>
                        <input type="text" id="exercise-avatar" placeholder="did:gun:media:... or did:gun:YOUR_SOUL_HASH:...">
                        <small>Reference to a media record (GIF, video) demonstrating the exercise</small>
                    </div>

                    <!-- Exercise Flags -->
                    <div class="form-group">
                        <label>Exercise Properties:</label>
                        <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 15px;">
                            <label><input type="checkbox" id="exercise-bodyweight"> Bodyweight Exercise</label>
                        </div>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="exercise-tags">Tags:</label>
                        <input type="text" id="exercise-tags" placeholder="chest, strength, compound, barbell">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishExercise()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏋️ Publish Exercise
                    </button>
                </div>
            `;
        }

        function createFitnessEquipmentInterface() {
            return `
                <div class="publish-form">
                    <h3>🏋️‍♀️ Fitness Equipment Publishing</h3>
                    
                    <!-- Equipment Basic Info -->
                    <div class="form-group">
                        <label for="equipment-name">Equipment Name:</label>
                        <input type="text" id="equipment-name" required placeholder="e.g., Dumbbells">
                    </div>

                    <div class="form-group">
                        <label for="equipment-description">Description:</label>
                        <textarea id="equipment-description" placeholder="Brief description of the equipment..." rows="3"></textarea>
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="equipment-language">Language:</label>
                        <select id="equipment-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Equipment Avatar (DID reference) -->
                    <div class="form-group">
                        <label for="equipment-avatar">Equipment Image DID:</label>
                        <input type="text" id="equipment-avatar" placeholder="did:gun:media:... or did:arweave:...">
                        <small>Reference to a media record showing the equipment</small>
                    </div>

                    <!-- Equipment Category -->
                    <div class="form-group">
                        <label for="equipment-category">Category:</label>
                        <select id="equipment-category">
                            <option value="weights">Weights</option>
                            <option value="cardio">Cardio</option>
                            <option value="bodyweight">Bodyweight</option>
                            <option value="flexibility">Flexibility</option>
                            <option value="functional">Functional</option>
                            <option value="accessories">Accessories</option>
                        </select>
                    </div>

                    <!-- Equipment Subcategory -->
                    <div class="form-group">
                        <label for="equipment-subcategory">Subcategory:</label>
                        <input type="text" id="equipment-subcategory" placeholder="e.g., Free Weights, Resistance Bands">
                    </div>

                    <!-- Muscle Groups -->
                    <div class="form-group">
                        <label for="equipment-muscle-groups">Muscle Groups (comma-separated):</label>
                        <input type="text" id="equipment-muscle-groups" placeholder="chest, back, shoulders, arms, legs">
                        <small>Muscle groups this equipment can target</small>
                    </div>

                    <!-- Exercise Types -->
                    <div class="form-group">
                        <label for="equipment-exercise-types">Exercise Types (comma-separated):</label>
                        <input type="text" id="equipment-exercise-types" placeholder="strength, functional, rehabilitation">
                        <small>Types of exercises this equipment supports</small>
                    </div>

                    <!-- Equipment Properties -->
                    <div class="form-group">
                        <label for="equipment-difficulty">Difficulty Level:</label>
                        <select id="equipment-difficulty">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="advanced">Advanced</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-space-required">Space Required:</label>
                        <select id="equipment-space-required">
                            <option value="minimal">Minimal Space</option>
                            <option value="small">Small Space</option>
                            <option value="medium">Medium Space</option>
                            <option value="large">Large Space</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-portability">Portability:</label>
                        <select id="equipment-portability">
                            <option value="portable">Portable</option>
                            <option value="semi_portable">Semi-Portable</option>
                            <option value="stationary">Stationary</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-price-range">Price Range:</label>
                        <select id="equipment-price-range">
                            <option value="budget">Budget ($0-50)</option>
                            <option value="mid_range">Mid-Range ($50-200)</option>
                            <option value="premium">Premium ($200-500)</option>
                            <option value="professional">Professional ($500+)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-maintenance">Maintenance Level:</label>
                        <select id="equipment-maintenance">
                            <option value="none">No Maintenance</option>
                            <option value="low">Low Maintenance</option>
                            <option value="medium">Medium Maintenance</option>
                            <option value="high">High Maintenance</option>
                        </select>
                    </div>

                    <!-- Alternatives -->
                    <div class="form-group">
                        <label for="equipment-alternatives">Alternatives (comma-separated):</label>
                        <input type="text" id="equipment-alternatives" placeholder="Resistance bands, Kettlebells, Cable machine">
                        <small>Alternative equipment that can provide similar benefits</small>
                    </div>

                    <!-- Safety -->
                    <div class="form-group">
                        <label for="equipment-safety">Safety Considerations:</label>
                        <textarea id="equipment-safety" placeholder="Safety tips and considerations for using this equipment..." rows="3"></textarea>
                    </div>

                    <!-- Equipment Flags -->
                    <div class="form-group">
                        <label>Equipment Properties:</label>
                        <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 15px;">
                            <label><input type="checkbox" id="equipment-beginner-friendly"> Beginner Friendly</label>
                            <label><input type="checkbox" id="equipment-home-gym"> Home Gym Suitable</label>
                            <label><input type="checkbox" id="equipment-commercial"> Commercial Grade</label>
                        </div>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="equipment-access-level">Access Level:</label>
                        <select id="equipment-access-level" onchange="updateEquipmentAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this equipment record</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="equipment-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="equipment-organization">Select Organization:</label>
                        <select id="equipment-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this equipment belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="equipment-tags">Tags:</label>
                        <input type="text" id="equipment-tags" placeholder="weights, dumbbells, beginner, home-gym">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishFitnessEquipment()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏋️‍♀️ Publish Equipment
                    </button>
                </div>
            `;
        }

        function createMediaInterface() {
            return `
                <div class="publish-form">
                    <h3>📁 Media File Publishing</h3>
                    
                    <div class="info-box" style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>🌐 BitTorrent + OIP Media Distribution</h4>
                        <p>Upload media files that will be:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>📋 <strong>Formatted as proper OIP records</strong> (image/video/audio types)</li>
                            <li>🔒 <strong>Stored with HD wallet ownership</strong> and access control</li>
                            <li>🌍 <strong>Distributed via BitTorrent</strong> for peer-to-peer sharing</li>
                            <li>⚡ <strong>Streamable via HTTP</strong> with range request support</li>
                            <li>🔍 <strong>Indexed in Elasticsearch</strong> for search and discovery</li>
                        </ul>
                        <p><strong>Note:</strong> Record type (image/video/audio) is automatically determined by file type.</p>
                    </div>

                    <!-- File Upload -->
                    <div class="form-group">
                        <label for="media-file">Select Media File:</label>
                        <input type="file" id="media-file" accept="image/*,video/*,audio/*" required onchange="updateMediaFilePreview()">
                        <small>Supported: Images (JPG, PNG, GIF, WebP), Videos (MP4, WebM, AVI), Audio (MP3, WAV, OGG, FLAC)</small>
                    </div>

                    <!-- Detected File Type Display -->
                    <div id="detected-file-type" class="form-group hidden" style="background: #f0f4ff; padding: 10px; border-radius: 6px; border: 1px solid #c7d2fe;">
                        <label>Detected Record Type:</label>
                        <div id="detected-type-display" style="font-weight: bold; color: #3730a3;"></div>
                        <small id="detected-type-description"></small>
                    </div>

                    <!-- Media Basic Info -->
                    <div class="form-group">
                        <label for="media-name">Media Title:</label>
                        <input type="text" id="media-name" placeholder="Descriptive title for the media file">
                        <small>If empty, will use the original filename</small>
                    </div>

                    <div class="form-group">
                        <label for="media-description">Description:</label>
                        <textarea id="media-description" placeholder="Brief description of the media content..." rows="2"></textarea>
                    </div>

                    <!-- Language Selection -->
                    <div class="form-group">
                        <label for="media-language">Language:</label>
                        <select id="media-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="media-access-level">Access Level:</label>
                        <select id="media-access-level" onchange="updateMediaAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this media file</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="media-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="media-organization">Select Organization:</label>
                        <select id="media-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this media belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="media-tags">Tags:</label>
                        <input type="text" id="media-tags" placeholder="tag1, tag2, tag3">
                        <small>Comma-separated tags for categorization</small>
                    </div>

                    <!-- NSFW Toggle -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="media-nsfw"> NSFW Content
                        </label>
                    </div>

                    <!-- Upload Progress -->
                    <div id="media-upload-progress" class="upload-progress hidden" style="margin: 15px 0;">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text">Ready to upload...</div>
                    </div>

                    <!-- Media Preview -->
                    <div id="media-preview" class="media-preview hidden" style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                        <h4>Media Preview:</h4>
                        <div id="media-preview-content"></div>
                        <div id="media-info" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                    </div>

                    <button onclick="publishMedia()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📁 Upload & Publish Media
                    </button>
                </div>
            `;
        }

        function createMultiResolutionGifInterface() {
            return `
                <div class="publish-form">
                    <h3>🎬 Multi-Resolution GIF Collection</h3>
                    
                    <div class="info-box" style="background: #fff3e0; border: 1px solid #ff9800; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>📚 Exercise Demo Collections</h4>
                        <p>Create a collection of GIF files at different resolutions for exercise demonstrations. Perfect for:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>🎯 <strong>Exercise tutorials</strong> with multiple quality options</li>
                            <li>📱 <strong>Adaptive streaming</strong> based on device/connection</li>
                            <li>💾 <strong>Storage optimization</strong> with resolution choices</li>
                        </ul>
                        <p><strong>Note:</strong> You must first upload individual GIF files as media records, then reference them here.</p>
                    </div>

                    <!-- Collection Basic Info -->
                    <div class="form-group">
                        <label for="gif-collection-name">Collection Name:</label>
                        <input type="text" id="gif-collection-name" required placeholder="e.g., Barbell Bench Press GIF Collection">
                    </div>

                    <div class="form-group">
                        <label for="gif-collection-description">Description:</label>
                        <textarea id="gif-collection-description" placeholder="Multi-resolution GIF demonstration set for..." rows="2"></textarea>
                    </div>

                    <!-- Input Method Selection -->
                    <div class="form-group">
                        <label for="gif-input-method">Input Method:</label>
                        <select id="gif-input-method" onchange="updateGifInputMethod()">
                            <option value="upload">Upload GIF Files</option>
                            <option value="manual">Manual DID Entry</option>
                        </select>
                        <small>Choose whether to upload files or enter existing media DIDs</small>
                    </div>

                    <!-- File Upload Interface -->
                    <div id="gif-upload-interface" class="form-group">
                        <label>GIF Files (Different Resolutions):</label>
                        <div id="gif-files-container">
                            <div class="gif-file-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 40px; gap: 10px; margin-bottom: 10px; align-items: end; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fafafa;">
                                <div>
                                    <label>GIF File:</label>
                                    <input type="file" class="gif-file-input" accept="image/gif" onchange="updateGifFileInfo(this)">
                                </div>
                                <div>
                                    <label>Resolution Label:</label>
                                    <input type="text" class="gif-resolution-label" placeholder="180p">
                                </div>
                                <div>
                                    <label>Width (px):</label>
                                    <input type="number" class="gif-width" placeholder="320">
                                </div>
                                <div>
                                    <label>Height (px):</label>
                                    <input type="number" class="gif-height" placeholder="180">
                                </div>
                                <button type="button" onclick="addGifFileRow()" class="btn-small" title="Add another resolution">+</button>
                            </div>
                        </div>
                        <button type="button" onclick="addGifFileRow()" style="margin-top: 10px;">+ Add Another Resolution</button>
                        <small>Upload GIF files at different resolutions. Dimensions will be auto-detected.</small>
                    </div>

                    <!-- Manual DID Interface -->
                    <div id="gif-manual-interface" class="form-group hidden">
                        <label>GIF Media References:</label>
                        <div id="gif-refs-container">
                            <div class="gif-ref-row" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: end;">
                                <div style="flex: 2;">
                                    <label>Media DID:</label>
                                    <input type="text" class="gif-media-did" placeholder="did:gun:media:...">
                                </div>
                                <div style="flex: 1;">
                                    <label>Resolution Label:</label>
                                    <input type="text" class="gif-resolution-label" placeholder="180p">
                                </div>
                                <div style="flex: 1;">
                                    <label>Width (px):</label>
                                    <input type="number" class="gif-width" placeholder="320">
                                </div>
                                <div style="flex: 1;">
                                    <label>Height (px):</label>
                                    <input type="number" class="gif-height" placeholder="180">
                                </div>
                                <button type="button" onclick="addGifReference()" class="btn-small">+</button>
                            </div>
                        </div>
                        <small>Add references to uploaded GIF media files at different resolutions</small>
                    </div>

                    <!-- Animation Settings -->
                    <div class="form-group" style="display: flex; gap: 15px;">
                        <div style="flex: 1;">
                            <label for="gif-frame-rate">Frame Rate (fps):</label>
                            <input type="number" id="gif-frame-rate" min="1" max="60" value="15">
                        </div>
                        <div style="flex: 1;">
                            <label for="gif-duration">Duration (seconds):</label>
                            <input type="number" id="gif-duration" step="0.1" min="0.1" value="8.5">
                        </div>
                        <div style="flex: 1;">
                            <label for="gif-loop-count">Loop Count:</label>
                            <input type="number" id="gif-loop-count" min="0" value="0">
                            <small>0 = infinite</small>
                        </div>
                    </div>

                    <!-- Primary Resolution -->
                    <div class="form-group">
                        <label for="gif-primary-index">Primary Resolution Index:</label>
                        <select id="gif-primary-index">
                            <option value="0">First (0)</option>
                            <option value="1" selected>Second (1)</option>
                            <option value="2">Third (2)</option>
                            <option value="3">Fourth (3)</option>
                        </select>
                        <small>Which resolution to use as the default/primary</small>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="gif-access-level">Access Level:</label>
                        <select id="gif-access-level" onchange="updateGifAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this GIF collection</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="gif-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="gif-organization">Select Organization:</label>
                        <select id="gif-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this GIF collection belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="gif-tags">Tags:</label>
                        <input type="text" id="gif-tags" placeholder="exercise-demo, multi-resolution, barbell-bench-press">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishMultiResolutionGif()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="gif-publish-text">🎬 Publish GIF Collection</span>
                    </button>
                </div>
            `;
        }

        // Master Audio Player functions
        let currentAudioUrl = null;
        let currentAudioTitle = null;
        let currentAudioType = null;
        let currentPlayingIndex = null;

        function playAudioInMaster(audioUrl, title, recordType, recordIndex) {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            const audioTitle = document.getElementById('audio-title');
            const audioMeta = document.getElementById('audio-meta');
            const playBtn = document.getElementById('master-play-btn');
            
            // Update all audio buttons
            document.querySelectorAll('.audio-play-btn').forEach(btn => {
                btn.classList.remove('playing');
                btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
            });
            
            // If same audio is playing, toggle it
            if (currentAudioUrl === audioUrl && !masterAudio.paused) {
                masterAudio.pause();
                return;
            }
            
            // Set new audio
            currentAudioUrl = audioUrl;
            currentAudioTitle = title;
            currentAudioType = recordType;
            currentPlayingIndex = recordIndex;
            
            masterAudio.src = audioUrl;
            
            // Enhanced display for podcast episodes
            if (recordType === 'podcast' && currentRecords[recordIndex]?.data?.podcast?.show) {
                const podcastShow = currentRecords[recordIndex].data.podcast.show;
                audioTitle.textContent = title;
                audioMeta.textContent = `🎙️ ${podcastShow} • Loading...`;
            } else {
                audioTitle.textContent = title;
                audioMeta.textContent = `${recordType} • Loading...`;
            }
            
            // Show master player
            masterPlayer.classList.add('visible');
            
            // Update button states
            const currentBtn = document.getElementById(`audioBtn-${recordIndex}`);
            if (currentBtn) {
                currentBtn.classList.add('playing');
                if (recordType === 'podcast') {
                    currentBtn.innerHTML = '<span>⏸️</span><span>Playing Episode...</span>';
                } else {
                    currentBtn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                }
            }
            
            // Play audio
            masterAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                if (recordType === 'podcast') {
                    audioMeta.textContent = `🎙️ ${currentRecords[recordIndex]?.data?.podcast?.show || 'Podcast'} • Error loading episode`;
                } else {
                    audioMeta.textContent = `${recordType} • Error loading audio`;
                }
            });
            
            playBtn.textContent = '⏸️';
        }

        function toggleAudioPlayback() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            
            if (masterAudio.paused) {
                masterAudio.play();
                playBtn.textContent = '⏸️';
                updateCurrentPlayingButton(true);
            } else {
                masterAudio.pause();
                playBtn.textContent = '▶️';
                updateCurrentPlayingButton(false);
            }
        }

        function stopAudio() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            masterAudio.pause();
            masterAudio.currentTime = 0;
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Stopped`;
            updateCurrentPlayingButton(false);
        }

        function closeMasterPlayer() {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            
            masterAudio.pause();
            masterPlayer.classList.remove('visible');
            updateCurrentPlayingButton(false);
            
            currentAudioUrl = null;
            currentAudioTitle = null;
            currentAudioType = null;
            currentPlayingIndex = null;
        }

        function updateCurrentPlayingButton(isPlaying) {
            if (currentPlayingIndex !== null) {
                const btn = document.getElementById(`audioBtn-${currentPlayingIndex}`);
                if (btn) {
                    if (isPlaying) {
                        btn.classList.add('playing');
                        if (currentAudioType === 'podcast') {
                            btn.innerHTML = '<span>⏸️</span><span>Playing Episode...</span>';
                        } else {
                            btn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                        }
                    } else {
                        btn.classList.remove('playing');
                        if (currentAudioType === 'podcast') {
                            btn.innerHTML = '<span>🎙️</span><span>Play Episode</span>';
                        } else {
                            btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
                        }
                    }
                }
            }
        }

        function updateAudioProgress() {
            const masterAudio = document.getElementById('master-audio');
            const progressBar = document.getElementById('audio-progress-bar');
            const timeDisplay = document.getElementById('audio-time');
            
            if (masterAudio.duration) {
                const progress = (masterAudio.currentTime / masterAudio.duration) * 100;
                progressBar.style.width = progress + '%';
                
                const currentTime = formatTime(masterAudio.currentTime);
                const totalTime = formatTime(masterAudio.duration);
                timeDisplay.textContent = `${currentTime} / ${totalTime}`;
            }
        }

        function seekAudio(event) {
            const masterAudio = document.getElementById('master-audio');
            const progressContainer = event.currentTarget;
            const rect = progressContainer.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            
            if (masterAudio.duration) {
                masterAudio.currentTime = percent * masterAudio.duration;
            }
        }

        function onAudioLoaded() {
            const audioMeta = document.getElementById('audio-meta');
            const masterAudio = document.getElementById('master-audio');
            
            if (masterAudio.duration) {
                const duration = formatTime(masterAudio.duration);
                
                if (currentAudioType === 'podcast' && currentPlayingIndex !== null && currentRecords[currentPlayingIndex]?.data?.podcast?.show) {
                    const podcastShow = currentRecords[currentPlayingIndex].data.podcast.show;
                    audioMeta.textContent = `🎙️ ${podcastShow} • Duration: ${duration}`;
                } else {
                    audioMeta.textContent = `${currentAudioType} • Duration: ${duration}`;
                }
            }
        }

        function onAudioEnded() {
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            playBtn.textContent = '▶️';
            
            if (currentAudioType === 'podcast' && currentPlayingIndex !== null && currentRecords[currentPlayingIndex]?.data?.podcast?.show) {
                const podcastShow = currentRecords[currentPlayingIndex].data.podcast.show;
                audioMeta.textContent = `🎙️ ${podcastShow} • Episode Finished`;
            } else {
                audioMeta.textContent = `${currentAudioType} • Finished`;
            }
            
            updateCurrentPlayingButton(false);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // AI Chat State Management
        let chatState = {
            isInitialized: false,
            isProcessing: false,
            conversation: [],
            selectedModel: 'llama3.2:3b',
            selectedLanguage: 'auto',
            lastQuery: '',
            appliedFilters: {},
            // Follow-up question tracking
            lastSearchResults: [],
            lastSearchSubject: '',
            lastSearchKeywords: [],
            // Voice recording state
            isRecording: false,
            isTranscribing: false,
            isListening: false,
            mediaStream: null,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            vadInterval: null,
            silenceTimeout: null,
            lastSpeechTime: 0
        };

        // Voice variables removed - now using unified enhanced system with currentFilters, currentRecords, etc.

        // AI Chat Feature Initialization
        async function initializeVoiceFeatures() {
            if (chatState.isInitialized) return Promise.resolve();
            
            console.log('[Chat] Initializing AI chat features...');
            updateAIStatus('Initializing...');
            
            try {
                // Initialize multi-tag filtering system
                clearAllTagFilters();
                
                // Initialize view mode
                document.getElementById('voice-view-as').value = currentViewMode;
                
                // Initialize voice system
                await loadVoiceSettings();
                
                updateAIStatus('Ready to answer questions!');
                
                chatState.isInitialized = true;
                
                // Load initial records for voice tab
                await loadVoiceRecords(true);
                
                console.log('[Chat] AI chat features initialized successfully with multi-tag system and view modes');
                
                return Promise.resolve();
                
            } catch (error) {
                console.error('[Chat] Initialization failed:', error);
                updateAIStatus('AI chat unavailable');
                return Promise.reject(error);
            }
        }


        // Voice Engine Configuration (based on working index.html)
        const voiceConfig = {
            enabled: true,
            selectedEngine: 'edge_tts',
            baseUrl: window.location.origin,
            // Chatterbox-specific settings
            chatterbox: {
                selectedVoice: 'female_expressive',
                exaggeration: 0.5,       // 50% emotion for balanced speech
                cfg_weight: 0.5,         // Balanced pacing
                voiceCloning: {
                    enabled: false,
                    audioFile: null,
                    fileName: null
                }
            },
            // Edge TTS-specific settings
            edge: {
                selectedVoice: 'en-GB-RyanNeural',
                speed: 1.0,              // Normal speed
                pitch: 0,                // No pitch adjustment
                volume: 0                // No volume adjustment
            },
            // ElevenLabs-specific settings
            elevenlabs: {
                selectedVoice: 'onwK4e9ZLuTAKqWW03F9',  // Daniel voice ID
                model_id: 'eleven_turbo_v2',           // Fast turbo model
                stability: 0.5,                        // Balanced stability
                similarity_boost: 0.75,                // Good similarity
                style: 0.0,                           // Neutral style
                use_speaker_boost: true               // Enhanced clarity
            }
        };
        
        // Available voices for each engine (loaded dynamically)
        let availableVoices = {
            chatterbox: [],
            edge_tts: [],
            elevenlabs: []
        };

        // Switch between voice engines
        async function switchVoiceEngine() {
            const selectedEngine = document.getElementById('voice-engine').value;
            voiceConfig.selectedEngine = selectedEngine;
            
            console.log(`🔄 Switching to engine: ${selectedEngine}`);
            
            // Update UI visibility
            if (selectedEngine === 'chatterbox') {
                document.getElementById('chatterbox-controls').style.display = 'block';
                document.getElementById('edge-controls').style.display = 'none';
                document.getElementById('elevenlabs-controls').style.display = 'none';
                document.getElementById('tts-enable-label').textContent = 'Enable Chatterbox TTS';
            } else if (selectedEngine === 'edge_tts') {
                document.getElementById('chatterbox-controls').style.display = 'none';
                document.getElementById('edge-controls').style.display = 'block';
                document.getElementById('elevenlabs-controls').style.display = 'none';
                document.getElementById('tts-enable-label').textContent = 'Enable Edge TTS';
            } else if (selectedEngine === 'elevenlabs') {
                document.getElementById('chatterbox-controls').style.display = 'none';
                document.getElementById('edge-controls').style.display = 'none';
                document.getElementById('elevenlabs-controls').style.display = 'block';
                document.getElementById('tts-enable-label').textContent = 'Enable ElevenLabs TTS';
            }
            
            // Load voices for selected engine
            await populateVoiceDropdown(selectedEngine);
            updateAIStatus(`🔄 Switched to ${selectedEngine === 'chatterbox' ? 'Chatterbox TTS' : selectedEngine === 'edge_tts' ? 'Edge TTS' : 'ElevenLabs'}`);
        }

        // Load available voices from API
        async function loadAvailableVoices() {
            try {
                // Load all voices from the single voices endpoint
                const response = await fetch('/api/alfred/voices');
                if (response.ok) {
                    const data = await response.json();
                    const voices = data.voices || [];
                    
                    // Separate voices by engine (case-insensitive)
                    availableVoices.chatterbox = voices.filter(v => 
                        v.engine && (v.engine.toLowerCase() === 'chatterbox' || v.engine.toLowerCase() === 'chatterbox tts')
                    );
                    availableVoices.edge_tts = voices.filter(v => 
                        v.engine && (v.engine.toLowerCase() === 'edge tts' || v.engine.toLowerCase() === 'edge_tts')
                    );
                    
                    // Add ElevenLabs voices (hardcoded popular ones)
                    availableVoices.elevenlabs = [
                        { id: 'pNInz6obpgDQGcFmaJgB', name: 'Adam (Male, Deep)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'EXAVITQu4vr4xnSDxMaL', name: 'Bella (Female, Sweet)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'VR6AewLTigWG4xSOukaG', name: 'Arnold (Male, Crisp)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'pMsXgVXv3BLzUgSXRplE', name: 'Freya (Female, Conversational)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'onwK4e9ZLuTAKqWW03F9', name: 'Daniel (Male, British)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'CYw3kZ02Hs0563khs1Fj', name: 'Gigi (Female, Childlike)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'bVMeCyTHy58xNoL34h3p', name: 'Jeremy (Male, American)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'XB0fDUnXU5powFXDhCwa', name: 'Charlotte (Female, Seductive)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'JBFqnCBsd6RMkjVDRZzb', name: 'George (Male, Raspy)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'oWAxZDx7w5VEj9dCyTzz', name: 'Grace (Female, Calm)', gender: 'female', engine: 'elevenlabs' }
                    ];
                    
                    console.log(`🎵 Loaded ${availableVoices.chatterbox.length} Chatterbox voices, ${availableVoices.edge_tts.length} Edge TTS voices, and ${availableVoices.elevenlabs.length} ElevenLabs voices`);
                    
                    // Populate dropdown for default engine
                    await populateVoiceDropdown(voiceConfig.selectedEngine);
                } else {
                    console.error('Failed to load voices:', response.status, await response.text());
                    updateAIStatus('⚠️ Failed to load voice options');
                }
                
            } catch (error) {
                console.error('Failed to load voices:', error);
                updateAIStatus('⚠️ Failed to load voice options');
            }
        }
        
        // Populate voice dropdown based on selected engine
        async function populateVoiceDropdown(engine) {
            const voiceSelect = document.getElementById('voice-select');
            voiceSelect.innerHTML = ''; // Clear existing options
            
            const voices = availableVoices[engine] || [];
            
            if (voices.length === 0) {
                voiceSelect.innerHTML = '<option value="">No voices available</option>';
                return;
            }
            
            // Group voices by gender for better organization
            const groupedVoices = {
                female: voices.filter(v => v.gender === 'female'),
                male: voices.filter(v => v.gender === 'male'),
                other: voices.filter(v => !['female', 'male'].includes(v.gender))
            };
            
            // Add female voices
            if (groupedVoices.female.length > 0) {
                const femaleGroup = document.createElement('optgroup');
                femaleGroup.label = 'Female Voices';
                groupedVoices.female.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    femaleGroup.appendChild(option);
                });
                voiceSelect.appendChild(femaleGroup);
            }
            
            // Add male voices
            if (groupedVoices.male.length > 0) {
                const maleGroup = document.createElement('optgroup');
                maleGroup.label = 'Male Voices';
                groupedVoices.male.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    maleGroup.appendChild(option);
                });
                voiceSelect.appendChild(maleGroup);
            }
            
            // Add other voices
            if (groupedVoices.other.length > 0) {
                const otherGroup = document.createElement('optgroup');
                otherGroup.label = 'Other Voices';
                groupedVoices.other.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    otherGroup.appendChild(option);
                });
                voiceSelect.appendChild(otherGroup);
            }
            
            // Set default selection
            if (engine === 'chatterbox') {
                const defaultVoice = voices.find(v => v.id === 'female_expressive') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.chatterbox.selectedVoice = defaultVoice.id;
                }
            } else if (engine === 'edge_tts') {
                const defaultVoice = voices.find(v => v.id === 'en-US-AriaNeural') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.edge.selectedVoice = defaultVoice.id;
                }
            } else if (engine === 'elevenlabs') {
                const defaultVoice = voices.find(v => v.id === 'pNInz6obpgDQGcFmaJgB') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.elevenlabs.selectedVoice = defaultVoice.id;
                }
            }
            
            console.log(`🎵 Populated ${voices.length} voices for ${engine}`);
        }

        // Handle voice selection change
        function updateVoiceSelection() {
            const selectedVoice = document.getElementById('voice-select').value;
            const engine = voiceConfig.selectedEngine;
            
            if (engine === 'chatterbox') {
                voiceConfig.chatterbox.selectedVoice = selectedVoice;
            } else if (engine === 'edge_tts') {
                voiceConfig.edge.selectedVoice = selectedVoice;
            } else if (engine === 'elevenlabs') {
                voiceConfig.elevenlabs.selectedVoice = selectedVoice;
            }
            
            console.log(`🎵 Selected voice: ${selectedVoice} for engine: ${engine}`);
        }

        // Chatterbox controls
        function updateEmotion(value) {
            voiceConfig.chatterbox.exaggeration = value / 100;
            document.getElementById('emotion-value').textContent = value + '%';
        }

        function updatePacing(value) {
            voiceConfig.chatterbox.cfg_weight = value / 100;
            document.getElementById('pacing-value').textContent = value + '%';
        }

        // Edge TTS controls
        function updateSpeed(value) {
            voiceConfig.edge.speed = value / 100;
            document.getElementById('speed-value').textContent = value + '%';
        }
        
        function updatePitch(value) {
            voiceConfig.edge.pitch = parseInt(value);
            document.getElementById('pitch-value').textContent = value + 'Hz';
        }
        
        function updateVolume(value) {
            voiceConfig.edge.volume = parseInt(value);
            document.getElementById('volume-value').textContent = value + '%';
        }

        // ElevenLabs controls
        function updateStability(value) {
            voiceConfig.elevenlabs.stability = value / 100;
            document.getElementById('stability-value').textContent = value + '%';
        }
        
        function updateSimilarity(value) {
            voiceConfig.elevenlabs.similarity_boost = value / 100;
            document.getElementById('similarity-value').textContent = value + '%';
        }
        
        function updateStyle(value) {
            voiceConfig.elevenlabs.style = value / 100;
            document.getElementById('style-value').textContent = value + '%';
        }
        
        function updateModel(value) {
            voiceConfig.elevenlabs.model_id = value;
        }

        // Toggle TTS enabled/disabled
        function toggleTTSEnabled() {
            const checkbox = document.getElementById('tts-enabled');
            voiceConfig.enabled = checkbox.checked;
            const engineName = voiceConfig.selectedEngine === 'chatterbox' ? 'Chatterbox TTS' : 
                             voiceConfig.selectedEngine === 'edge_tts' ? 'Edge TTS' : 'ElevenLabs';
            updateAIStatus(voiceConfig.enabled ? `${engineName} Enabled` : 'TTS Disabled');
        }

        // Universal voice synthesis function (handles all engines)
        async function synthesizeResponseWithChatterbox(text) {
            if (!voiceConfig.enabled) {
                console.log('Voice synthesis disabled, skipping');
                return;
            }

            const engine = voiceConfig.selectedEngine;
            
            try {
                if (engine === 'chatterbox') {
                    await synthesizeWithChatterbox(text);
                } else if (engine === 'edge_tts') {
                    await synthesizeWithEdge(text);
                } else if (engine === 'elevenlabs') {
                    await synthesizeWithElevenLabs(text);
                } else {
                    throw new Error(`Unknown engine: ${engine}`);
                }
            } catch (error) {
                console.error(`Voice synthesis failed with ${engine}:`, error);
                
                // Try fallback to Chatterbox if the primary engine fails
                if (engine !== 'chatterbox') {
                    console.log(`[TTS] Falling back to Chatterbox TTS...`);
                    updateAIStatus('🔄 Falling back to Chatterbox TTS...');
                    try {
                        await synthesizeWithChatterbox(text);
                        return; // Successfully fell back
                    } catch (fallbackError) {
                        console.error('[TTS] Chatterbox fallback also failed:', fallbackError);
                        updateAIStatus('❌ All TTS engines failed');
                    }
                } else {
                    updateAIStatus(`❌ ${engine} synthesis failed`);
                }
            }
        }

        // Synthesize with Chatterbox TTS
        async function synthesizeWithChatterbox(text) {
            try {
                updateAIStatus('🎭 Synthesizing with Chatterbox TTS...');
                
                const formData = new FormData();
                formData.append('text', text);
                formData.append('voice_id', voiceConfig.chatterbox.selectedVoice);
                formData.append('exaggeration', voiceConfig.chatterbox.exaggeration.toString());
                formData.append('cfg_weight', voiceConfig.chatterbox.cfg_weight.toString());
                formData.append('engine', 'chatterbox');

                const response = await fetch('/api/alfred/synthesize', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('Chatterbox synthesis failed:', error);
                throw error;
            }
        }

        // Synthesize with Edge TTS
        async function synthesizeWithEdge(text) {
            try {
                updateAIStatus('⚡ Synthesizing with Edge TTS...');
                
                const formData = new FormData();
                formData.append('text', text);
                formData.append('voice_id', voiceConfig.edge.selectedVoice);
                formData.append('speed', voiceConfig.edge.speed.toString());
                formData.append('engine', 'edge_tts');
                
                // Add exaggeration and cfg_weight for compatibility (Edge will convert these to pitch/volume)
                formData.append('exaggeration', (voiceConfig.edge.pitch / 10 + 0.5).toString());
                formData.append('cfg_weight', (voiceConfig.edge.volume / 20 + 0.5).toString());

                const response = await fetch('/api/alfred/synthesize', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('Edge TTS synthesis failed:', error);
                throw error;
            }
        }

        // Synthesize with ElevenLabs
        async function synthesizeWithElevenLabs(text) {
            try {
                updateAIStatus('🚀 Synthesizing with ElevenLabs...');
                
                const requestData = {
                    text: text,
                    voice_settings: {
                        stability: voiceConfig.elevenlabs.stability,
                        similarity_boost: voiceConfig.elevenlabs.similarity_boost,
                        style: voiceConfig.elevenlabs.style,
                        use_speaker_boost: voiceConfig.elevenlabs.use_speaker_boost
                    },
                    model_id: voiceConfig.elevenlabs.model_id
                };
                
                const response = await fetch(`/api/alfred/elevenlabs/${voiceConfig.elevenlabs.selectedVoice}/synthesize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('ElevenLabs synthesis failed:', error);
                throw error;
            }
        }

        // Helper function to play audio
        async function playAudio(audioBlob) {
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                updateAIStatus('Ready to answer questions!');
            };
            
            audio.onerror = (error) => {
                console.error('Audio playback failed:', error);
                URL.revokeObjectURL(audioUrl);
                updateAIStatus('Ready to answer questions!');
            };
            
            await audio.play();
            console.log('Audio synthesis and playback successful');
        }

        async function loadVoiceSettings() {
            try {
                console.log('🎵 Initializing voice system...');
                
                // Load available voices
                await loadAvailableVoices();
                
                // Initialize voice controls
                await switchVoiceEngine();
                
                console.log('🎵 Voice system initialized successfully');
                
            } catch (error) {
                console.error('🎵 Failed to initialize voice system:', error);
                updateAIStatus('⚠️ Voice system initialization failed');
            }
        }

        // Legacy function removed - replaced by comprehensive voice engine system

        // DEPRECATED: loadVoiceRecordTypes() - now handled by loadActualRecordTypes() in main app init
        // async function loadVoiceRecordTypes() { ... }

        // DEPRECATED: populateVoiceRecordTypeFilter() - now handled by populateAllRecordTypeDropdowns()
        // function populateVoiceRecordTypeFilter(recordTypes) { ... }

        function updateAIStatus(main) {
            document.getElementById('ai-status-text').textContent = main;
        }

        // Chat Input Functions
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize textarea
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('ai-chat-input');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 200) + 'px';
                });
            }
        });

        async function sendChatMessage() {
            const input = document.getElementById('ai-chat-input');
            const question = input.value.trim();
            
            if (!question || chatState.isProcessing) {
                return;
            }
            
            // Clear input and disable send button temporarily
            input.value = '';
            input.style.height = '60px'; // Reset textarea height
            const sendBtn = document.getElementById('ai-chat-send-btn');
            sendBtn.disabled = true;
            
            try {
                // Add user message to conversation immediately
                addToConversation('user', question);
                
                // Update selected model and voice
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                await processTextWithAI(question);
            } catch (error) {
                console.error('[Chat] Error processing message:', error);
                updateAIStatus('Error occurred');
                addToConversation('system', `Error: ${error.message}`);
            } finally {
                // Re-enable send button and ensure input is ready
                sendBtn.disabled = false;
                ensureChatInputReady();
            }
        }

        // AI Processing Functions

        async function processTextWithAI(text) {
            try {
                updateAIStatus('Analyzing question...');
                chatState.isProcessing = true;
                
                // Determine if this is a follow-up question or new subject
                const isFollowUp = await detectFollowUpQuestion(text);
                
                if (isFollowUp && (chatState.lastSearchResults.length > 0 || (currentRecords && currentRecords.length === 1))) {
                    updateAIStatus('Processing follow-up with existing data...');
                    await processFollowUpQuestion(text);
                } else {
                    updateAIStatus('Searching for new information...');
                    await processNewQuestion(text);
                }
                
                updateAIStatus('Ready to answer questions!');
                
            } catch (error) {
                console.error('[Chat] AI processing error:', error);
                updateAIStatus('AI processing failed');
                addToConversation('system', `AI Error: ${error.message}`);
            } finally {
                chatState.isProcessing = false;
            }
        }

        async function detectFollowUpQuestion(text) {
            const lowerText = text.toLowerCase();
            
            // Special case: If we have exactly one record loaded, check for follow-up patterns
            if (currentRecords && currentRecords.length === 1) {
                console.log('[Chat] Single record context detected, analyzing for follow-up patterns');
                
                // Direct follow-up phrases
                const singleRecordFollowUpPatterns = [
                    /^(tell me more|give me more details|more info|more information|what else|anything else)/,
                    /^(how many calories|what about calories|calories|nutrition|nutritional info)/,
                    /^(how long|cook time|cooking time|prep time|preparation time)/,
                    /^(ingredients|what ingredients|recipe|instructions|how to make)/,
                    /^(servings|how many servings|serves how many)/,
                    /^(can you|could you|would you|will you).+(tell|give|show|explain)/,
                    /^(what about|how about|what's the|what is the)/,
                    /^(it|this|that|the recipe|the dish|the food)/,
                    /^(what does it|how does it|when does it|where does it)/,
                    /^(what is it|what's it|how is it|how's it)/
                ];
                
                if (singleRecordFollowUpPatterns.some(pattern => pattern.test(lowerText))) {
                    console.log('[Chat] Follow-up pattern detected for single record context');
                    return true;
                }
                
                // Check for questions with just attributes (likely follow-ups)
                const words = lowerText.split(/\s+/).filter(w => w.length > 2);
                const questionWords = ['what', 'how', 'when', 'where', 'why', 'which', 'who'];
                const attributeWords = ['calories', 'time', 'ingredients', 'servings', 'nutrition', 'cook', 'prep', 'difficulty'];
                
                const nonQuestionWords = words.filter(word => !questionWords.includes(word));
                const isAttributeQuery = nonQuestionWords.length > 0 && 
                                        nonQuestionWords.every(word => attributeWords.includes(word));
                
                if (isAttributeQuery) {
                    console.log('[Chat] Attribute-only question detected for single record context');
                    return true;
                }
            }
            
            // If no previous conversation, definitely not a follow-up (unless single record case above)
            if (chatState.conversation.length === 0 || !chatState.lastSearchSubject) {
                return false;
            }
            
            // Obvious new subject indicators
            const newSubjectPatterns = [
                /^(find|search|show|get|tell me about|what is|who is|where is|when is|how is)/,
                /recipe for/,
                /workout for/,
                /video about/,
                /image of/,
                /post about/,
                /information about/,
                /data on/
            ];
            
            if (newSubjectPatterns.some(pattern => pattern.test(lowerText))) {
                // Check if it mentions the same subject as before
                const lastSubjectWords = chatState.lastSearchSubject.toLowerCase().split(' ');
                const hasCommonSubject = lastSubjectWords.some(word => 
                    word.length > 3 && lowerText.includes(word)
                );
                
                if (!hasCommonSubject) {
                    return false; // Definitely new subject
                }
            }
            
            // Follow-up indicators
            const followUpPatterns = [
                /^(how many|how much|what about|what else|also|and|more|any other|tell me more)/,
                /^(where|when|why|who|which|whose)/,
                /(more|additional|other|else|further|next)/,
                /^(can you|could you|please)/
            ];
            
            if (followUpPatterns.some(pattern => pattern.test(lowerText))) {
                return true;
            }
            
            // Check for context continuity
            const lastSearchWords = chatState.lastSearchKeywords;
            if (lastSearchWords.length > 0) {
                const hasContextOverlap = lastSearchWords.some(keyword => 
                    lowerText.includes(keyword.toLowerCase())
                );
                
                if (hasContextOverlap) {
                    return true;
                }
            }
            
            return false;
        }

        async function processFollowUpQuestion(text) {
            console.log('[Chat] Processing follow-up question with existing data');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 20000);
            
            try {
                // Send the question with context and existing search results
                const response = await fetch('/api/alfred/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: false, // Don't perform new search
                        is_follow_up: true,
                        conversation_context: chatState.conversation.slice(-4), // Last 4 messages for context
                        existing_search_results: currentRecords && currentRecords.length === 1 ? currentRecords : chatState.lastSearchResults,
                        pinnedDidTx: (window.__alfredPinnedDid || '').trim() || undefined
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Follow-up processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] Follow-up Response:', aiData);
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: chatState.lastSearchResults,
                    searchResults: chatState.lastSearchResults.length,
                    isFollowUp: true
                });
                
                // Synthesize AI response with selected voice engine
                if (voiceConfig.enabled && aiData.response_text) {
                    await synthesizeResponseWithChatterbox(aiData.response_text);
                }
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                throw fetchError;
            }
        }

        /**
         * Check if any filters are currently active that would reduce the total record set
         */
        function hasActiveFilters() {
            return !!(
                currentFilters.search ||
                currentFilters.recordType ||
                currentFilters.dateStart ||
                currentFilters.dateEnd ||
                currentFilters.did ||
                currentFilters.didTx ||
                currentFilters.tags ||
                currentFilters.tag ||
                currentFilters.hasAudio ||
                currentFilters.aiTags
            );
        }

        async function processNewQuestion(text) {
            console.log('[Chat] Processing new question with fresh search');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 25000);
            
            try {
                // Determine if we should pass existing context based on active filters
                const filtersActive = hasActiveFilters();
                const shouldPassFullContext = filtersActive && currentRecords && currentRecords.length > 0 && currentRecords.length < 1000;
                const hasRecordTypeFilter = currentFilters.recordType && currentFilters.recordType.trim() !== '';
                
                console.log(`[Chat] Filters active: ${filtersActive}, Current records: ${currentRecords?.length || 0}, Record type: ${currentFilters.recordType || 'none'}`);
                console.log(`[Chat] Passing full context: ${shouldPassFullContext}, Has record type filter: ${hasRecordTypeFilter}`);
                
                // Build request body
                const requestBody = {
                    text: text,
                    model: chatState.selectedModel,
                    return_audio: false,
                    include_filter_analysis: true,
                    is_follow_up: false
                };
                
                // If a pinned DID is set, force single-record mode server-side
                if ((window.__alfredPinnedDid || '').trim()) {
                    requestBody.pinnedDidTx = window.__alfredPinnedDid.trim();
                    // In single-record mode, there is no need to pass existingContext/searchParams
                    requestBody.include_filter_analysis = false;
                }

                // Pass existing context if filters are active and we have a reasonable number of records
                if (shouldPassFullContext) {
                    // Pass first 10 records as context to avoid overwhelming the API
                    requestBody.existingContext = currentRecords.slice(0, 10);
                    console.log(`[Chat] Passing ${requestBody.existingContext.length} filtered records as existing context`);
                } else if (hasRecordTypeFilter) {
                    // Even if we can't pass full records, pass the record type for domain context
                    requestBody.searchParams = {
                        recordType: currentFilters.recordType
                    };
                    console.log(`[Chat] Passing record type context: ${currentFilters.recordType}`);
                }
                
                // Send to chat endpoint for new search
                const response = await fetch('/api/alfred/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 408 || response.status === 504) {
                        throw new Error('Request timeout - service may be busy, please try again');
                    }
                    throw new Error(`AI processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] New Question Response:', aiData);
                
                // Store search results and subject for future follow-ups
                chatState.lastSearchResults = aiData.search_results || [];
                chatState.lastSearchSubject = aiData.extracted_subject || text;
                chatState.lastSearchKeywords = aiData.extracted_keywords || [];
                
                // Use applied filters from backend (enhanced RAG service)
                const appliedFilters = aiData.applied_filters || {};
                
                console.log('[Chat] AI found search results:', aiData.search_results?.length || 0);
                console.log('[Chat] AI applied filters:', appliedFilters);
                
                // If AI found specific search results, display them directly
                if (aiData.search_results && aiData.search_results.length > 0) {
                    console.log('[Chat] 🎯 Displaying AI search results directly');
                    displayAISearchResults(aiData.search_results, appliedFilters);
                    // Update filters display but don't reload records (use AI results instead)
                    displayAppliedFilters(appliedFilters, aiData.sources);
                } else {
                    console.log('[Chat] 📋 No AI search results, using filter-based search');
                    // Apply the filters to the UI and reload records
                    await applyAIFilters(appliedFilters, aiData.sources);
                }
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: aiData.sources,
                    searchResults: aiData.search_results_count,
                    filtersApplied: appliedFilters,
                    isFollowUp: false
                });
                
                // Synthesize AI response with selected voice engine
                if (voiceConfig.enabled && aiData.response_text) {
                    await synthesizeResponseWithChatterbox(aiData.response_text);
                }
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                if (fetchError.message.includes('Failed to fetch')) {
                    throw new Error('Connection failed - please check your connection and try again');
                }
                
                throw fetchError;
            }
        }

        // Manage pinned DID state from the new input
        function onPinnedDidChange(value) {
            const val = (value || '').trim();
            if (!val) {
                window.__alfredPinnedDid = '';
                return;
            }
            if (!val.startsWith('did:arweave:')) {
                alert('Please enter a valid DID that starts with did:arweave:');
                return;
            }
            window.__alfredPinnedDid = val;
            // Also reflect to the main filters DID input so the browse view loads that record
            const didInput = document.getElementById('voice-did-tx');
            if (didInput) {
                didInput.value = val;
                validateAndApplyDidTx();
            }
        }

        function clearPinnedDid() {
            window.__alfredPinnedDid = '';
            const pinned = document.getElementById('alfred-pinned-did');
            if (pinned) pinned.value = '';
        }



        function displayAISearchResults(searchResults, appliedFilters) {
            console.log(`[Chat AI] 🎯 Displaying ${searchResults.length} exact AI search results`);
            
            // Switch to Browse tab to show the visual representation
            showSearchInterface();
            
            // Update global state to match AI results
            currentRecords = searchResults;
            currentPage = 1;
            hasMoreRecords = false; // AI results are finite
            
            // Update the interface with AI filters
            Object.assign(currentFilters, appliedFilters);
            
            // Update UI elements
            if (appliedFilters.search) {
                document.getElementById('voice-search-input').value = appliedFilters.search;
            }
            if (appliedFilters.searchMatchMode) {
                document.getElementById('voice-search-match-mode').value = appliedFilters.searchMatchMode;
            }
            if (appliedFilters.recordType) {
                document.getElementById('voice-record-type-filter').value = appliedFilters.recordType;
            }
            if (appliedFilters.sortBy) {
                document.getElementById('voice-sort-by').value = appliedFilters.sortBy;
            }
            
            // Handle AI multi-tag filters
            if (appliedFilters.tags && appliedFilters.tagsMatchMode) {
                currentFilters.aiTags = appliedFilters.tags;
                currentFilters.aiTagsMatchMode = appliedFilters.tagsMatchMode;
            }
            
            // Display the exact results the AI found
            displayVoiceRecords(searchResults, false);
            
            // Update pagination info
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${searchResults.length} AI search results • Page 1`;
            
            // Hide load more button since AI results are finite
            document.getElementById('voice-load-more-container').classList.add('hidden');
            
            // Extract and update tag summary if available
            const allTags = [];
            searchResults.forEach(record => {
                const tags = record.data?.basic?.tagItems || [];
                tags.forEach(tag => {
                    const existing = allTags.find(t => t.tag === tag);
                    if (existing) {
                        existing.count++;
                    } else {
                        allTags.push({ tag, count: 1 });
                    }
                });
            });
            
            if (allTags.length > 0) {
                updateVoiceTagFilter(allTags);
            }
            
            console.log(`[Chat AI] ✅ Successfully displayed ${searchResults.length} AI search results`);
        }

        async function applyAIFilters(filters, sources = []) {
            // Switch to Browse tab to show the visual representation
            showSearchInterface();
            
            // Update the enhanced unified filters state
            Object.assign(currentFilters, filters);
            
            // Update the UI elements for basic filters
            if (filters.search) {
                document.getElementById('voice-search-input').value = filters.search;
            }
            if (filters.searchMatchMode) {
                document.getElementById('voice-search-match-mode').value = filters.searchMatchMode;
            }
            if (filters.recordType) {
                document.getElementById('voice-record-type-filter').value = filters.recordType;
            }
            if (filters.sortBy) {
                document.getElementById('voice-sort-by').value = filters.sortBy;
            }
            if (filters.did || filters.didTx) {
                document.getElementById('voice-did-tx').value = filters.did || filters.didTx;
            }
            
            // Handle enhanced multi-tag filtering from AI
            if (filters.tags && filters.tagsMatchMode) {
                console.log(`[Enhanced AI] Applying multi-tag filter: ${filters.tags} (${filters.tagsMatchMode} mode)`);
                // Store the AI-applied tag filters separately since UI doesn't support multi-tag
                currentFilters.aiTags = filters.tags;
                currentFilters.aiTagsMatchMode = filters.tagsMatchMode;
                
                // Clear the single tag filter since we're using AI multi-tag
                currentFilters.tag = '';
                document.getElementById('voice-tag-filter').value = '';
            } else if (filters.tag) {
                // Handle single tag from regular filtering
                currentFilters.tag = filters.tag;
                if (document.getElementById('voice-tag-filter')) {
                    document.getElementById('voice-tag-filter').value = filters.tag;
                }
            }
            
            // Update applied filters display
            displayAppliedFilters(filters, sources);
            
            // Reload records with new filters using enhanced system
            await loadVoiceRecords(true);
            
            console.log('[Enhanced AI] Applied AI filters:', filters);
        }

        function displayAppliedFilters(filters, sources) {
            const display = document.getElementById('applied-filters-display');
            const container = document.getElementById('filter-chips-container');
            const rationale = document.getElementById('filter-rationale');
            
            // Clear existing chips
            container.innerHTML = '';
            
            // Create filter chips
            let hasFilters = false;
            if (filters.search) {
                addFilterChip(container, 'Search', filters.search);
                hasFilters = true;
            }
            if (filters.recordType) {
                addFilterChip(container, 'Type', filters.recordType);
                hasFilters = true;
            }
            if (currentFilters.hasAudio) {
                addFilterChip(container, 'Content', 'Has Audio');
                hasFilters = true;
            }
            if (currentFilters.did || currentFilters.didTx) {
                const didValue = currentFilters.did || currentFilters.didTx;
                const shortDid = didValue.length > 25 ? 
                    didValue.substring(0, 25) + '...' : 
                    didValue;
                addFilterChip(container, 'DID', shortDid);
                hasFilters = true;
            }
            if (filters.sortBy && filters.sortBy !== 'inArweaveBlock:desc') {
                addFilterChip(container, 'Sort', filters.sortBy.replace(':', ' '));
                hasFilters = true;
            }
            // Show manual multi-tag filters first (highest priority)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                const tagMode = currentFilters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `Tags (${tagMode})`, currentFilters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show AI-applied filters if no manual filters
            else if (filters.tags && filters.tagsMatchMode) {
                const tagMode = filters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `AI Tags (${tagMode})`, filters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show legacy single tag filter (fallback)
            else if (filters.tag) {
                addFilterChip(container, 'Tag', filters.tag);
                hasFilters = true;
            }
            
            if (hasFilters) {
                display.classList.remove('hidden');
                
                // Use rationale from backend or generate fallback
                const rationaleText = filters.rationale || `AI applied these filters automatically based on your query.`;
                rationale.textContent = rationaleText;
            } else {
                display.classList.add('hidden');
            }
        }

        function addFilterChip(container, label, value) {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';
            chip.textContent = `${label}: ${value}`;
            container.appendChild(chip);
        }

        // No audio playback needed for text chat

        // Conversation Management
        function addToConversation(role, content, metadata = {}) {
            const message = {
                role,
                content,
                timestamp: new Date().toISOString(),
                ...metadata
            };
            
            chatState.conversation.push(message);
            updateConversationDisplay();
        }

        function updateConversationDisplay() {
            const container = document.getElementById('chat-messages');
            const emptyState = document.getElementById('chat-empty-state');
            
            if (chatState.conversation.length === 0) {
                emptyState.style.display = 'flex';
                container.innerHTML = '';
                return;
            }
            
            emptyState.style.display = 'none';
            container.innerHTML = '';
            
            // Show all messages
            chatState.conversation.forEach((message, index) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}`;
                
                const avatar = getMessageAvatar(message.role);
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                
                let sourcesHtml = '';
                if (message.role === 'assistant' && message.sources && message.sources.length > 0) {
                    sourcesHtml = `
                        <div class="message-sources">
                            <span class="source-count">📚 ${message.sources.length} sources found</span>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-content">
                        <div class="message-text">${escapeHtml(message.content)}</div>
                        ${sourcesHtml}
                        <div class="message-meta">
                            <span class="message-timestamp">${timestamp}</span>
                        </div>
                    </div>
                `;
                
                container.appendChild(messageDiv);
            });
            
            // Scroll to bottom
            const chatConversation = document.getElementById('chat-conversation');
            setTimeout(() => {
                chatConversation.scrollTop = chatConversation.scrollHeight;
            }, 10);
        }

        function ensureChatInputReady() {
            const chatInput = document.getElementById('ai-chat-input');
            const sendBtn = document.getElementById('ai-chat-send-btn');
            
            if (chatInput) {
                chatInput.disabled = false;
                chatInput.removeAttribute('readonly');
                chatInput.removeAttribute('hidden');
                chatInput.classList.remove('hidden');
                
                // Only reset dimensions if they're problematic
                if (chatInput.offsetHeight === 0) {
                    chatInput.style.height = '60px';
                }
            }
            
            if (sendBtn) {
                sendBtn.disabled = chatState.isProcessing;
                sendBtn.removeAttribute('hidden');
                sendBtn.classList.remove('hidden');
            }
        }

        function getMessageAvatar(role) {
            switch (role) {
                case 'user': return '👤';
                case 'assistant': return '🤖';
                case 'system': return '⚠️';
                default: return '💬';
            }
        }

        // STT (Speech-to-Text) Functions
        
        // Voice Activity Detection configuration
        const VAD_CONFIG = {
            silenceThreshold: 0.01,
            silenceTimeoutMs: 2000,
            minRecordingMs: 1500,
            volumeThreshold: 0.12,
        };

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator?.mediaDevices?.getUserMedia);
            const hasMediaRecorder = typeof MediaRecorder !== 'undefined';
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            
            return hasMediaDevices && hasMediaRecorder && hasAudioContext;
        }

        async function toggleRecording() {
            if (chatState.isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            if (!checkBrowserSupport()) {
                updateAIStatus('Browser does not support voice recording');
                return;
            }

            try {
                chatState.mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                await setupVAD(chatState.mediaStream);

                chatState.mediaRecorder = new MediaRecorder(chatState.mediaStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                chatState.audioChunks = [];

                chatState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chatState.audioChunks.push(event.data);
                    }
                };

                chatState.mediaRecorder.onstop = async () => {
                    if (chatState.audioChunks.length > 0) {
                        const audioBlob = new Blob(chatState.audioChunks, { type: 'audio/webm' });
                        await processAudioBlob(audioBlob);
                    }
                };

                chatState.mediaRecorder.start();
                chatState.isRecording = true;
                updateMicrophoneButton();
                updateAIStatus('Recording... Speak now');

            } catch (error) {
                console.error('Error starting recording:', error);
                updateAIStatus('Microphone access denied');
                cleanupRecording();
            }
        }

        async function setupVAD(stream) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            chatState.audioContext = new AudioContext();

            if (chatState.audioContext.state === 'suspended') {
                await chatState.audioContext.resume();
            }

            chatState.analyser = chatState.audioContext.createAnalyser();
            chatState.analyser.fftSize = 512;

            const source = chatState.audioContext.createMediaStreamSource(stream);
            source.connect(chatState.analyser);

            const bufferLength = chatState.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const monitorAudio = () => {
                if (!chatState.analyser || !chatState.isRecording) return;

                chatState.analyser.getByteFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength) / 255;

                const now = Date.now();

                if (rms > VAD_CONFIG.volumeThreshold) {
                    chatState.lastSpeechTime = now;
                    chatState.isListening = true;
                    updateMicrophoneButton();

                    if (chatState.silenceTimeout) {
                        clearTimeout(chatState.silenceTimeout);
                        chatState.silenceTimeout = null;
                    }
                } else {
                    const recordingDuration = now - (chatState.lastSpeechTime || now);

                    if (recordingDuration > VAD_CONFIG.minRecordingMs && chatState.lastSpeechTime > 0) {
                        if (!chatState.silenceTimeout) {
                            chatState.silenceTimeout = setTimeout(() => {
                                stopRecording();
                            }, VAD_CONFIG.silenceTimeoutMs);
                        }
                    }

                    chatState.isListening = false;
                    updateMicrophoneButton();
                }
            };

            chatState.vadInterval = setInterval(monitorAudio, 100);
        }

        function stopRecording() {
            if (chatState.mediaRecorder && chatState.isRecording) {
                chatState.mediaRecorder.stop();
            }
            
            chatState.isRecording = false;
            chatState.isListening = false;
            updateMicrophoneButton();
            cleanupVAD();

            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            updateAIStatus('Processing speech...');
        }

        function cleanupVAD() {
            if (chatState.vadInterval) {
                clearInterval(chatState.vadInterval);
                chatState.vadInterval = null;
            }

            if (chatState.silenceTimeout) {
                clearTimeout(chatState.silenceTimeout);
                chatState.silenceTimeout = null;
            }

            if (chatState.analyser) {
                chatState.analyser = null;
            }
        }

        function cleanupRecording() {
            cleanupVAD();
            
            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            if (chatState.audioContext && chatState.audioContext.state !== 'closed') {
                chatState.audioContext.close();
                chatState.audioContext = null;
            }

            chatState.isRecording = false;
            chatState.isTranscribing = false;
            chatState.isListening = false;
            updateMicrophoneButton();
        }

        async function processAudioBlob(audioBlob) {
            try {
                chatState.isTranscribing = true;
                updateMicrophoneButton();
                updateAIStatus('Transcribing speech...');

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                
                // Add language if specified
                const language = document.getElementById('stt-language').value;
                if (language && language !== 'auto') {
                    formData.append('language', language);
                }

                const response = await fetch('/api/alfred/transcribe', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Speech transcription failed');
                }

                const data = await response.json();
                const transcribedText = data.text?.trim();

                if (!transcribedText) {
                    updateAIStatus('No speech detected. Try again.');
                    return;
                }

                console.log('[STT] Transcribed:', transcribedText);

                // Add transcribed text to the conversation window immediately
                addToConversation('user', transcribedText);

                // Also put transcribed text in the input field for editing if needed
                const input = document.getElementById('ai-chat-input');
                input.value = transcribedText;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 200) + 'px';

                // Automatically process the transcribed text with AI (like working index.html)
                updateAIStatus('Processing your question...');
                
                // Update selected model and voice from current settings
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                // Automatically trigger AI processing
                await processTextWithAI(transcribedText);

            } catch (error) {
                console.error('Transcription error:', error);
                updateAIStatus('Speech transcription failed');
            } finally {
                chatState.isTranscribing = false;
                updateMicrophoneButton();
            }
        }

        function updateMicrophoneButton() {
            const micBtn = document.getElementById('mic-btn');
            
            // Default microphone SVG
            const microphoneSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M50,10 C43.373,10 38,15.373 38,22 L38,50 C38,56.627 43.373,62 50,62 C56.627,62 62,56.627 62,50 L62,22 C62,15.373 56.627,10 50,10 Z M50,15 C53.866,15 57,18.134 57,22 L57,50 C57,53.866 53.866,57 50,57 C46.134,57 43,53.866 43,50 L43,22 C43,18.134 46.134,15 50,15 Z M20,45 L20,50 C20,66.568 33.432,80 50,80 C66.568,80 80,66.568 80,50 L80,45 L85,45 L85,50 C85,69.33 69.33,85 50,85 L50,90 L60,90 L60,95 L40,95 L40,90 L50,90 L50,85 C30.67,85 15,69.33 15,50 L15,45 L20,45 Z"/>
            </svg>`;
            
            // Processing/loading SVG
            const processingSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="35" fill="none" stroke="currentColor" stroke-width="8" stroke-dasharray="164.93361431346415 54.97787143782138">
                    <animateTransform attributeName="transform" type="rotate" values="0 50 50;360 50 50" dur="1s" repeatCount="indefinite"/>
                </circle>
            </svg>`;
            
            // Recording dot SVG
            const recordingSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="30" fill="currentColor"/>
            </svg>`;
            
            // Reset all classes
            micBtn.classList.remove('recording', 'listening', 'transcribing');
            
            if (chatState.isTranscribing) {
                micBtn.classList.add('transcribing');
                micBtn.innerHTML = processingSVG;
                micBtn.title = 'Processing speech...';
            } else if (chatState.isRecording) {
                if (chatState.isListening) {
                    micBtn.classList.add('listening');
                    micBtn.innerHTML = microphoneSVG;
                    micBtn.title = 'Listening... (click to stop)';
                } else {
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = recordingSVG;
                    micBtn.title = 'Recording... (click to stop)';
                }
            } else {
                micBtn.innerHTML = microphoneSVG;
                micBtn.title = 'Click to record voice message';
            }
        }

        function clearConversation() {
            // Stop any current recording
            if (chatState.isRecording) {
                stopRecording();
            }
            
            // Clear conversation array
            chatState.conversation = [];
            
            // Clear follow-up tracking state
            chatState.lastSearchResults = [];
            chatState.lastSearchSubject = '';
            chatState.lastSearchKeywords = [];
            
            // Update display
            updateConversationDisplay();
            
            // Clear any applied filters
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            // Ensure input is ready
            ensureChatInputReady();
            
            updateAIStatus('Ready to answer questions!');
        }

        // No conversation mode needed for text chat

        // View Mode Management
        let currentViewMode = 'grid'; // Default view mode
        let tagFilterIndex = 0; // Track multi-tag filter indices
        const viewModeDefaults = {
            'podcast': 'list',
            'post': 'grid', 
            'recipe': 'grid',
            'video': 'grid',
            'audio': 'list',
            'image': 'grid',
            'text': 'list',
            'workout': 'grid'
        };

        // Enhanced view mode functionality with error handling
        function changeViewMode() {
            try {
                const viewAsElement = document.getElementById('voice-view-as');
                if (!viewAsElement) {
                    console.error('[View Mode] voice-view-as element not found');
                    return;
                }
                
                const newMode = viewAsElement.value;
                console.log(`[View Mode] Attempting to change from ${currentViewMode} to ${newMode}`);
                
                if (newMode !== currentViewMode) {
                    currentViewMode = newMode;
                    
                    // Re-render current records with new view mode
                    if (currentRecords && currentRecords.length > 0) {
                        console.log(`[View Mode] Re-rendering ${currentRecords.length} records with ${newMode} view`);
                        displayVoiceRecords(currentRecords, false);
                    } else {
                        console.log('[View Mode] No records to re-render');
                        // Still update the container class even if no records
                        const container = document.getElementById('voice-records-grid');
                        if (container) {
                            container.className = newMode === 'list' ? 'records-list' : 'records-grid';
                        }
                    }
                    
                    console.log(`[View Mode] Successfully changed to ${newMode} view`);
                } else {
                    console.log('[View Mode] No change needed - already in', newMode, 'mode');
                }
            } catch (error) {
                console.error('[View Mode] Error in changeViewMode:', error);
                // Show user-friendly error message
                const statusDiv = document.getElementById('voice-loading-indicator');
                if (statusDiv) {
                    statusDiv.innerHTML = '❌ View mode change failed. Please refresh the page.';
                    statusDiv.classList.remove('hidden');
                    setTimeout(() => {
                        statusDiv.classList.add('hidden');
                    }, 5000);
                }
            }
        }

        // Enhanced displayVoiceRecords function with improved error handling
        function displayVoiceRecords(records, append = false) {
            try {
                const container = document.getElementById('voice-records-grid');
                if (!container) {
                    console.error('[Enhanced Display] voice-records-grid container not found');
                    return;
                }
                
                console.log(`[Enhanced Display] Displaying ${records.length} records, append=${append}, currentViewMode=${currentViewMode}`);
                
                if (!append) {
                    container.innerHTML = '';
                }
                
                // Update container class based on view mode
                const containerClass = currentViewMode === 'list' ? 'records-list' : 'records-grid';
                container.className = containerClass;
                console.log(`[Enhanced Display] Set container class to: ${containerClass}`);
                
                // Group podcast records by show
                const podcastShows = {};
                const nonPodcastRecords = [];
                
                records.forEach(record => {
                    try {
                        if (record.oip?.recordType === 'podcast' && record.data?.podcast?.show) {
                            const showName = record.data.podcast.show;
                            if (!podcastShows[showName]) {
                                podcastShows[showName] = [];
                            }
                            podcastShows[showName].push(record);
                        } else {
                            nonPodcastRecords.push(record);
                        }
                    } catch (recordError) {
                        console.error('[Enhanced Display] Error processing record:', recordError, record);
                        nonPodcastRecords.push(record); // Add to non-podcast as fallback
                    }
                });
                
                const startIndex = currentRecords.length - records.length;
                let recordIndex = startIndex;
                
                // Render podcast shows
                Object.keys(podcastShows).forEach(showName => {
                    try {
                        const episodes = podcastShows[showName];
                        
                        if (currentViewMode === 'list') {
                            // In list view, render individual podcast episodes
                            episodes.forEach(episode => {
                                const episodeCard = createRecordCard(episode, recordIndex, true);
                                container.appendChild(episodeCard);
                                recordIndex++;
                            });
                        } else {
                            // In grid view, use grouped podcast show cards
                            const showCard = createPodcastShowCard(showName, episodes, recordIndex);
                            container.appendChild(showCard);
                            recordIndex += episodes.length;
                        }
                    } catch (showError) {
                        console.error('[Enhanced Display] Error rendering podcast show:', showError, showName);
                    }
                });
                
                // Render non-podcast records
                nonPodcastRecords.forEach(record => {
                    try {
                        const card = createRecordCard(record, recordIndex, currentViewMode === 'list');
                        container.appendChild(card);
                        recordIndex++;
                    } catch (cardError) {
                        console.error('[Enhanced Display] Error creating record card:', cardError, record);
                    }
                });
                
                container.classList.remove('hidden');
                document.getElementById('voice-no-results').classList.add('hidden');
                
                console.log(`[Enhanced Display] Successfully rendered ${records.length} records in ${currentViewMode} view (${Object.keys(podcastShows).length} podcast shows)`);
                
            } catch (error) {
                console.error('[Enhanced Display] Error in displayVoiceRecords:', error);
                
                // Show error message to user
                const container = document.getElementById('voice-records-grid');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px; margin: 20px 0;">
                            <h4>❌ Error Displaying Records</h4>
                            <p>There was an error displaying the records. Please try refreshing the page.</p>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                    container.classList.remove('hidden');
                }
            }
        }

        // Enhanced createRecordCard function with better error handling
        function createRecordCard(record, recordIndex, isListView = false) {
            try {
                const card = document.createElement('div');
                card.className = isListView ? 'record-card list-view' : 'record-card';
                
                const recordType = record.oip?.recordType || 'unknown';
                const basicData = record.data?.basic || {};
                
                let templatesUsed = [];
                try {
                    templatesUsed = analyzeRecordTemplates(record);
                } catch (error) {
                    console.warn('[Card Creation] Error analyzing templates:', error);
                    templatesUsed = [recordType];
                }
                
                // Extract media and content for modern display
                let mediaContent = {};
                try {
                    mediaContent = extractMediaContent(record);
                } catch (error) {
                    console.warn('[Card Creation] Error extracting media content:', error);
                    mediaContent = { featuredImage: null, audioItems: [], videoItems: [] };
                }
                
                const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
                
                if (isListView) {
                    // List view layout - horizontal layout with thumbnail on left
                    card.innerHTML = `
                        ${renderMediaPreview(mediaContent, recordIndex, record)}
                        
                        <div class="record-content-area">
                            <div class="record-header">
                                <div class="record-type">${recordType}</div>
                                <div class="record-date">${dateDisplay}</div>
                            </div>
                            
                            ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                            
                            <div class="list-meta-row">
                                <div class="list-controls">
                                    ${renderMediaControls(mediaContent, record, recordIndex)}
                                    ${renderArticleTextButton(mediaContent, recordIndex)}
                                    ${renderWebUrlButton(mediaContent)}
                                </div>
                                <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                    🔧
                                </button>
                            </div>
                            
                            ${createTagsDisplay(basicData.tagItems)}
                            ${renderPodcastCitations(mediaContent, recordIndex)}
                        </div>
                        
                        <div id="structure-${recordIndex}" class="record-structure hidden">
                            <div class="structure-header">
                                <h4>🔧 Technical Record Structure</h4>
                                <div class="template-info">
                                    <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                    <strong>Record Type:</strong> ${recordType}<br>
                                    <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                    ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                                </div>
                            </div>
                            ${renderAllTemplateData(record, templatesUsed)}
                        </div>
                    `;
                } else {
                    // Grid view layout - vertical layout (original)
                    card.innerHTML = `
                        <div class="record-header">
                            <div class="record-type">${recordType}</div>
                            <div class="record-date">${dateDisplay}</div>
                        </div>
                        
                        ${renderMediaPreview(mediaContent, recordIndex, record)}
                        
                        <div class="record-content">
                            ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                            
                            ${renderMediaControls(mediaContent, record, recordIndex)}
                            ${renderArticleTextButton(mediaContent, recordIndex)}
                            ${renderWebUrlButton(mediaContent)}
                            ${renderPodcastCitations(mediaContent, recordIndex)}
                        </div>
                        
                        ${createTagsDisplay(basicData.tagItems)}
                        
                        <div class="record-footer">
                            <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                <span class="structure-icon">🔧</span> Show Record Structure
                            </button>
                            <div class="record-did">DID: ${truncateText(record.oip?.did || record.oip?.didTx || 'Unknown', 20)}</div>
                        </div>
                        
                        <div id="structure-${recordIndex}" class="record-structure hidden">
                            <div class="structure-header">
                                <h4>🔧 Technical Record Structure</h4>
                                <div class="template-info">
                                    <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                    <strong>Record Type:</strong> ${recordType}<br>
                                    <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                    ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                                </div>
                            </div>
                            ${renderAllTemplateData(record, templatesUsed)}
                        </div>
                    `;
                }
                
                return card;
                
            } catch (error) {
                console.error('[Card Creation] Error creating record card:', error, record);
                
                // Return a fallback error card
                const errorCard = document.createElement('div');
                errorCard.className = isListView ? 'record-card list-view' : 'record-card';
                errorCard.innerHTML = `
                    <div style="padding: 15px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px;">
                        <h4>❌ Error Displaying Record</h4>
                        <p>There was an error displaying this record.</p>
                        <small>Record Type: ${record.oip?.recordType || 'Unknown'}</small>
                    </div>
                `;
                return errorCard;
            }
        }

        // Add initialization check to ensure view mode works on page load
        function initializeViewMode() {
            try {
                const viewAsElement = document.getElementById('voice-view-as');
                if (viewAsElement) {
                    viewAsElement.value = currentViewMode;
                    console.log(`[View Mode] Initialized with mode: ${currentViewMode}`);
                } else {
                    console.warn('[View Mode] voice-view-as element not found during initialization');
                }
            } catch (error) {
                console.error('[View Mode] Error during initialization:', error);
            }
        }

        // Call initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeViewMode();
        });

        // Also initialize if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeViewMode);
        } else {
            initializeViewMode();
        }
        
        function updateAllTagDropdowns() {
            const selects = document.querySelectorAll('.tag-filter-select');
            const container = document.getElementById('tag-filters-container');
            
            // Store current values before clearing dropdowns
            const currentValues = [];
            selects.forEach(select => {
                currentValues.push({
                    index: parseInt(select.getAttribute('data-tag-index')),
                    value: select.value
                });
            });
            
            // Add compact styling when there are many tag filters
            if (selects.length >= 3) {
                container.classList.add('has-many-tags');
            } else {
                container.classList.remove('has-many-tags');
            }
            
            // Get all currently selected tags (exclude empty values)
            const allSelectedTags = currentValues
                .filter(item => item.value && item.value.trim())
                .map(item => item.value.trim());
            
            selects.forEach((select, selectIndex) => {
                const selectTagIndex = parseInt(select.getAttribute('data-tag-index'));
                const currentValue = currentValues.find(item => item.index === selectTagIndex)?.value || '';
                
                // Clear and repopulate options
                select.innerHTML = '<option value="">Select a tag...</option>';
                
                if (availableTags && availableTags.length > 0) {
                    availableTags.forEach(tag => {
                        // Add this tag if:
                        // 1. It's not selected by any other dropdown, OR
                        // 2. It's the current value of THIS dropdown
                        const isSelectedByOthers = allSelectedTags.some(selectedTag => 
                            selectedTag === tag.tag && selectedTag !== currentValue
                        );
                        
                        if (!isSelectedByOthers) {
                            const option = document.createElement('option');
                            option.value = tag.tag;
                            option.textContent = `${tag.tag} (${tag.count})`;
                            select.appendChild(option);
                        }
                    });
                }
                
                // Restore the current value (this will work now because we rebuilt the options)
                if (currentValue && currentValue.trim()) {
                    select.value = currentValue;
                    console.log(`[Multi-Tag] Restored value "${currentValue}" for select ${selectTagIndex}`);
                }
            });
            
            // Get final selected tags for logging
            const finalSelectedTags = getSelectedTags();
            console.log('[Multi-Tag] Updated dropdowns. Selected tags:', finalSelectedTags, 'Compact mode:', selects.length >= 3);
        }
        
        function clearAllTagFilters() {
            // Reset to single empty tag filter
            const container = document.getElementById('tag-filters-container');
            
            // Remove compact styling
            container.classList.remove('has-many-tags');
            
            container.innerHTML = `
                <div class="tag-filter-row" data-tag-index="0">
                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                        <option value="">Select a tag...</option>
                    </select>
                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                </div>
            `;
            
            // Reset the match mode
            document.getElementById('tag-match-mode').value = 'OR';
            
            tagFilterIndex = 0;
            updateAllTagDropdowns(); // This will ensure compact styling stays off
            console.log('[Multi-Tag] Cleared all tag filters');
        }
        
        function setDefaultViewMode() {
            // Set appropriate default view mode based on record type
            const recordType = currentFilters.recordType;
            if (recordType && viewModeDefaults[recordType]) {
                const defaultMode = viewModeDefaults[recordType];
                if (currentViewMode !== defaultMode) {
                    currentViewMode = defaultMode;
                    const viewAsElement = document.getElementById('voice-view-as');
                    if (viewAsElement) {
                        viewAsElement.value = defaultMode;
                    }
                    console.log(`[View Mode] Set default view mode for ${recordType}: ${defaultMode}`);
                }
            }
        }

        function getSelectedTags() {
            // Get all selected tags from the multi-tag filter system
            const tagSelects = document.querySelectorAll('.tag-filter-select');
            const selectedTags = [];
            
            tagSelects.forEach(select => {
                const value = select.value.trim();
                if (value) {
                    selectedTags.push(value);
                }
            });
            
            return selectedTags;
        }

        function addTagFilter() {
            // Add another tag filter row
            tagFilterIndex++;
            const container = document.getElementById('tag-filters-container');
            
            const newRow = document.createElement('div');
            newRow.className = 'tag-filter-row';
            newRow.setAttribute('data-tag-index', tagFilterIndex);
            
            newRow.innerHTML = `
                <select class="tag-filter-select" onchange="onTagFilterChange(${tagFilterIndex})" data-tag-index="${tagFilterIndex}">
                    <option value="">Select a tag...</option>
                </select>
                <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                <button type="button" class="remove-tag-btn" onclick="removeTagFilter(${tagFilterIndex})" title="Remove this tag filter">×</button>
            `;
            
            container.appendChild(newRow);
            updateAllTagDropdowns();
            console.log(`[Multi-Tag] Added tag filter ${tagFilterIndex}`);
        }

        function removeTagFilter(index) {
            // Remove a specific tag filter
            const row = document.querySelector(`[data-tag-index="${index}"]`);
            if (row) {
                row.remove();
                updateAllTagDropdowns();
                console.log(`[Multi-Tag] Removed tag filter ${index}`);
            }
        }

        function onTagFilterChange(index) {
            // Handle tag filter selection change
            console.log(`[Multi-Tag] Tag filter ${index} changed`);
            updateAllTagDropdowns();
            // Auto-apply filters when tags are selected
            applyVoiceFilters();
        }

        function applyVoiceFilters() {
            collectVoiceFilters();
            setDefaultViewMode(); // Set appropriate default view mode based on record type
            loadVoiceRecords(true);
        }

        function collectVoiceFilters() {
            // Sync header search to hidden search input
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                hiddenSearch.value = headerSearch.value;
            }
            
            // Update the main currentFilters object to work with enhanced system
            currentFilters.search = document.getElementById('voice-search-input').value.trim();
            currentFilters.searchMatchMode = document.getElementById('voice-search-match-mode').value;
            currentFilters.recordType = document.getElementById('voice-record-type-filter').value;
            currentFilters.source = document.getElementById('voice-storage-filter').value; // NEW: Storage type filter
            currentFilters.sortBy = document.getElementById('voice-sort-by').value;
            currentFilters.resolveDepth = parseInt(document.getElementById('voice-resolve-depth').value) || 2;
            currentFilters.dateStart = document.getElementById('voice-date-start').value;
            currentFilters.dateEnd = document.getElementById('voice-date-end').value;
            const didValue = document.getElementById('voice-did-tx').value.trim();
            currentFilters.did = didValue;
            currentFilters.didTx = didValue; // Backward compatibility
            currentFilters.includeSigs = document.getElementById('voice-include-sigs-toggle').classList.contains('active');
            currentFilters.includePubKeys = document.getElementById('voice-include-pubkeys-toggle').classList.contains('active');
            currentFilters.hasAudio = document.getElementById('voice-includes-audio-toggle').classList.contains('active');
            
            // Collect multi-tag filters (prioritize user manual selection over AI)
            const selectedTags = getSelectedTags();
            const tagMatchMode = document.getElementById('tag-match-mode').value;
            
            console.log(`[Filters] DEBUG: getSelectedTags() returned:`, selectedTags);
            console.log(`[Filters] DEBUG: tagMatchMode is:`, tagMatchMode);
            
            if (selectedTags.length > 0) {
                // Use manual multi-tag selection
                currentFilters.tags = selectedTags.join(',');
                currentFilters.tagsMatchMode = tagMatchMode;
                currentFilters.tag = ''; // Clear legacy single tag
                
                // Clear AI tags since user is manually filtering
                delete currentFilters.aiTags;
                delete currentFilters.aiTagsMatchMode;
                
                console.log('[Filters] ✅ Using manual multi-tag filters:', selectedTags, 'mode:', tagMatchMode);
                console.log('[Filters] ✅ Final tags parameter:', currentFilters.tags);
            } else {
                // No manual tags selected, keep AI tags if they exist
                if (!currentFilters.aiTags) {
                    currentFilters.tags = '';
                    currentFilters.tagsMatchMode = '';
                    currentFilters.tag = '';
                }
                console.log('[Filters] ❌ No manual tags, keeping AI tags:', currentFilters.aiTags);
            }
            
            // Update debug setting
            showDebugInfo = document.getElementById('show-template-debug')?.checked || false;
            
            console.log('[Filters] Updated filters:', currentFilters);
        }

        function handleVoiceSearchKeyup(event) {
            if (event.key === 'Enter') {
                applyVoiceFilters();
            }
        }

        function validateAndApplyDidTx() {
            const didTxInput = document.getElementById('voice-did-tx');
            const errorDiv = document.getElementById('did-tx-error');
            const value = didTxInput.value.trim();
            
            if (value && !value.startsWith('did:')) {
                errorDiv.classList.remove('hidden');
                didTxInput.style.borderColor = '#dc3545';
                return false;
            } else {
                errorDiv.classList.add('hidden');
                didTxInput.style.borderColor = '';
                applyVoiceFilters();
                return true;
            }
        }
        
        function clearDidTxError() {
            const errorDiv = document.getElementById('did-tx-error');
            const didTxInput = document.getElementById('voice-did-tx');
            errorDiv.classList.add('hidden');
            didTxInput.style.borderColor = '';
        }

        function clearVoiceFilters() {
            document.getElementById('voice-search-input').value = '';
            document.getElementById('voice-search-match-mode').value = 'AND';
            document.getElementById('voice-record-type-filter').value = '';
            document.getElementById('voice-storage-filter').value = 'all'; // NEW: Reset storage filter
            document.getElementById('voice-sort-by').value = 'matchCount:desc';
            document.getElementById('voice-resolve-depth').value = '2';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-did-tx').value = '';
            document.getElementById('voice-include-sigs-toggle').classList.remove('active');
            document.getElementById('voice-include-pubkeys-toggle').classList.remove('active');
            document.getElementById('voice-includes-audio-toggle').classList.remove('active');
            
            // Reset view mode to default grid
            currentViewMode = 'grid';
            document.getElementById('voice-view-as').value = 'grid';
            
            // Clear DID TX error
            clearDidTxError();
            
            // Clear multi-tag filters
            clearAllTagFilters();
            
            // Clear AI-applied multi-tag filters
            delete currentFilters.aiTags;
            delete currentFilters.aiTagsMatchMode;
            delete currentFilters.tags;
            delete currentFilters.tagsMatchMode;
            delete currentFilters.tag;
            
            // Clear DID filters
            delete currentFilters.did;
            delete currentFilters.didTx;
            
            // Clear hasAudio filter
            delete currentFilters.hasAudio;
            
            // Clear applied filters display
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            applyVoiceFilters();
        }

        function toggleVoiceSwitch(elementId) {
            document.getElementById(elementId).classList.toggle('active');
        }

        // ====== ENHANCED VOICE RECORDS LOADING WITH DYNAMIC TEMPLATES ======
        
        async function loadVoiceRecords(reset = false) {
            if (isLoading) return;
            
            try {
                isLoading = true;
                
                if (reset) {
                    currentPage = 1;
                    currentRecords = [];
                    document.getElementById('voice-records-grid').innerHTML = '';
                }
                
                document.getElementById('voice-loading-indicator').classList.remove('hidden');
                
                const params = buildVoiceApiParams();
                console.log(`[Enhanced Records] Loading with resolveDepth=${currentFilters.resolveDepth}, debug=${showDebugInfo}`);
                
                const response = await fetch(`/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    hasMoreRecords = data.totalPages > currentPage;
                    displayVoiceRecords(data.records, !reset);
                    updateVoicePaginationInfo(data);
                    updateVoiceTagFilter(data.tagSummary);
                    
                    // Log template analysis for first record if debug is on
                    if (showDebugInfo && data.records.length > 0) {
                        const firstRecord = data.records[0];
                        const templates = analyzeRecordTemplates(firstRecord);
                        console.log(`[Enhanced Records] First record uses templates:`, templates);
                    }
                } else {
                    showVoiceNoResults();
                }
                
                updateVoiceLoadMoreButton();
                
            } catch (error) {
                console.error('[Enhanced Records] Error loading records:', error);
                showVoiceNoResults();
            } finally {
                isLoading = false;
                document.getElementById('voice-loading-indicator').classList.add('hidden');
            }
        }

        function buildVoiceApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.searchMatchMode) {
                params.append('searchMatchMode', currentFilters.searchMatchMode);
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.did) {
                params.append('did', currentFilters.did);
                console.log('[Enhanced API] Using did filter:', currentFilters.did);
            } else if (currentFilters.didTx) {
                params.append('didTx', currentFilters.didTx);
                console.log('[Enhanced API] Using didTx filter:', currentFilters.didTx);
            }
            
            // Handle hasAudio filter (for finding records with audio content)
            if (currentFilters.hasAudio) {
                params.append('hasAudio', 'true');
                console.log('[Enhanced API] Using hasAudio filter: true');
            }
            
            // Handle tag filters (prioritize manual selection over AI)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                // Use manual multi-tag selection (highest priority)
                params.append('tags', currentFilters.tags);
                params.append('tagsMatchMode', currentFilters.tagsMatchMode);
                console.log(`[Enhanced API] Using manual multi-tag filter: ${currentFilters.tags} (${currentFilters.tagsMatchMode})`);
            } else if (currentFilters.aiTags && currentFilters.aiTagsMatchMode) {
                // Use AI-applied multi-tag filters (fallback)
                params.append('tags', currentFilters.aiTags);
                params.append('tagsMatchMode', currentFilters.aiTagsMatchMode);
                console.log(`[Enhanced API] Using AI multi-tag filter: ${currentFilters.aiTags} (${currentFilters.aiTagsMatchMode})`);
            } else if (currentFilters.tag) {
                // Fallback to legacy single tag
                params.append('tags', currentFilters.tag);
                console.log(`[Enhanced API] Using legacy single tag: ${currentFilters.tag}`);
            }

            console.log('[API] Building request with resolveDepth:', currentFilters.resolveDepth);
            return params.toString();
        }

        /**
         * Display voice records using enhanced dynamic template rendering
         */
        function displayVoiceRecords(records, append = false) {
            try {
                const container = document.getElementById('voice-records-grid');
                if (!container) {
                    console.error('[Enhanced Display] voice-records-grid container not found');
                    return;
                }
                
                console.log(`[Enhanced Display] Displaying ${records.length} records, append=${append}, currentViewMode=${currentViewMode}`);
                
                if (!append) {
                    container.innerHTML = '';
                }
                
                // Update container class based on view mode
                const containerClass = currentViewMode === 'list' ? 'records-list' : 'records-grid';
                container.className = containerClass;
                console.log(`[Enhanced Display] Set container class to: ${containerClass}`);
                
                // Group podcast records by show
                const podcastShows = {};
                const nonPodcastRecords = [];
                
                records.forEach(record => {
                    try {
                        if (record.oip?.recordType === 'podcast' && record.data?.podcast?.show) {
                            const showName = record.data.podcast.show;
                            if (!podcastShows[showName]) {
                                podcastShows[showName] = [];
                            }
                            podcastShows[showName].push(record);
                        } else {
                            nonPodcastRecords.push(record);
                        }
                    } catch (recordError) {
                        console.error('[Enhanced Display] Error processing record:', recordError, record);
                        nonPodcastRecords.push(record); // Add to non-podcast as fallback
                    }
                });
                
                const startIndex = currentRecords.length - records.length;
                let recordIndex = startIndex;
                
                // Render podcast shows
                Object.keys(podcastShows).forEach(showName => {
                    try {
                        const episodes = podcastShows[showName];
                        
                        if (currentViewMode === 'list') {
                            // In list view, render individual podcast episodes
                            episodes.forEach(episode => {
                                const episodeCard = createRecordCard(episode, recordIndex, true);
                                container.appendChild(episodeCard);
                                recordIndex++;
                            });
                        } else {
                            // In grid view, use grouped podcast show cards
                            const showCard = createPodcastShowCard(showName, episodes, recordIndex);
                            container.appendChild(showCard);
                            recordIndex += episodes.length;
                        }
                    } catch (showError) {
                        console.error('[Enhanced Display] Error rendering podcast show:', showError, showName);
                    }
                });
                
                // Render non-podcast records
                nonPodcastRecords.forEach(record => {
                    try {
                        const card = createRecordCard(record, recordIndex, currentViewMode === 'list');
                        container.appendChild(card);
                        recordIndex++;
                    } catch (cardError) {
                        console.error('[Enhanced Display] Error creating record card:', cardError, record);
                    }
                });
                
                container.classList.remove('hidden');
                document.getElementById('voice-no-results').classList.add('hidden');
                
                console.log(`[Enhanced Display] Successfully rendered ${records.length} records in ${currentViewMode} view (${Object.keys(podcastShows).length} podcast shows)`);
                
            } catch (error) {
                console.error('[Enhanced Display] Error in displayVoiceRecords:', error);
                
                // Show error message to user
                const container = document.getElementById('voice-records-grid');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px; margin: 20px 0;">
                            <h4>❌ Error Displaying Records</h4>
                            <p>There was an error displaying the records. Please try refreshing the page.</p>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                    container.classList.remove('hidden');
                }
            }
        }

        function showVoiceNoResults() {
            document.getElementById('voice-records-grid').classList.add('hidden');
            document.getElementById('voice-no-results').classList.remove('hidden');
        }

        function updateVoicePaginationInfo(data) {
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${currentRecords.length} of ${data.totalRecords || 'many'} records • Page ${currentPage}`;
        }

        function updateVoiceTagFilter(tagSummary) {
            if (!tagSummary) return;
            
            // Store available tags globally for multi-tag system
            availableTags = tagSummary;
            
            // Update legacy single tag filter (hidden, for backward compatibility)
            const legacySelect = document.getElementById('voice-tag-filter');
            if (legacySelect) {
                const currentValue = legacySelect.value;
                legacySelect.innerHTML = '<option value="">All Tags</option>';
                
                tagSummary.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.tag;
                    option.textContent = `${tag.tag} (${tag.count})`;
                    legacySelect.appendChild(option);
                });
                
                legacySelect.value = currentValue;
            }
            
            // Update all multi-tag dropdowns
            updateAllTagDropdowns();
            
            console.log('[Multi-Tag] Updated tag filter with', tagSummary.length, 'available tags');
        }

        function updateVoiceLoadMoreButton() {
            const container = document.getElementById('voice-load-more-container');
            const button = document.getElementById('voice-load-more-btn');
            
            if (hasMoreRecords && currentRecords.length > 0) {
                container.classList.remove('hidden');
                button.disabled = isLoading;
                button.textContent = isLoading ? 'Loading...' : 'Load More Records';
            } else {
                container.classList.add('hidden');
            }
        }

        function loadMoreVoiceRecords() {
            if (!hasMoreRecords || isLoading) return;
            currentPage++;
            loadVoiceRecords(false);
        }

        // Voice-specific text content toggle (for embedded text content)
        async function toggleVoiceTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`voice-textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`voice-textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Text';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading text:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Text';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Show Full Text';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }

        // Text content toggle function
        async function toggleTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Article';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading article:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Article';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Load Full Article';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }

        // Interface update functions
        function updatePostInterface() {
            const postType = document.getElementById('post-type').value;
            const authorSection = document.getElementById('author-section');
            
            if (postType === 'microblog') {
                authorSection.style.display = 'none';
            } else {
                authorSection.style.display = 'block';
            }
        }

        function updatePostSource() {
            const source = document.getElementById('post-source').value;
            const manualInterface = document.getElementById('manual-post-interface');
            const xInterface = document.getElementById('x-post-interface');
            const webArticleInterface = document.getElementById('web-article-interface');
            const publishText = document.getElementById('post-publish-text');
            
            // Hide all interfaces first
            manualInterface.classList.add('hidden');
            xInterface.classList.add('hidden');
            webArticleInterface.classList.add('hidden');
            
            if (source === 'archive-x') {
                xInterface.classList.remove('hidden');
                publishText.textContent = '📱 Archive X Post';
            } else if (source === 'archive-web') {
                webArticleInterface.classList.remove('hidden');
                publishText.textContent = '📰 Archive Web Article';
            } else {
                manualInterface.classList.remove('hidden');
                publishText.textContent = '📤 Publish Post';
            }
        }

        function updateVideoInterface() {
            const source = document.getElementById('video-source').value;
            const inputSection = document.getElementById('video-input-section');
            
            switch (source) {
                case 'manual':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'youtube-archive':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="youtube-url">YouTube URL:</label>
                            <input type="url" id="youtube-url" placeholder="https://youtube.com/watch?v=..." required>
                            <button type="button" onclick="archiveYouTubeVideo()" style="margin-top: 10px; width: 100%;">
                                📥 Archive Video & Get Metadata
                            </button>
                        </div>

                        <div id="youtube-progress" class="hidden" style="margin-top: 20px;">
                            <div class="publish-progress">
                                <h4>📥 Archiving YouTube Video...</h4>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="youtube-progress-bar" style="width: 0%;"></div>
                                </div>
                                <div id="youtube-status" style="margin-top: 10px; font-size: 0.9rem;">Initializing...</div>
                            </div>
                        </div>

                        <div id="youtube-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #ff0000;">
                            <h4>🎥 Video Preview</h4>
                            <div id="youtube-thumbnail" style="margin-bottom: 15px;"></div>
                            <div id="youtube-metadata"></div>
                        </div>
                    `;
                    break;
                case 'direct':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'upload':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-file">Upload Video:</label>
                            <input type="file" id="video-file" accept="video/*">
                            <small>Note: Large files may take time to upload</small>
                        </div>
                    `;
                    break;
            }
        }

        // Dynamic ingredient/exercise management
        function addIngredient() {
            const container = document.getElementById('ingredients-container');
            const newRow = document.createElement('div');
            newRow.className = 'ingredient-row';
            newRow.style = 'display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Amount" class="ingredient-amount">
                <input type="text" placeholder="Unit" class="ingredient-unit">
                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                <button type="button" onclick="removeIngredient(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeIngredient(button) {
            button.parentElement.remove();
        }

        function addExercise() {
            const container = document.getElementById('exercises-container');
            const newRow = document.createElement('div');
            newRow.className = 'exercise-row';
            newRow.style = 'display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Exercise name" class="exercise-name">
                <input type="text" placeholder="Sets" class="exercise-sets">
                <input type="text" placeholder="Reps" class="exercise-reps">
                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                <button type="button" onclick="removeExercise(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeExercise(button) {
            button.parentElement.remove();
        }

        // X Post Scraping Functions
        async function scrapeXPost() {
            const url = document.getElementById('x-post-url').value;
            const statusDiv = document.getElementById('x-post-status');
            const previewDiv = document.getElementById('x-post-preview');
            
            if (!url || (!url.includes('x.com') && !url.includes('twitter.com'))) {
                showXPostStatus('Please enter a valid X/Twitter URL', 'error');
                return;
            }

            try {
                showXPostStatus('🔍 Fetching post data...', 'loading');
                
                const response = await fetch('/api/scrape/x-post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();
                console.log('[X Post] Received data:', data); // Debug log

                if (response.ok) {
                    displayXPostPreview(data);
                    showXPostStatus('✅ Post data fetched successfully!', 'success');
                } else {
                    console.error('[X Post] Error response:', data);
                    let errorMessage = data.error || 'Unknown error occurred';
                    
                    // Provide more helpful error messages
                    if (errorMessage.includes('Bearer Token')) {
                        errorMessage = `
                            <div style="text-align: left; line-height: 1.5;">
                                <strong>🔑 X API Setup Required</strong><br><br>
                                To reliably archive X posts, you need X API access:<br><br>
                                <strong>1. Get X API Access:</strong><br>
                                • Go to <a href="https://developer.twitter.com/en/portal/dashboard" target="_blank" style="color: #1da1f2;">developer.twitter.com</a><br>
                                • Create a developer account and app<br>
                                • Get your Bearer Token<br><br>
                                <strong>2. Configure Server:</strong><br>
                                • Add X_BEARER_TOKEN to environment variables<br>
                                • Restart the server<br><br>
                                <em>Without this, X post archiving is unreliable due to X.com login requirements.</em>
                            </div>
                        `;
                    } else if (errorMessage.includes('login') || errorMessage.includes('protected')) {
                        errorMessage = '❌ This X post requires login or is from a protected account. Set up X API access for reliable extraction.';
                    } else if (errorMessage.includes('rate limit')) {
                        errorMessage = '❌ Rate limited by X. Please wait a few minutes and try again.';
                    } else if (errorMessage.includes('Failed to retrieve')) {
                        errorMessage = '❌ Could not extract post data. X may have changed their structure or the post may be unavailable.';
                    }
                    
                    showXPostStatus(errorMessage, 'error');
                }
            } catch (error) {
                console.error('[X Post] Network error:', error);
                let errorMessage = error.message;
                
                if (errorMessage.includes('Failed to fetch')) {
                    errorMessage = '❌ Network error. Please check your connection and try again.';
                } else if (errorMessage.includes('timeout')) {
                    errorMessage = '❌ Request timed out. X may be slow to respond.';
                }
                
                showXPostStatus(`❌ ${errorMessage}`, 'error');
            }
        }

        // Web Article Scraping Functions
        async function scrapeWebArticle() {
            const url = document.getElementById('web-article-url').value;
            
            if (!url) {
                showWebArticleStatus('Please enter a valid article URL', 'error');
                return;
            }

            // Validate URL format
            try {
                new URL(url);
            } catch (error) {
                showWebArticleStatus('Please enter a valid URL format', 'error');
                return;
            }

            try {
                // Show progress
                document.getElementById('web-article-progress').classList.remove('hidden');
                document.getElementById('web-article-preview').classList.add('hidden');
                document.getElementById('web-article-result').classList.add('hidden');
                
                updateWebArticleProgress(5, 'Starting article archival...');
                
                // Start the scraping process
                const response = await fetch('/api/scrape/web-article', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();
                console.log('[Web Article] Received scrape ID:', data);

                if (response.ok && data.scrapeId) {
                    // Open EventSource stream to receive real-time updates
                    openWebArticleStream(data.scrapeId);
                } else {
                    throw new Error(data.error || 'Failed to start article archival');
                }
            } catch (error) {
                console.error('[Web Article] Error:', error);
                showWebArticleStatus(`❌ Error: ${error.message}`, 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
            }
        }

        function openWebArticleStream(scrapeId) {
            const eventSource = new EventSource(`/api/scrape/open-stream?streamId=${scrapeId}`);
            
            eventSource.onopen = function() {
                console.log('[Web Article] Stream opened for scrapeId:', scrapeId);
                updateWebArticleProgress(10, 'Connected to server...');
            };

            eventSource.onmessage = function(event) {
                console.log('[Web Article] Received message:', event);
            };

            eventSource.addEventListener('initializing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Initializing:', data);
                updateWebArticleProgress(15, data.data?.message || 'Initializing browser...');
            });

            eventSource.addEventListener('loading', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Loading:', data);
                updateWebArticleProgress(25, data.data?.message || 'Loading page...');
            });

            eventSource.addEventListener('processing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Processing:', data);
                updateWebArticleProgress(40, data.data?.message || 'Processing content...');
            });

            eventSource.addEventListener('screenshot', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Screenshot:', data);
                updateWebArticleProgress(55, data.data?.message || 'Taking screenshot...');
            });

            eventSource.addEventListener('parsing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Parsing:', data);
                updateWebArticleProgress(70, data.data?.message || 'Parsing article...');
            });

            eventSource.addEventListener('initialData', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Initial data:', data);
                updateWebArticleProgress(75, 'Article data extracted...');
                displayWebArticlePreview(data.data);
            });

            eventSource.addEventListener('finalData', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Final data:', data);
                updateWebArticleProgress(90, 'Finalizing article...');
                // Store the final data for publishing
                window.scrapedWebArticleData = data.data;
            });

            eventSource.addEventListener('archived', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Archived:', data);
                updateWebArticleProgress(100, 'Article archived successfully!');
                showWebArticleStatus(`✅ Article archived successfully! DID: ${data.data?.archived}`, 'success');
                setTimeout(() => {
                    document.getElementById('web-article-progress').classList.add('hidden');
                }, 2000);
                eventSource.close();
            });

            eventSource.addEventListener('error', function(event) {
                const data = JSON.parse(event.data);
                console.error('[Web Article] Error:', data);
                showWebArticleStatus(`❌ Error: ${data.data?.message || 'Unknown error occurred'}`, 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
                eventSource.close();
            });

            eventSource.onerror = function(event) {
                console.error('[Web Article] Stream error:', event);
                showWebArticleStatus('❌ Connection error occurred', 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
                eventSource.close();
            };
        }

        function updateWebArticleProgress(percent, status) {
            document.getElementById('web-article-progress-bar').style.width = `${percent}%`;
            document.getElementById('web-article-status').textContent = status;
        }

        function displayWebArticlePreview(data) {
            const previewDiv = document.getElementById('web-article-preview');
            const contentDiv = document.getElementById('web-article-content');
            const metaDiv = document.getElementById('web-article-meta');

            console.log('[Web Article] Displaying preview for data:', data);

            const title = data.title || 'Unknown Title';
            const description = data.description || 'No description available';
            const byline = data.byline || 'Unknown Author';
            const domain = data.domain || 'Unknown Domain';
            const publishDate = data.publishDate ? new Date(data.publishDate * 1000).toLocaleDateString() : 'Unknown Date';

            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px; color: #28a745;">${title}</div>
                <div style="line-height: 1.4; margin-bottom: 10px; color: #666;">${description}</div>
                ${data.screenshotURL ? `
                    <div style="margin-top: 10px;">
                        <img src="${data.screenshotURL}" 
                             style="max-width: 100%; max-height: 200px; border-radius: 8px; border: 1px solid #ddd;" 
                             alt="Article screenshot"
                             onerror="this.style.display='none';">
                    </div>
                ` : ''}
            `;

            metaDiv.innerHTML = `
                <strong>Author:</strong> ${byline}<br>
                <strong>Domain:</strong> ${domain}<br>
                <strong>Published:</strong> ${publishDate}<br>
                <strong>URL:</strong> <a href="${data.url}" target="_blank" style="color: #28a745;">${data.url}</a><br>
                ${data.tags && data.tags.length > 0 ? `<strong>Tags:</strong> ${data.tags.join(', ')}<br>` : ''}
                ${data.summaryTTS ? `<strong>Audio Summary:</strong> <a href="${data.summaryTTS}" target="_blank">🎵 Listen</a><br>` : ''}
            `;

            previewDiv.classList.remove('hidden');
        }

        function showWebArticleStatus(message, type) {
            const statusDiv = document.getElementById('web-article-result');
            statusDiv.className = 'hidden';
            
            if (type === 'error') {
                statusDiv.className = 'error-message';
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            } else if (type === 'success') {
                statusDiv.className = 'success-message';
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else {
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.style.border = '1px solid #2196f3';
            }
            
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden');
        }

        function displayXPostPreview(data) {
            const previewDiv = document.getElementById('x-post-preview');
            const contentDiv = document.getElementById('x-post-content');
            const metaDiv = document.getElementById('x-post-meta');

            console.log('[X Post] Displaying preview for data:', data); // Debug log

            // Store data for publishing
            window.scrapedXPostData = data;

            // Handle different possible data structures from the API
            const author = data.author || data.username || data.user?.screen_name || data.user?.username || '';
            const text = data.text || data.full_text || data.tweet_text || data.content || '';
            const postUrl = data.url || data.original_url || url;
            const postDate = data.date || data.created_at || data.timestamp || '';
            const images = data.images || data.media || data.photos || [];

            // Ensure we have an array for images
            const imageArray = Array.isArray(images) ? images : (images ? [images] : []);

            // Check if we have any meaningful data
            const hasData = author.trim() || text.trim() || imageArray.length > 0;
            
            if (!hasData) {
                contentDiv.innerHTML = `
                    <div style="color: #dc3545; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <strong>⚠️ No content extracted</strong><br>
                        This X post may be:<br>
                        • From a protected/private account<br>
                        • Requiring login to view<br>
                        • Deleted or unavailable<br>
                        • Using new X.com structure we haven't adapted to yet
                    </div>
                `;
            } else {
                contentDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 8px; color: #1da1f2;">
                        ${author ? `@${author}` : 'Unknown Author'}
                    </div>
                    <div style="line-height: 1.4; margin-bottom: 10px; white-space: pre-wrap;">
                        ${text || '<em style="color: #666;">No text content found</em>'}
                    </div>
                    ${imageArray.length > 0 ? `
                        <div style="margin-top: 10px;">
                            <strong>Images (${imageArray.length}):</strong><br>
                            ${imageArray.map((img, index) => `
                                <img src="${img}" 
                                     style="max-width: 150px; max-height: 150px; margin: 5px; border-radius: 8px; border: 1px solid #ddd;" 
                                     alt="Tweet image ${index + 1}"
                                     onerror="this.style.display='none';">
                            `).join('')}
                        </div>
                    ` : '<div style="color: #666; font-style: italic;">No images</div>'}
                `;
            }

            metaDiv.innerHTML = `
                <strong>Original URL:</strong> <a href="${postUrl}" target="_blank" style="color: #1da1f2;">${postUrl}</a><br>
                <strong>Date:</strong> ${postDate}<br>
                <strong>Author:</strong> @${author}<br>
                <strong>Images:</strong> ${imageArray.length}<br>
                <strong>Text Length:</strong> ${text.length} characters
            `;

            previewDiv.classList.remove('hidden');

            // Also log what we're displaying for debugging
            console.log('[X Post] Preview data:', {
                author,
                text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                postUrl,
                postDate,
                imageCount: imageArray.length
            });
        }

        function showXPostStatus(message, type) {
            const statusDiv = document.getElementById('x-post-status');
            statusDiv.className = 'hidden';
            
            if (type === 'error') {
                statusDiv.className = 'error-message';
            } else if (type === 'success') {
                statusDiv.className = 'success-message';
            } else {
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.style.border = '1px solid #2196f3';
            }
            
            // Use innerHTML for rich content (like API setup instructions)
            if (message.includes('<')) {
                statusDiv.innerHTML = message;
            } else {
                statusDiv.textContent = message;
            }
            statusDiv.classList.remove('hidden');
        }

        // YouTube Video Archiving Functions
        async function archiveYouTubeVideo() {
            const url = document.getElementById('youtube-url').value;
            const progressDiv = document.getElementById('youtube-progress');
            const previewDiv = document.getElementById('youtube-preview');
            
            if (!url || (!url.includes('youtube.com') && !url.includes('youtu.be'))) {
                alert('Please enter a valid YouTube URL');
                return;
            }

            try {
                progressDiv.classList.remove('hidden');
                updateYouTubeProgress(10, 'Extracting video metadata...');

                const response = await fetch('/api/scrape/youtube-archive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                
                updateYouTubeProgress(30, 'Downloading video...');

                // Poll for completion
                const checkProgress = async () => {
                    try {
                        const progressResponse = await fetch(`/api/scrape/youtube-progress?taskId=${data.taskId}`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });
                        
                        const progressData = await progressResponse.json();
                        
                        if (progressData.status === 'complete') {
                            displayYouTubePreview(progressData.result);
                            updateYouTubeProgress(100, 'Video archived successfully!');
                            setTimeout(() => progressDiv.classList.add('hidden'), 2000);
                        } else if (progressData.status === 'error') {
                            updateYouTubeProgress(0, `Error: ${progressData.error}`);
                        } else {
                            updateYouTubeProgress(progressData.progress || 50, progressData.message || 'Processing...');
                            setTimeout(checkProgress, 2000);
                        }
                    } catch (error) {
                        updateYouTubeProgress(0, `Error: ${error.message}`);
                    }
                };

                setTimeout(checkProgress, 2000);

            } catch (error) {
                updateYouTubeProgress(0, `Error: ${error.message}`);
            }
        }

        function updateYouTubeProgress(percent, status) {
            document.getElementById('youtube-progress-bar').style.width = `${percent}%`;
            document.getElementById('youtube-status').textContent = status;
        }

        function extractVideoId(url) {
            const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
            return match ? match[1] : null;
        }

        function displayYouTubePreview(data) {
            const previewDiv = document.getElementById('youtube-preview');
            const thumbnailDiv = document.getElementById('youtube-thumbnail');
            const metadataDiv = document.getElementById('youtube-metadata');

            // Store data for publishing
            window.archivedYouTubeData = data;

            // Auto-populate form fields
            document.getElementById('video-title').value = data.title || '';
            document.getElementById('video-description').value = data.description || '';
            document.getElementById('video-channel').value = data.uploader || '';
            document.getElementById('video-duration').value = data.duration ? Math.ceil(data.duration / 60) : '';
            document.getElementById('video-thumbnail').value = data.thumbnail || '';
            
            // Set tags from YouTube tags
            if (data.tags && data.tags.length > 0) {
                document.getElementById('video-tags').value = data.tags.slice(0, 10).join(', ');
            }

            thumbnailDiv.innerHTML = data.thumbnail ? 
                `<img src="${data.thumbnail}" style="max-width: 200px; border-radius: 8px;">` : 
                '<div style="color: #666;">No thumbnail available</div>';

            metadataDiv.innerHTML = `
                <div><strong>Title:</strong> ${data.title || 'Unknown'}</div>
                <div><strong>Channel:</strong> ${data.uploader || 'Unknown'}</div>
                <div><strong>Duration:</strong> ${data.duration ? formatDuration(data.duration) : 'Unknown'}</div>
                <div><strong>Upload Date:</strong> ${data.upload_date || 'Unknown'}</div>
                <div><strong>Views:</strong> ${data.view_count ? data.view_count.toLocaleString() : 'Unknown'}</div>
                <div><strong>Resolution:</strong> ${data.resolution || 'Unknown'}</div>
                <div><strong>Video URL:</strong> <a href="${data.video_url}" target="_blank">Archived Video</a></div>
            `;

            previewDiv.classList.remove('hidden');
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Exercise Resolution for Workouts
        async function resolveWorkoutExercises() {
            const exerciseRows = document.querySelectorAll('.exercise-row');
            const exercises = [];
            const exerciseNames = [];

            exerciseRows.forEach(row => {
                const name = row.querySelector('.exercise-name').value.trim();
                if (name) {
                    exerciseNames.push(name.toLowerCase());
                    exercises.push({
                        name: name,
                        sets: parseInt(row.querySelector('.exercise-sets').value) || 3,
                        reps: row.querySelector('.exercise-reps').value || '12',
                        rest_seconds: parseInt(row.querySelector('.exercise-rest').value) || 60
                    });
                }
            });

            if (exerciseNames.length === 0) {
                throw new Error('Please add at least one exercise');
            }

            // Check if non-standard workout
            const isNonStandard = document.getElementById('workout-non-standard').checked;
            if (isNonStandard) {
                return { exercises, exerciseDidRefs: null };
            }

            try {
                showMessage('publish-status', '🔍 Looking up exercises in database...', 'info');

                // Look up exercises in OIP
                const response = await fetch('/api/workout/resolve-exercises', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ exerciseNames })
                });

                const data = await response.json();

                if (response.ok) {
                    // Update exercise names with DID references where available
                    const resolvedExercises = exercises.map(exercise => {
                        const didRef = data.exerciseDidRefs[exercise.name.toLowerCase()];
                        return {
                            ...exercise,
                            exerciseDidRef: didRef || exercise.name
                        };
                    });

                    const missingCount = Object.values(data.exerciseDidRefs).filter(ref => ref === null).length;
                    if (missingCount > 0) {
                        showMessage('publish-status', `✅ Found ${exerciseNames.length - missingCount} exercises, creating ${missingCount} new ones from Kaggle dataset...`, 'info');
                    } else {
                        showMessage('publish-status', '✅ All exercises found in database!', 'success');
                    }

                    return { exercises: resolvedExercises, exerciseDidRefs: data.exerciseDidRefs };
                } else {
                    throw new Error(data.error || 'Failed to resolve exercises');
                }
            } catch (error) {
                console.error('Exercise resolution error:', error);
                showMessage('publish-status', `⚠️ Exercise lookup failed, publishing with exercise names: ${error.message}`, 'warning');
                return { exercises, exerciseDidRefs: null };
            }
        }

        // Publishing functions for each record type
        async function publishPost() {
            try {
                const postSource = document.getElementById('post-source').value;
                let postData;

                if (postSource === 'archive-x' && window.scrapedXPostData) {
                    // Use scraped X post data
                    postData = {
                        basic: {
                            name: window.scrapedXPostData.text.substring(0, 100) + (window.scrapedXPostData.text.length > 100 ? '...' : ''),
                            description: window.scrapedXPostData.text,
                            language: 'en',
                            date: window.scrapedXPostData.date ? Math.floor(new Date(window.scrapedXPostData.date).getTime() / 1000) : Math.floor(Date.now() / 1000),
                            nsfw: false,
                            tagItems: ['twitter', 'x', 'social-media'],
                            webUrl: window.scrapedXPostData.url // Original X post URL
                        },
                        post: {
                            articleText: window.scrapedXPostData.text,
                            bylineWriter: window.scrapedXPostData.author,
                            webUrl: window.scrapedXPostData.url,
                            imageItems: window.scrapedXPostData.images || [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: [],
                            replyTo: ''
                        }
                    };
                } else if (postSource === 'archive-web' && window.scrapedWebArticleData) {
                    // Use scraped web article data
                    postData = {
                        basic: {
                            name: window.scrapedWebArticleData.title || 'Archived Web Article',
                            description: window.scrapedWebArticleData.description || '',
                            language: 'en',
                            date: window.scrapedWebArticleData.publishDate || Math.floor(Date.now() / 1000),
                            nsfw: false,
                            tagItems: window.scrapedWebArticleData.tags || ['web-article', 'archived'],
                            webUrl: window.scrapedWebArticleData.url // Original article URL
                        },
                        post: {
                            articleText: window.scrapedWebArticleData.content || '',
                            bylineWriter: window.scrapedWebArticleData.byline || '',
                            webUrl: window.scrapedWebArticleData.url,
                            featuredImage: window.scrapedWebArticleData.embeddedImageUrl || '',
                            imageItems: [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: window.scrapedWebArticleData.summaryTTS ? [{
                                audio: {
                                    webUrl: window.scrapedWebArticleData.summaryTTS,
                                    contentType: 'audio/mpeg'
                                }
                            }] : [],
                            audioCaptionItems: [],
                            replyTo: ''
                        }
                    };
                } else {
                    // Use manual form data
                    postData = {
                        basic: {
                            name: document.getElementById('post-title').value,
                            description: document.getElementById('post-description').value,
                            language: 'en',
                            date: Math.floor(Date.now() / 1000),
                            nsfw: document.getElementById('post-nsfw').checked,
                            tagItems: document.getElementById('post-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        post: {
                            articleText: document.getElementById('post-content').value,
                            bylineWriter: document.getElementById('post-author')?.value || '',
                            bylineWritersTitle: document.getElementById('post-author-title')?.value || '',
                            bylineWritersLocation: document.getElementById('post-author-location')?.value || '',
                            webUrl: document.getElementById('post-web-url')?.value || '',
                            featuredImage: document.getElementById('post-featured-image')?.value || '',
                            replyTo: document.getElementById('post-reply-to')?.value || '',
                            imageItems: [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: []
                        }
                    };
                }

                if (!postData.basic.name) {
                    showMessage('publish-status', 'Please provide a title for the post', 'error');
                    return;
                }

                // For archived content, the article may already be published, so just show success
                if (postSource === 'archive-web' && (window.scrapedWebArticleData?.did || window.scrapedWebArticleData?.didTx)) {
                    const did = window.scrapedWebArticleData.did || window.scrapedWebArticleData.didTx;
                    showMessage('publish-success', `Article already archived! DID: ${did}`, 'success');
                    return;
                }

                if (!postData.post.articleText && postSource === 'manual') {
                    showMessage('publish-status', 'Please fill in content', 'error');
                    return;
                }

                // Get storage type and GUN-specific options
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                const isPrivate = document.getElementById('gun-private')?.checked || false;

                // Build request body with storage options
                const requestBody = { ...postData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) {
                        requestBody.localId = localId;
                    }
                    if (isPrivate) {
                        requestBody.accessControl = { private: true };
                    }
                } else {
                    requestBody.blockchain = storageType;
                }

                // Determine endpoint based on storage type
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/publish/newPost';
                const queryParams = storageType === 'gun' ? '?recordType=post' : '';

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Handle different response formats for different storage types
                    let successMessage;
                    if (storageType === 'gun') {
                        successMessage = `Post saved to GUN! DID: ${result.did}${result.encrypted ? ' (Encrypted)' : ''}`;
                    } else {
                        successMessage = `Post published successfully! Transaction ID: ${result.transactionId}`;
                    }
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish post', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishVideo() {
            try {
                const videoSource = document.getElementById('video-source').value;
                let videoData;

                if (videoSource === 'youtube-archive' && window.archivedYouTubeData) {
                    // Use archived YouTube data
                    videoData = {
                        youtubeUrl: window.archivedYouTubeData.original_url || document.getElementById('youtube-url').value,
                        archivedVideoUrl: window.archivedYouTubeData.video_url,
                        thumbnailUrl: window.archivedYouTubeData.thumbnail,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t),
                            webUrl: window.archivedYouTubeData.original_url // Original YouTube URL
                        },
                        videoMetadata: {
                            duration: window.archivedYouTubeData.duration,
                            uploader: window.archivedYouTubeData.uploader,
                            upload_date: window.archivedYouTubeData.upload_date,
                            view_count: window.archivedYouTubeData.view_count,
                            resolution: window.archivedYouTubeData.resolution
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                } else {
                    // Use manual form data
                    videoData = {
                        youtubeUrl: document.getElementById('video-url')?.value,
                        thumbnailUrl: document.getElementById('video-thumbnail')?.value,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        videoMetadata: {
                            duration: document.getElementById('video-duration').value ? parseInt(document.getElementById('video-duration').value) * 60 : null,
                            uploader: document.getElementById('video-channel').value
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                }

                if (!videoData.basicMetadata.name) {
                    showMessage('publish-status', 'Please fill in video title', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newVideo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(videoData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Video published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish video', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishRecipe() {
            try {
                // Collect ingredients
                const ingredientRows = document.querySelectorAll('.ingredient-row');
                const ingredients = [];
                const ingredientAmounts = [];
                const ingredientUnits = [];

                ingredientRows.forEach(row => {
                    const amount = row.querySelector('.ingredient-amount').value;
                    const unit = row.querySelector('.ingredient-unit').value;
                    const name = row.querySelector('.ingredient-name').value;
                    
                    if (name.trim()) {
                        ingredients.push(name);
                        ingredientAmounts.push(parseFloat(amount) || 1);
                        ingredientUnits.push(unit || 'unit');
                    }
                });

                const recipeData = {
                    basic: {
                        name: document.getElementById('recipe-title').value,
                        description: document.getElementById('recipe-description').value,
                        language: 'En',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('recipe-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    recipe: [{
                        prep_time_mins: parseInt(document.getElementById('recipe-prep-time').value) || null,
                        cook_time_mins: parseInt(document.getElementById('recipe-cook-time').value) || null,
                        total_time_mins: (parseInt(document.getElementById('recipe-prep-time').value) || 0) + (parseInt(document.getElementById('recipe-cook-time').value) || 0),
                        servings: parseInt(document.getElementById('recipe-servings').value) || null,
                        ingredient_amount: ingredientAmounts,
                        ingredient_unit: ingredientUnits,
                        ingredient: ingredients,
                        instructions: document.getElementById('recipe-instructions').value,
                        notes: document.getElementById('recipe-notes').value,
                        cuisine: document.getElementById('recipe-cuisine').value,
                        course: document.getElementById('recipe-course').value
                    }],
                    image: {
                        webUrl: document.getElementById('recipe-image').value,
                        contentType: 'image/jpeg'
                    }
                };

                if (!recipeData.basic.name || !recipeData.recipe[0].instructions) {
                    showMessage('publish-status', 'Please fill in recipe name and instructions', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newRecipe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recipeData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Recipe published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish recipe', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishWorkout() {
            try {
                // Resolve exercises first
                const exerciseData = await resolveWorkoutExercises();
                
                const workoutData = {
                    basic: {
                        name: document.getElementById('workout-title').value,
                        description: document.getElementById('workout-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('workout-goals').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    workout: {
                        duration_mins: parseInt(document.getElementById('workout-duration').value) || null,
                        difficulty: document.getElementById('workout-difficulty').value,
                        category: document.getElementById('workout-category').value,
                        equipment_required: document.getElementById('workout-equipment').value.split(',').map(t => t.trim()).filter(t => t),
                        target_muscle_groups: document.getElementById('workout-muscles').value.split(',').map(t => t.trim()).filter(t => t),
                        exercise: exerciseData.exerciseDidRefs ? 
                            exerciseData.exercises.map(ex => ex.exerciseDidRef) : 
                            exerciseData.exercises.map(ex => ex.name),
                        exercise_sets: exerciseData.exercises.map(ex => ex.sets),
                        exercise_reps: exerciseData.exercises.map(ex => ex.reps),
                        exercise_rest_seconds: exerciseData.exercises.map(ex => ex.rest_seconds),
                        notes: document.getElementById('workout-notes').value,
                        non_standard: document.getElementById('workout-non-standard').checked
                    }
                };

                if (!workoutData.basic.name || exerciseData.exercises.length === 0) {
                    showMessage('publish-status', 'Please fill in workout name and add at least one exercise', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newWorkout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(workoutData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Workout published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish workout', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Exercise resolution error: ' + error.message, 'error');
            }
        }

        async function publishExercise() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                const exerciseData = {
                    basic: {
                        name: document.getElementById('exercise-name').value,
                        description: document.getElementById('exercise-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        tagItems: document.getElementById('exercise-tags').value.split(',').map(t => t.trim()).filter(t => t),
                        avatar: document.getElementById('exercise-avatar').value || undefined
                    },
                    exercise: {
                        instructions: document.getElementById('exercise-instructions').value.split('\\n').map(i => i.trim()).filter(i => i),
                        muscleGroups: document.getElementById('exercise-muscle-groups').value.split(',').map(t => t.trim()).filter(t => t),
                        difficulty: document.getElementById('exercise-difficulty').value,
                        category: document.getElementById('exercise-category').value,
                        equipmentRequired: document.getElementById('exercise-equipment').value.split(',').map(t => t.trim()).filter(t => t),
                        alternativeEquipment: document.getElementById('exercise-alternative-equipment').value.split(',').map(t => t.trim()).filter(t => t),
                        isBodyweight: document.getElementById('exercise-bodyweight').checked,
                        exercise_type: document.getElementById('exercise-type').value,
                        measurement_type: document.getElementById('exercise-measurement-type').value,
                        est_duration_minutes: parseInt(document.getElementById('exercise-duration').value) || 8,
                        recommended_sets: parseInt(document.getElementById('exercise-recommended-sets').value) || 3,
                        recommended_reps: parseInt(document.getElementById('exercise-recommended-reps').value) || 10,
                        imageUrl: "",
                        videoUrl: "",
                        gitUrl: ""
                    }
                };

                if (!exerciseData.basic.name || exerciseData.exercise.instructions.length === 0) {
                    showMessage('publish-status', 'Please fill in exercise name and instructions', 'error');
                    return;
                }

                // Get storage type and build URL
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/publish/newExercise';
                const queryParams = storageType === 'gun' ? `?recordType=exercise${localId ? `&localId=${localId}` : ''}` : '';

                const requestBody = { ...exerciseData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) requestBody.localId = localId;
                }

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    const successMessage = storageType === 'gun' 
                        ? `Exercise published to GUN! DID: ${result.did}` 
                        : `Exercise published to Arweave! Transaction ID: ${result.transactionId}`;
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish exercise', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishFitnessEquipment() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                const accessLevel = document.getElementById('equipment-access-level').value;
                
                // Get organization selection if needed
                let selectedOrganizationDid = null;
                if (accessLevel === 'organization') {
                    selectedOrganizationDid = document.getElementById('equipment-organization').value;
                    if (!selectedOrganizationDid) {
                        showMessage('publish-status', 'Please select an organization when using Organization access level', 'error');
                        return;
                    }
                }

                const equipmentData = {
                    basic: {
                        name: document.getElementById('equipment-name').value,
                        description: document.getElementById('equipment-description').value,
                        language: document.getElementById('equipment-language').value,
                        date: Math.floor(Date.now() / 1000),
                        tagItems: document.getElementById('equipment-tags').value.split(',').map(t => t.trim()).filter(t => t),
                        avatar: document.getElementById('equipment-avatar').value || undefined
                    },
                    fitnessEquipment: {
                        category: document.getElementById('equipment-category').value,
                        subcategory: document.getElementById('equipment-subcategory').value,
                        muscle_groups: document.getElementById('equipment-muscle-groups').value.split(',').map(t => t.trim()).filter(t => t),
                        exercise_types: document.getElementById('equipment-exercise-types').value.split(',').map(t => t.trim()).filter(t => t),
                        difficulty_level: document.getElementById('equipment-difficulty').value,
                        space_required: document.getElementById('equipment-space-required').value,
                        portability: document.getElementById('equipment-portability').value,
                        price_range: document.getElementById('equipment-price-range').value,
                        alternatives: document.getElementById('equipment-alternatives').value.split(',').map(t => t.trim()).filter(t => t),
                        maintenance_level: document.getElementById('equipment-maintenance').value,
                        safety_considerations: document.getElementById('equipment-safety').value,
                        beginner_friendly: document.getElementById('equipment-beginner-friendly').checked,
                        home_gym_suitable: document.getElementById('equipment-home-gym').checked,
                        commercial_grade: document.getElementById('equipment-commercial').checked
                    },
                    accessControl: {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID if selected
                    }
                };

                if (!equipmentData.basic.name) {
                    showMessage('publish-status', 'Please fill in equipment name', 'error');
                    return;
                }

                // Get storage type and build URL
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/publish/newFitnessEquipment';
                const queryParams = storageType === 'gun' ? `?recordType=fitnessEquipment${localId ? `&localId=${localId}` : ''}` : '';

                const requestBody = { ...equipmentData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) requestBody.localId = localId;
                }

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    const successMessage = storageType === 'gun' 
                        ? `Equipment published to GUN! DID: ${result.did}` 
                        : `Equipment published to Arweave! Transaction ID: ${result.transactionId}`;
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish equipment', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishMedia() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for media upload. Please set your token first.', 'error');
                    return;
                }

                const fileInput = document.getElementById('media-file');
                const file = fileInput.files[0];
                
                if (!file) {
                    showMessage('publish-status', 'Please select a media file to upload', 'error');
                    return;
                }

                // Determine record type from file MIME type
                const mimeType = file.type;
                let recordType = 'unknown';
                
                if (mimeType.startsWith('image/')) {
                    recordType = 'image';
                } else if (mimeType.startsWith('video/')) {
                    recordType = 'video';
                } else if (mimeType.startsWith('audio/')) {
                    recordType = 'audio';
                } else {
                    showMessage('publish-status', 'Unsupported file type. Please select an image, video, or audio file.', 'error');
                    return;
                }

                // Show upload progress
                const progressDiv = document.getElementById('media-upload-progress');
                const progressFill = progressDiv.querySelector('.progress-fill');
                const progressText = progressDiv.querySelector('.progress-text');
                progressDiv.classList.remove('hidden');
                
                progressText.textContent = 'Uploading file...';
                progressFill.style.width = '10%';

                // Step 1: Upload file to get BitTorrent info and file metadata
                const formData = new FormData();
                formData.append('file', file);
                formData.append('name', document.getElementById('media-name').value || file.name);
                formData.append('access_level', document.getElementById('media-access-level').value);
                
                // Add description if provided
                const description = document.getElementById('media-description').value;
                if (description) {
                    formData.append('description', description);
                }

                const uploadResponse = await fetch('/api/media/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: formData
                });

                progressFill.style.width = '50%';
                progressText.textContent = 'Creating BitTorrent...';

                const uploadResult = await uploadResponse.json();
                
                if (!uploadResponse.ok) {
                    throw new Error(uploadResult.error || 'File upload failed');
                }

                progressFill.style.width = '70%';
                progressText.textContent = 'Creating OIP record...';

                // Step 2: Create proper OIP record based on detected type
                const mediaTitle = document.getElementById('media-name').value || file.name;
                const mediaDescription = document.getElementById('media-description').value || `${recordType.charAt(0).toUpperCase() + recordType.slice(1)} file: ${file.name}`;
                const language = document.getElementById('media-language').value;
                const accessLevel = document.getElementById('media-access-level').value;
                const tags = document.getElementById('media-tags').value.split(',').map(t => t.trim()).filter(t => t);
                const nsfw = document.getElementById('media-nsfw').checked;

                // Get file dimensions for images/videos (we'll need to extract these)
                let width = 0;
                let height = 0;
                let duration = 0;

                // For images and videos, try to get dimensions
                if (recordType === 'image' || recordType === 'video') {
                    try {
                        const dimensions = await getMediaDimensions(file, recordType);
                        width = dimensions.width;
                        height = dimensions.height;
                        if (recordType === 'video') {
                            duration = dimensions.duration || 0;
                        }
                    } catch (error) {
                        console.warn('Could not extract media dimensions:', error);
                    }
                }


                progressFill.style.width = '80%';
                progressText.textContent = 'Creating OIP record...';

                // Get organization selection if needed
                let selectedOrganizationDid = null;
                if (accessLevel === 'organization') {
                    selectedOrganizationDid = document.getElementById('media-organization').value;
                    if (!selectedOrganizationDid) {
                        throw new Error('Please select an organization when using Organization access level');
                    }
                }

                // Step 3: Create proper OIP record using the new media endpoint
                const recordData = {
                    mediaId: uploadResult.mediaId,
                    recordType: recordType,
                    basicInfo: {
                        name: mediaTitle,
                        description: mediaDescription,
                        language: language,
                        nsfw: nsfw,
                        tagItems: tags
                    },
                    accessControl: {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID goes in shared_with field
                    },
                    width: width,
                    height: height,
                    duration: duration
                };

                const recordResponse = await fetch('/api/media/createRecord', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recordData)
                });

                const recordResult = await recordResponse.json();

                if (!recordResponse.ok) {
                    throw new Error(recordResult.error || 'Failed to create OIP record');
                }

                progressFill.style.width = '100%';
                progressText.textContent = 'Upload complete!';
                
                showMessage('publish-success', 
                    `${recordType.charAt(0).toUpperCase() + recordType.slice(1)} published successfully!\\n` +
                    `Record Type: ${recordType}\\n` +
                    `DID: ${recordResult.did}\\n` +
                    `Media ID: ${uploadResult.mediaId}\\n` +
                    `Size: ${(file.size / 1024).toFixed(1)} KB\\n` +
                    `BitTorrent: ${uploadResult.magnetURI ? 'Enabled' : 'Failed'}`, 'success');
                
                // Show media preview with both upload and record info
                showMediaPreview({
                    ...uploadResult,
                    recordType: recordType,
                    recordDid: recordResult.did,
                    dimensions: { width, height, duration }
                });
                
                // Clear form after delay
                setTimeout(() => {
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                }, 3000);

            } catch (error) {
                console.error('Media publishing error:', error);
                const progressDiv = document.getElementById('media-upload-progress');
                const progressFill = progressDiv.querySelector('.progress-fill');
                const progressText = progressDiv.querySelector('.progress-text');
                progressFill.style.width = '0%';
                progressText.textContent = 'Upload failed';
                showMessage('publish-status', 'Error: ' + error.message, 'error');
            }
        }

        // Helper function to extract media dimensions
        async function getMediaDimensions(file, recordType) {
            return new Promise((resolve) => {
                if (recordType === 'image') {
                    const img = new Image();
                    img.onload = () => {
                        resolve({ width: img.width, height: img.height });
                    };
                    img.onerror = () => {
                        resolve({ width: 0, height: 0 });
                    };
                    img.src = URL.createObjectURL(file);
                } else if (recordType === 'video') {
                    const video = document.createElement('video');
                    video.onloadedmetadata = () => {
                        resolve({ 
                            width: video.videoWidth, 
                            height: video.videoHeight,
                            duration: Math.floor(video.duration) || 0
                        });
                    };
                    video.onerror = () => {
                        resolve({ width: 0, height: 0, duration: 0 });
                    };
                    video.src = URL.createObjectURL(file);
                } else {
                    resolve({ width: 0, height: 0, duration: 0 });
                }
            });
        }

        // Organization management for media publishing
        let availableOrganizations = [];

        async function loadOrganizations() {
            try {
                console.log('📋 Loading organizations...');
                const response = await fetch('/api/organizations', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    availableOrganizations = data.organizationsInDB || [];
                    console.log(`✅ Loaded ${availableOrganizations.length} organizations`);
                    updateOrganizationDropdown();
                    updateGifOrganizationDropdown(); // Also update GIF dropdown
                    updateEquipmentOrganizationDropdown(); // Also update Equipment dropdown
                } else {
                    console.warn('⚠️ Failed to load organizations:', response.status);
                    updateOrganizationDropdown(); // Show empty state
                    updateGifOrganizationDropdown(); // Show empty state
                    updateEquipmentOrganizationDropdown(); // Show empty state
                }
            } catch (error) {
                console.error('❌ Error loading organizations:', error);
                updateOrganizationDropdown(); // Show error state
                updateGifOrganizationDropdown(); // Show error state
                updateEquipmentOrganizationDropdown(); // Show error state
            }
        }

        function updateOrganizationDropdown() {
            const orgSelect = document.getElementById('media-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function updateMediaAccessLevel() {
            const accessLevel = document.getElementById('media-access-level').value;
            const orgSelection = document.getElementById('media-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
            } else {
                orgSelection.style.display = 'none';
            }
        }

        // Helper function to detect file type and update UI
        function updateMediaFilePreview() {
            const fileInput = document.getElementById('media-file');
            const detectedTypeDiv = document.getElementById('detected-file-type');
            const typeDisplay = document.getElementById('detected-type-display');
            const typeDescription = document.getElementById('detected-type-description');
            
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const mimeType = file.type;
                let recordType = 'unknown';
                let description = '';
                
                if (mimeType.startsWith('image/')) {
                    recordType = 'image';
                    description = 'Will create an OIP image record with BitTorrent distribution';
                } else if (mimeType.startsWith('video/')) {
                    recordType = 'video';
                    description = 'Will create an OIP video record with BitTorrent distribution and streaming support';
                } else if (mimeType.startsWith('audio/')) {
                    recordType = 'audio';
                    description = 'Will create an OIP audio record with BitTorrent distribution and streaming support';
                } else {
                    recordType = 'unknown';
                    description = 'Unsupported file type - please select an image, video, or audio file';
                }
                
                typeDisplay.textContent = `${recordType.toUpperCase()} Record`;
                typeDescription.textContent = description;
                detectedTypeDiv.classList.remove('hidden');
                
                // Auto-populate name if empty
                const nameInput = document.getElementById('media-name');
                if (!nameInput.value) {
                    // Use filename without extension as default name
                    const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
                    nameInput.value = nameWithoutExt;
                }
            } else {
                detectedTypeDiv.classList.add('hidden');
            }
        }

        function showMediaPreview(mediaResult) {
            const previewDiv = document.getElementById('media-preview');
            const previewContent = document.getElementById('media-preview-content');
            const mediaInfo = document.getElementById('media-info');
            
            previewDiv.classList.remove('hidden');
            
            // Create preview based on MIME type
            const httpUrl = mediaResult.httpUrl || (mediaResult.transport && mediaResult.transport.http && mediaResult.transport.http[0]);
            
            if (mediaResult.mime.startsWith('image/')) {
                previewContent.innerHTML = `<img src="${httpUrl}" style="max-width: 100%; max-height: 200px; border-radius: 4px;" onerror="this.style.display='none';">`;
            } else if (mediaResult.mime.startsWith('video/')) {
                previewContent.innerHTML = `<video controls style="max-width: 100%; max-height: 200px; border-radius: 4px;">
                    <source src="${httpUrl}" type="${mediaResult.mime}">
                    Your browser does not support video playback.
                </video>`;
            } else if (mediaResult.mime.startsWith('audio/')) {
                previewContent.innerHTML = `<audio controls style="width: 100%;">
                    <source src="${httpUrl}" type="${mediaResult.mime}">
                    Your browser does not support audio playback.
                </audio>`;
            } else {
                previewContent.innerHTML = `<div style="padding: 20px; text-align: center; background: #f0f0f0; border-radius: 4px;">
                    📄 ${mediaResult.originalName}
                </div>`;
            }
            
            // Build info display
            let infoHtml = `
                <strong>Media ID:</strong> ${mediaResult.mediaId}<br>
                <strong>Size:</strong> ${(mediaResult.size / 1024).toFixed(1)} KB<br>
                <strong>MIME:</strong> ${mediaResult.mime}<br>
                <strong>Access:</strong> ${mediaResult.access_level}<br>
                <strong>BitTorrent:</strong> ${mediaResult.magnetURI ? 'Available' : 'Not available'}
            `;
            
            // Add record-specific info if available
            if (mediaResult.recordType && mediaResult.recordDid) {
                infoHtml += `<br><strong>Record Type:</strong> ${mediaResult.recordType}`;
                infoHtml += `<br><strong>OIP DID:</strong> ${mediaResult.recordDid}`;
                
                // Add dimensions if available
                if (mediaResult.dimensions) {
                    if (mediaResult.dimensions.width && mediaResult.dimensions.height) {
                        infoHtml += `<br><strong>Dimensions:</strong> ${mediaResult.dimensions.width}x${mediaResult.dimensions.height}`;
                    }
                    if (mediaResult.dimensions.duration) {
                        infoHtml += `<br><strong>Duration:</strong> ${mediaResult.dimensions.duration}s`;
                    }
                }
            }
            
            mediaInfo.innerHTML = infoHtml;
        }

        async function publishMultiResolutionGif() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                const collectionName = document.getElementById('gif-collection-name').value;
                if (!collectionName) {
                    showMessage('publish-status', 'Please fill in collection name', 'error');
                    return;
                }

                const inputMethod = document.getElementById('gif-input-method').value;
                const accessLevel = document.getElementById('gif-access-level').value;
                
                // Get organization selection if needed
                let selectedOrganizationDid = null;
                if (accessLevel === 'organization') {
                    selectedOrganizationDid = document.getElementById('gif-organization').value;
                    if (!selectedOrganizationDid) {
                        showMessage('publish-status', 'Please select an organization when using Organization access level', 'error');
                        return;
                    }
                }

                let gifRefs = [];
                let resolutionLabels = [];
                let fileSizes = [];
                let widths = [];
                let heights = [];

                // Update button text
                const publishBtn = document.getElementById('gif-publish-text');
                const originalBtnText = publishBtn.textContent;

                if (inputMethod === 'upload') {
                    // Upload mode: Upload files and create image records first
                    publishBtn.textContent = '📤 Uploading GIF Files...';
                    showMessage('publish-status', 'Uploading GIF files and creating image records...', 'info');
                    
                    const fileRows = document.querySelectorAll('.gif-file-row');
                    const uploadTasks = [];
                    
                    for (const row of fileRows) {
                        const fileInput = row.querySelector('.gif-file-input');
                        const file = fileInput.files[0];
                        const label = row.querySelector('.gif-resolution-label').value.trim();
                        const width = parseInt(row.querySelector('.gif-width').value) || 0;
                        const height = parseInt(row.querySelector('.gif-height').value) || 0;
                        
                        if (file && label) {
                            uploadTasks.push({
                                file: file,
                                label: label,
                                width: width,
                                height: height,
                                row: row
                            });
                        }
                    }

                    if (uploadTasks.length === 0) {
                        showMessage('publish-status', 'Please select at least one GIF file', 'error');
                        return;
                    }

                    // Upload each GIF file and create image records
                    for (let i = 0; i < uploadTasks.length; i++) {
                        const task = uploadTasks[i];
                        const progress = Math.floor((i / uploadTasks.length) * 50); // First 50% for uploads
                        
                        publishBtn.textContent = `📤 Uploading ${task.file.name} (${i + 1}/${uploadTasks.length})...`;
                        showMessage('publish-status', `Uploading ${task.file.name} (${i + 1}/${uploadTasks.length})...`, 'info');
                        
                        try {
                            // Step 1: Upload file
                            const formData = new FormData();
                            formData.append('file', task.file);
                            formData.append('name', `${collectionName} - ${task.label}`);
                            formData.append('access_level', 'private');
                            formData.append('description', `GIF resolution: ${task.label}`);

                            const uploadResponse = await fetch('/api/media/upload', {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: formData
                            });

                            const uploadResult = await uploadResponse.json();
                            if (!uploadResponse.ok) {
                                throw new Error(`Upload failed: ${uploadResult.error}`);
                            }

                            // Step 2: Create image record
                            const recordData = {
                                mediaId: uploadResult.mediaId,
                                recordType: 'image',
                                basicInfo: {
                                    name: `${collectionName} - ${task.label}`,
                                    description: `GIF resolution: ${task.label}`,
                                    language: 'en',
                                    nsfw: false,
                                    tagItems: ['gif', 'multi-resolution', task.label]
                                },
                                accessControl: {
                                    access_level: accessLevel,
                                    shared_with: selectedOrganizationDid // Organization's DID if selected
                                },
                                width: task.width,
                                height: task.height,
                                duration: 0
                            };

                            const recordResponse = await fetch('/api/media/createRecord', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify(recordData)
                            });

                            const recordResult = await recordResponse.json();
                            if (!recordResponse.ok) {
                                throw new Error(`Record creation failed: ${recordResult.error}`);
                            }

                            // Store the results
                            gifRefs.push(recordResult.did);
                            resolutionLabels.push(task.label);
                            fileSizes.push(task.file.size);
                            widths.push(task.width);
                            heights.push(task.height);

                            console.log(`✅ Created image record for ${task.label}: ${recordResult.did}`);
                            
                        } catch (error) {
                            showMessage('publish-status', `Error uploading ${task.file.name}: ${error.message}`, 'error');
                            return;
                        }
                    }
                    
                } else {
                    // Manual mode: Collect existing DIDs
                    const refRows = document.querySelectorAll('.gif-ref-row');
                    refRows.forEach(row => {
                        const did = row.querySelector('.gif-media-did').value.trim();
                        const label = row.querySelector('.gif-resolution-label').value.trim();
                        const width = parseInt(row.querySelector('.gif-width').value) || 0;
                        const height = parseInt(row.querySelector('.gif-height').value) || 0;
                        
                        if (did && label) {
                            gifRefs.push(did);
                            resolutionLabels.push(label);
                            widths.push(width);
                            heights.push(height);
                            fileSizes.push(0); // Unknown for manual DIDs
                        }
                    });

                    if (gifRefs.length === 0) {
                        showMessage('publish-status', 'Please add at least one GIF media reference', 'error');
                        return;
                    }
                }

                // Create the multiResolutionGif record
                publishBtn.textContent = '📋 Creating Collection Record...';
                showMessage('publish-status', 'Creating multi-resolution GIF collection record...', 'info');

                const gifData = {
                    basic: {
                        name: collectionName,
                        description: document.getElementById('gif-collection-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        tagItems: document.getElementById('gif-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    multiResolutionGif: {
                        gif_media_refs: gifRefs,
                        resolution_labels: resolutionLabels,
                        file_sizes: fileSizes,
                        resolution_widths: widths,
                        resolution_heights: heights,
                        primary_resolution_index: parseInt(document.getElementById('gif-primary-index').value) || 1,
                        loop_count: parseInt(document.getElementById('gif-loop-count').value) || 0,
                        frame_rate: parseInt(document.getElementById('gif-frame-rate').value) || 15,
                        duration_seconds: parseFloat(document.getElementById('gif-duration').value) || 8.5
                    },
                    accessControl: {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID if selected
                    }
                };

                // Always publish to GUN for multi-resolution GIF collections
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                const queryParams = `?recordType=multiResolutionGif${localId ? `&localId=${localId}` : ''}`;

                const requestBody = { ...gifData };
                requestBody.storage = 'gun';
                if (localId) requestBody.localId = localId;

                const response = await fetch(`/api/records/newRecord${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    publishBtn.textContent = '✅ Published Successfully!';
                    showMessage('publish-success', 
                        `GIF collection published successfully!\\n` +
                        `Collection DID: ${result.did}\\n` +
                        `Image Records: ${gifRefs.length}\\n` +
                        `Method: ${inputMethod === 'upload' ? 'File Upload' : 'Manual DID Entry'}`, 'success');
                    
                    // Clear form after delay
                    setTimeout(() => {
                        document.getElementById('publish-record-type').value = '';
                        loadPublishInterface();
                    }, 3000);
                } else {
                    publishBtn.textContent = originalBtnText;
                    showMessage('publish-status', result.error || 'Failed to publish GIF collection', 'error');
                }
            } catch (error) {
                publishBtn.textContent = originalBtnText;
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Multi-Resolution GIF management functions
        function updateGifInputMethod() {
            const method = document.getElementById('gif-input-method').value;
            const uploadInterface = document.getElementById('gif-upload-interface');
            const manualInterface = document.getElementById('gif-manual-interface');
            
            if (method === 'upload') {
                uploadInterface.classList.remove('hidden');
                manualInterface.classList.add('hidden');
            } else {
                uploadInterface.classList.add('hidden');
                manualInterface.classList.remove('hidden');
            }
        }

        function updateGifAccessLevel() {
            const accessLevel = document.getElementById('gif-access-level').value;
            const orgSelection = document.getElementById('gif-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
                // Update the GIF organization dropdown
                updateGifOrganizationDropdown();
            } else {
                orgSelection.style.display = 'none';
            }
        }

        function updateGifOrganizationDropdown() {
            const orgSelect = document.getElementById('gif-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function updateEquipmentAccessLevel() {
            const accessLevel = document.getElementById('equipment-access-level').value;
            const orgSelection = document.getElementById('equipment-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
                // Update the equipment organization dropdown
                updateEquipmentOrganizationDropdown();
            } else {
                orgSelection.style.display = 'none';
            }
        }

        function updateEquipmentOrganizationDropdown() {
            const orgSelect = document.getElementById('equipment-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function addGifFileRow() {
            const container = document.getElementById('gif-files-container');
            const newRow = document.createElement('div');
            newRow.className = 'gif-file-row';
            newRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 40px; gap: 10px; margin-bottom: 10px; align-items: end; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fafafa;';
            
            newRow.innerHTML = `
                <div>
                    <input type="file" class="gif-file-input" accept="image/gif" onchange="updateGifFileInfo(this)">
                </div>
                <div>
                    <input type="text" class="gif-resolution-label" placeholder="360p">
                </div>
                <div>
                    <input type="number" class="gif-width" placeholder="640">
                </div>
                <div>
                    <input type="number" class="gif-height" placeholder="360">
                </div>
                <button type="button" onclick="removeGifFileRow(this)" class="btn-small btn-secondary" title="Remove this resolution">-</button>
            `;
            
            container.appendChild(newRow);
        }

        function removeGifFileRow(button) {
            const row = button.closest('.gif-file-row');
            if (document.querySelectorAll('.gif-file-row').length > 1) {
                row.remove();
            }
        }

        async function updateGifFileInfo(fileInput) {
            const row = fileInput.closest('.gif-file-row');
            const file = fileInput.files[0];
            
            if (file && file.type === 'image/gif') {
                try {
                    // Auto-detect dimensions
                    const dimensions = await getMediaDimensions(file, 'image');
                    
                    // Auto-populate fields
                    const widthInput = row.querySelector('.gif-width');
                    const heightInput = row.querySelector('.gif-height');
                    const labelInput = row.querySelector('.gif-resolution-label');
                    
                    if (dimensions.width && dimensions.height) {
                        widthInput.value = dimensions.width;
                        heightInput.value = dimensions.height;
                        
                        // Auto-generate resolution label if empty
                        if (!labelInput.value) {
                            labelInput.value = `${dimensions.height}p`;
                        }
                    }
                    
                    console.log(`📐 Auto-detected GIF dimensions: ${dimensions.width}x${dimensions.height}`);
                } catch (error) {
                    console.warn('Could not auto-detect GIF dimensions:', error);
                }
            }
        }

        // Helper function to add GIF references dynamically
        function addGifReference() {
            const container = document.getElementById('gif-refs-container');
            const newRow = document.createElement('div');
            newRow.className = 'gif-ref-row';
            newRow.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: end;';
            
            newRow.innerHTML = `
                <div style="flex: 2;">
                    <input type="text" class="gif-media-did" placeholder="did:gun:media:...">
                </div>
                <div style="flex: 1;">
                    <input type="text" class="gif-resolution-label" placeholder="360p">
                </div>
                <div style="flex: 1;">
                    <input type="number" class="gif-width" placeholder="640">
                </div>
                <div style="flex: 1;">
                    <input type="number" class="gif-height" placeholder="360">
                </div>
                <button type="button" onclick="removeGifReference(this)" class="btn-small btn-secondary">-</button>
            `;
            
            container.appendChild(newRow);
        }

        function removeGifReference(button) {
            const row = button.closest('.gif-ref-row');
            if (document.querySelectorAll('.gif-ref-row').length > 1) {
                row.remove();
            }
        }

        async function publishOrganization() {
            try {
                // Check for token in either location
                const token = authToken || localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
                
                if (!token) {
                    showMessage('publish-status', 'JWT token required for organization registration. Please log in first.', 'error');
                    return;
                }

                // Extract user public key from JWT token
                let userPublicKey;
                try {
                    const parts = token.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        userPublicKey = payload.publicKey;
                        
                        if (!userPublicKey) {
                            throw new Error('Public key not found in JWT token');
                        }
                        
                        // Ensure authToken is set for the API call
                        authToken = token;
                    } else {
                        throw new Error('Invalid JWT format');
                    }
                } catch (jwtError) {
                    showMessage('publish-status', 'Error reading authentication token: ' + jwtError.message, 'error');
                    return;
                }

                // Collect form data
                const orgName = document.getElementById('org-name').value.trim();
                const orgDescription = document.getElementById('org-description').value.trim();
                const orgHandle = document.getElementById('org-handle').value.trim();
                const orgLanguage = document.getElementById('org-language').value;
                const orgWebUrl = document.getElementById('org-web-url').value.trim();
                const membershipPolicy = document.getElementById('org-membership-policy').value;

                // Validation
                if (!orgName) {
                    showMessage('publish-status', 'Please fill in organization name', 'error');
                    return;
                }
                if (!orgDescription) {
                    showMessage('publish-status', 'Please fill in organization description', 'error');
                    return;
                }
                if (!orgHandle) {
                    showMessage('publish-status', 'Please fill in organization handle', 'error');
                    return;
                }
                if (!membershipPolicy) {
                    showMessage('publish-status', 'Please select a membership policy', 'error');
                    return;
                }

                // Validate handle format (lowercase, numbers, hyphens only)
                const handleRegex = /^[a-z0-9-]+$/;
                if (!handleRegex.test(orgHandle)) {
                    showMessage('publish-status', 'Organization handle must contain only lowercase letters, numbers, and hyphens', 'error');
                    return;
                }

                // Build organization record data
                const organizationData = {
                    basic: {
                        name: orgName,
                        description: orgDescription,
                        language: orgLanguage,
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        webUrl: orgWebUrl || undefined
                    },
                    organization: {
                        org_handle: orgHandle,
                        org_public_key: userPublicKey,
                        admin_public_keys: userPublicKey, // Initially, creator is the only admin
                        membership_policy: membershipPolicy
                    }
                };

                // Get storage type and GUN-specific options
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || orgHandle; // Use org handle as default localId
                const isPrivate = document.getElementById('gun-private')?.checked || false;

                // Build request body with storage options
                const requestBody = { ...organizationData };
                
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) {
                        requestBody.localId = localId;
                    }
                    if (isPrivate) {
                        requestBody.accessControl = { 
                            access_level: 'private',
                            owner_public_key: userPublicKey,
                            created_by: userPublicKey
                        };
                    } else {
                        requestBody.accessControl = { 
                            access_level: 'organization',
                            owner_public_key: userPublicKey,
                            created_by: userPublicKey
                        };
                    }
                } else {
                    requestBody.blockchain = storageType;
                }

                // Determine endpoint based on storage type
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/organizations/newOrganization';
                const queryParams = storageType === 'gun' ? `?recordType=organization${localId ? `&localId=${localId}` : ''}` : '';

                console.log('[Organization] Publishing with data:', requestBody);
                console.log('[Organization] Using endpoint:', endpoint + queryParams);

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Handle different response formats for different storage types
                    let successMessage;
                    if (storageType === 'gun') {
                        successMessage = `Organization registered in GUN! DID: ${result.did}${result.encrypted ? ' (Encrypted)' : ''}`;
                    } else {
                        successMessage = `Organization registered successfully! Transaction ID: ${result.transactionId}`;
                    }
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to register organization', 'error');
                }
            } catch (error) {
                console.error('[Organization] Publishing error:', error);
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Initialize storage type handler for GUN options
        function initializeStorageTypeHandler() {
            const storageSelect = document.getElementById('publish-storage-type');
            const gunOptions = document.getElementById('gun-options');
            
            if (storageSelect && gunOptions) {
                // Add event listener for storage type changes
                storageSelect.addEventListener('change', function() {
                    const selectedStorage = this.value;
                    
                    if (selectedStorage === 'gun') {
                        gunOptions.style.display = 'block';
                    } else {
                        gunOptions.style.display = 'none';
                    }
                });
                
                // Initialize visibility based on current selection
                const currentStorage = storageSelect.value;
                gunOptions.style.display = currentStorage === 'gun' ? 'block' : 'none';
            }
            
            // If organization interface is loaded, populate public key fields
            populateOrganizationPublicKeys();
        }

        // Populate organization public key fields from JWT token
        function populateOrganizationPublicKeys() {
            const orgPubKeyDisplay = document.getElementById('org-public-key-display');
            const orgAdminKeyDisplay = document.getElementById('org-admin-key-display');
            
            if (orgPubKeyDisplay && orgAdminKeyDisplay) {
                // Check for token in either location
                const token = authToken || localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
                
                if (token) {
                    try {
                        // Decode JWT to get user's public key
                        const parts = token.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            const userPublicKey = payload.publicKey;
                            
                            if (userPublicKey) {
                                orgPubKeyDisplay.textContent = userPublicKey;
                                orgAdminKeyDisplay.textContent = userPublicKey;
                                console.log('[Organization] Populated public keys from JWT:', userPublicKey.slice(0, 20) + '...');
                            } else {
                                orgPubKeyDisplay.textContent = 'Public key not found in JWT';
                                orgAdminKeyDisplay.textContent = 'Public key not found in JWT';
                                console.error('[Organization] No publicKey field in JWT payload:', payload);
                            }
                        } else {
                            orgPubKeyDisplay.textContent = 'Invalid JWT format';
                            orgAdminKeyDisplay.textContent = 'Invalid JWT format';
                        }
                    } catch (error) {
                        console.error('Error parsing JWT for organization keys:', error);
                        orgPubKeyDisplay.textContent = 'Error parsing JWT';
                        orgAdminKeyDisplay.textContent = 'Error parsing JWT';
                    }
                } else {
                    orgPubKeyDisplay.textContent = 'Please log in to see your public key';
                    orgAdminKeyDisplay.textContent = 'Please log in to see your public key';
                }
            }
        }

        // Helper functions
        function previewImage() {
            const imageUrl = document.getElementById('image-url').value;
            const previewContainer = document.getElementById('image-preview');
            const previewImg = document.getElementById('preview-img');
            
            if (imageUrl) {
                previewImg.src = imageUrl;
                previewContainer.classList.remove('hidden');
            }
        }

    </script>
</body>
</html> 