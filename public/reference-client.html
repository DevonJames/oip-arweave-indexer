<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OIP Explorer - Browse & Publish Records</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 2rem;
            font-weight: bold;
        }

        .nav-tabs {
            display: flex;
            gap: 20px;
        }

        .nav-tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .nav-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .nav-tab.active {
            background: white;
            color: #667eea;
            border-color: white;
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .filters-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .filters-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .filter-group.wide {
            flex: 2;
            min-width: 200px;
        }

        .search-container {
            flex: 3;
            min-width: 300px;
        }

        .records-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 600px;
        }

        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .record-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
            transition: all 0.3s ease;
        }

        .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-type {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .record-block {
            color: #666;
            font-size: 0.9rem;
        }

        .record-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .record-content {
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .record-meta {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.8rem;
            color: #999;
        }

        .tags-container {
            margin-top: 10px;
        }

        .tag {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin: 2px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag:hover {
            background: #667eea;
            color: white;
        }

        /* Media content styling */
        .media-content {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .media-item {
            margin: 10px 0;
        }

        .media-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .media-item img:hover {
            transform: scale(1.02);
        }

        .media-item audio,
        .media-item video {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .media-item button {
            transition: all 0.2s;
        }

        .media-item button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .text-content {
            border: 1px solid #dee2e6;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .media-item label {
            color: #495057;
            font-size: 14px;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 28px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .logged-in-user {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            font-size: 14px;
        }

        .dynamic-fields {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background: white;
        }

        .field-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .field-row > div {
            flex: 1;
        }

        .field-row button {
            margin: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .date-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-inputs input {
            flex: 1;
        }

        .advanced-filters {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .toggle-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .load-more {
            text-align: center;
            margin: 20px 0;
        }

        .no-results {
            text-align: center;
            color: #999;
        }

        /* Master Audio Player */
        .master-audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .master-audio-player.visible {
            transform: translateY(0);
        }

        .audio-player-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .audio-info {
            flex: 1;
            min-width: 0;
        }

        .audio-title {
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .audio-meta {
            font-size: 12px;
            opacity: 0.8;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .audio-controls button:hover {
            background: rgba(255,255,255,0.3);
            transform: none;
            box-shadow: none;
        }

        .audio-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        .audio-progress-bar {
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .audio-time {
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .record-card .audio-play-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .record-card .audio-play-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .record-card .audio-play-btn.playing {
            background: #dc3545;
        }

        .record-card .audio-play-btn.playing:hover {
            background: #c82333;
        }

        .text-content-preview {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .toggle-text-btn {
            background: #17a2b8;
            font-size: 12px;
            padding: 4px 8px;
        }

        .toggle-text-btn:hover {
            background: #138496;
        }

        .record-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .record-image:hover {
            transform: scale(1.02);
        }

        /* Ensure body has padding for fixed audio player */
        body {
            margin-bottom: 80px;
        }

        /* AI Chat Integration Styles */
        .ai-chat-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .chat-header {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 15px;
        }

        .chat-conversation {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            min-height: 300px;
            max-height: 400px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .chat-message .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .message-avatar {
            background: rgba(59, 130, 246, 0.8);
        }

        .chat-message.assistant .message-avatar {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-avatar {
            background: rgba(239, 68, 68, 0.8);
        }

        .message-content {
            flex: 1;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            position: relative;
        }

        .chat-message.user .message-content {
            background: rgba(59, 130, 246, 0.8);
            margin-left: auto;
        }

        .chat-message.assistant .message-content {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-content {
            background: rgba(239, 68, 68, 0.8);
            font-style: italic;
        }

        .message-text {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.8;
        }

        .message-timestamp {
            font-size: 11px;
            opacity: 0.7;
        }

        .mic-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mic-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .mic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .mic-btn.recording {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(239, 68, 68, 1);
            animation: pulse 1.5s infinite;
        }

        .mic-btn.listening {
            background: rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 1);
            animation: pulse 2s infinite;
        }

        .mic-btn.transcribing {
            background: rgba(59, 130, 246, 0.8);
            border-color: rgba(59, 130, 246, 1);
            animation: spin 1s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .message-sources {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
        }

        .source-count {
            font-weight: bold;
        }

        .chat-input-container {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 10px;
        }

        #ai-chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-height: 44px;
            resize: vertical;
            max-height: 120px;
        }

        #ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #ai-chat-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .chat-send-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(10px);
            height: 44px;
        }

        .chat-send-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-status {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            backdrop-filter: blur(10px);
            opacity: 0.9;
            font-size: 12px;
        }

        .chat-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            opacity: 0.8;
        }

        .chat-empty-state .emoji {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .chat-empty-state h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .chat-empty-state p {
            font-size: 14px;
            opacity: 0.8;
        }

        .ai-settings {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .ai-setting {
            flex: 1;
            min-width: 200px;
        }

        .ai-setting label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }

        .ai-setting select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .applied-filters {
            background: rgba(59, 130, 246, 0.15);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .filter-chip {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 16px;
            margin: 4px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .conversation-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .conversation-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .conversation-message.user {
            background: rgba(59, 130, 246, 0.3);
            margin-left: 20px;
        }

        .conversation-message.assistant {
            background: rgba(34, 197, 94, 0.3);
            margin-right: 20px;
        }

        .conversation-message .timestamp {
            font-size: 11px;
            opacity: 0.7;
            display: block;
            margin-top: 4px;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots:after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Microphone icon styles */
        .microphone-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .pagination-info {
            text-align: center;
            color: #666;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-tabs {
                order: -1;
            }
            
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group,
            .filter-group.wide,
            .search-container {
                min-width: auto;
                flex: none;
            }
            
            .records-grid {
                grid-template-columns: 1fr;
            }
            
            .field-row {
                flex-direction: column;
                gap: 5px;
            }
            
            .date-inputs {
                flex-direction: column;
            }
            
            .toggle-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            /* Mobile adjustments for chat */
            .ai-chat-section {
                height: 500px;
                padding: 15px;
            }
            
            .ai-settings {
                flex-direction: column;
                gap: 10px;
            }
            
            .ai-setting {
                display: block !important;
                margin-right: 0 !important;
            }
            
            .chat-input-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .chat-send-btn {
                width: 100%;
            }
            
            .message-content {
                max-width: 95%;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo">OIP Explorer</div>
            
            <div class="nav-tabs">
                <!-- <div class="nav-tab active" onclick="showBrowseTab()">Browse Records</div> -->
                <div class="nav-tab active" onclick="showVoiceBrowseTab()">Browse</div>
                <div class="nav-tab" onclick="showPublishTab()">Publish</div>
            </div>
            
            <div class="auth-section">
                <div id="user-info" class="hidden">
                    <span id="logged-in-display" class="logged-in-user"></span>
                    <button onclick="logout()" class="btn-secondary btn-small">Logout</button>
                </div>
                <div id="auth-buttons">
                    <button onclick="showAuthModal()" class="btn-small">Login / Register</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">


        <!-- Browse + Voice Chat Tab Content -->
        <div id="voice-browse-tab">
            <!-- AI Chat Section -->
            <div class="ai-chat-section">
                <div class="chat-header">
                    <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                        <span>🤖</span> AI Assistant
                    </h3>
                    
                    <div class="ai-settings" style="margin-top: 15px;">
                        <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                            <label for="ai-model-select">AI Model</label>
                            <select id="ai-model-select">
                                <option value="llama3.2:3b">LLaMA 3.2 3B (Fast)</option>
                                <option value="mistral:latest">Mistral 7B (Balanced)</option>
                                <option value="llama2:latest">LLaMA 2 7B (Quality)</option>
                                <option value="tinyllama:latest">TinyLlama (Ultra Fast)</option>
                            </select>
                        </div>
                        <div class="ai-setting" style="display: inline-block;">
                            <label for="stt-language">Speech Language</label>
                            <select id="stt-language">
                                <option value="auto">Auto-detect</option>
                                <option value="en">English</option>
                                <option value="es">Spanish</option>
                                <option value="fr">French</option>
                                <option value="de">German</option>
                                <option value="it">Italian</option>
                                <option value="pt">Portuguese</option>
                            </select>
                        </div>
                    </div>

                    <div id="applied-filters-display" class="applied-filters hidden" style="margin-top: 15px; background: rgba(59, 130, 246, 0.2); border: 2px solid rgba(59, 130, 246, 0.5); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                        <div style="margin-bottom: 8px; font-weight: bold; color: #1e40af; background: rgba(255, 255, 255, 0.8); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(30, 64, 175, 0.3);">🔍 AI Applied Filters:</div>
                        <div id="filter-chips-container"></div>
                        <div id="filter-rationale" style="margin-top: 8px; font-size: 12px; color: #374151; opacity: 0.9;"></div>
                    </div>
                </div>
                
                <div id="chat-conversation" class="chat-conversation">
                    <div id="chat-empty-state" class="chat-empty-state">
                        <div class="emoji">💬</div>
                        <h3>Start a conversation</h3>
                        <p>Ask questions about your data and I'll help you find answers!</p>
                    </div>
                    <div id="chat-messages"></div>
                </div>

                <div class="chat-input-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="ai-status" id="ai-status" style="flex: 1; margin-bottom: 0; margin-right: 10px;">
                            <div id="ai-status-text">Ready to answer questions!</div>
                        </div>
                        <button onclick="clearConversation()" class="btn-secondary btn-small" style="background: #6b7280; border: 1px solid #9ca3af; color: white; margin: 0;">
                            Clear Chat
                        </button>
                    </div>
                    
                    <div class="chat-input-row">
                        <button id="mic-btn" onclick="toggleRecording()" class="mic-btn" title="Click to record voice message">
                            🎤
                        </button>
                        <textarea id="ai-chat-input" placeholder="Ask a question about your data or click the microphone..." onkeydown="handleChatKeydown(event)" rows="1"></textarea>
                        <button id="ai-chat-send-btn" onclick="sendChatMessage()" class="chat-send-btn">
                            <span>Ask AI</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Clear visual separator -->
            <div style="height: 20px; border-bottom: 2px solid rgba(102, 126, 234, 0.2); margin: 15px 0;"></div>
            
            <!-- Filters Section (Enhanced Version) -->
            <div class="filters-section" style="position: relative; z-index: 1; background: white; border: 2px solid rgba(102, 126, 234, 0.1);">
                <div class="filters-row">
                    <div class="search-container">
                        <label for="voice-search-input">Search Records</label>
                        <input type="text" id="voice-search-input" placeholder="Enter search terms or ask AI..." onkeyup="handleVoiceSearchKeyup(event)">
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-record-type-filter">Record Type</label>
                        <select id="voice-record-type-filter" onchange="applyVoiceFilters()">
                            <option value="">All Types</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-sort-by">Sort By</label>
                        <select id="voice-sort-by" onchange="applyVoiceFilters()">
                            <option value="inArweaveBlock:desc">Block (Newest)</option>
                            <option value="inArweaveBlock:asc">Block (Oldest)</option>
                            <option value="date:desc">Date (Newest)</option>
                            <option value="date:asc">Date (Oldest)</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-resolve-depth">Resolve Depth</label>
                        <input type="number" id="voice-resolve-depth" value="2" min="0" max="5" onchange="applyVoiceFilters()">
                    </div>
                </div>
                
                <div class="filters-row">
                    <div class="filter-group wide">
                        <label>Date Range</label>
                        <div class="date-inputs">
                            <input type="date" id="voice-date-start" onchange="applyVoiceFilters()" placeholder="Start Date">
                            <span>to</span>
                            <input type="date" id="voice-date-end" onchange="applyVoiceFilters()" placeholder="End Date">
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-tag-filter">Filter by Tag</label>
                        <select id="voice-tag-filter" onchange="applyVoiceFilters()">
                            <option value="">All Tags</option>
                        </select>
                    </div>
                </div>
                
                <div class="advanced-filters">
                    <div class="toggle-row">
                        <div class="toggle-group">
                            <label>Include Signatures:</label>
                            <div class="toggle-switch" id="voice-include-sigs-toggle" onclick="toggleVoiceSwitch('voice-include-sigs-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Include Public Keys:</label>
                            <div class="toggle-switch" id="voice-include-pubkeys-toggle" onclick="toggleVoiceSwitch('voice-include-pubkeys-toggle')"></div>
                        </div>
                        
                        <button onclick="clearVoiceFilters()" class="btn-secondary btn-small">Clear Filters</button>
                        <button onclick="applyVoiceFilters()" class="btn-small">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Records Display (Enhanced Version) -->
            <div class="records-container">
                <div id="voice-records-header">
                    <h2>OIP Records</h2>
                    <div id="voice-pagination-info" class="pagination-info"></div>
                </div>
                
                <div id="voice-loading-indicator" class="loading">
                    <div class="spinner"></div>
                    Loading records...
                </div>
                
                <div id="voice-records-grid" class="records-grid hidden"></div>
                
                <div id="voice-no-results" class="no-results hidden">
                    No records found matching your criteria.
                </div>
                
                <div id="voice-load-more-container" class="load-more hidden">
                    <button onclick="loadMoreVoiceRecords()" id="voice-load-more-btn">Load More Records</button>
                </div>
            </div>
        </div>

        <!-- Publish Tab Content -->
        <div id="publish-tab" class="hidden">
            <div class="section">
                <h2>Publishing Platform</h2>
                <p>Please log in to access publishing features.</p>
                
                <div id="publishing-content" class="hidden">
                    <div class="filters-row">
                        <button onclick="showCreatorRegistration()">Register Creator</button>
                        <button onclick="showTemplateCreation()">Create Template</button>
                        <button onclick="showRecordPublishing()">Publish Record</button>
                    </div>
                </div>
            </div>

            <!-- Creator Registration -->
            <div id="creator-section" class="section hidden">
                <h2>Creator Registration</h2>
                <div class="form-group">
                    <label for="creator-name">Creator Name:</label>
                    <input type="text" id="creator-name" required>
                </div>
                <div class="form-group">
                    <label for="creator-description">Description:</label>
                    <textarea id="creator-description"></textarea>
                </div>
                <div class="form-group">
                    <label for="creator-email">Email:</label>
                    <input type="email" id="creator-email">
                </div>
                <div class="form-group">
                    <label for="creator-website">Website:</label>
                    <input type="url" id="creator-website">
                </div>
                <button onclick="registerCreator()">Register Creator</button>
                <div id="creator-status" class="error-message hidden"></div>
                <div id="creator-success" class="success-message hidden"></div>
            </div>

            <!-- Template Creation -->
            <div id="template-section" class="section hidden">
                <h2>Template Creation</h2>
                <div class="form-group">
                    <label for="template-name">Template Name:</label>
                    <input type="text" id="template-name" required>
                </div>
                <div class="form-group">
                    <label for="template-recordtype">Record Type:</label>
                    <input type="text" id="template-recordtype" required placeholder="e.g., post, recipe, workout">
                </div>
                <div class="dynamic-fields">
                    <h3>Template Fields</h3>
                    <div id="template-fields">
                        <div class="field-row">
                            <div>
                                <label>Field Name:</label>
                                <input type="text" class="field-name" placeholder="e.g., title, content">
                            </div>
                            <div>
                                <label>Field Type:</label>
                                <select class="field-type">
                                    <option value="string">String</option>
                                    <option value="number">Number</option>
                                    <option value="boolean">Boolean</option>
                                    <option value="enum">Enum</option>
                                    <option value="array">Array</option>
                                </select>
                            </div>
                            <div>
                                <button type="button" onclick="removeField(this)">Remove</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" onclick="addTemplateField()">Add Field</button>
                </div>
                <button onclick="createTemplate()">Create Template</button>
                <div id="template-status" class="error-message hidden"></div>
                <div id="template-success" class="success-message hidden"></div>
            </div>

            <!-- Record Publishing -->
            <div id="record-section" class="section hidden">
                <h2>Publish Record</h2>
                <div class="form-group">
                    <label for="record-type">Record Type:</label>
                    <select id="record-type" onchange="loadTemplateFields()">
                        <option value="">Select Record Type</option>
                        <option value="recipe">Recipe</option>
                        <option value="workout">Workout</option>
                        <option value="video">Video</option>
                        <option value="image">Image</option>
                        <option value="post">Post</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="template-select">Template:</label>
                    <select id="template-select">
                        <option value="">Loading templates...</option>
                    </select>
                </div>

                <div id="record-fields" class="dynamic-fields">
                    <div class="loading">Select a record type to see available fields</div>
                </div>
                
                <button onclick="publishRecord()" id="publish-btn" disabled>Publish Record</button>
                <div id="record-status" class="error-message hidden"></div>
                <div id="record-success" class="success-message hidden"></div>
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="auth-modal" class="modal hidden">
        <div class="modal-content">
            <div id="login-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" required>
                </div>
                <button onclick="login()">Login</button>
                <button onclick="showRegisterForm()" class="btn-secondary">Register Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="register-form" class="hidden">
                <h2>Register</h2>
                <div class="form-group">
                    <label for="register-email">Email:</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password:</label>
                    <input type="password" id="register-password" required>
                </div>
                <button onclick="register()">Register</button>
                <button onclick="showLoginForm()" class="btn-secondary">Login Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="auth-status" class="error-message hidden"></div>
            <div id="auth-success" class="success-message hidden"></div>
        </div>
    </div>

    <!-- Master Audio Player -->
    <div id="master-audio-player" class="master-audio-player">
        <div class="audio-player-content">
            <div class="audio-info">
                <div class="audio-title" id="audio-title">No audio selected</div>
                <div class="audio-meta" id="audio-meta">Select an audio file to play</div>
            </div>
            
            <div class="audio-controls">
                <button onclick="toggleAudioPlayback()" id="master-play-btn">▶️</button>
                <button onclick="stopAudio()">⏹️</button>
                <div class="audio-progress" onclick="seekAudio(event)">
                    <div class="audio-progress-bar" id="audio-progress-bar"></div>
                </div>
                <div class="audio-time" id="audio-time">0:00 / 0:00</div>
                <button onclick="closeMasterPlayer()">✕</button>
            </div>
        </div>
        
        <audio id="master-audio" style="display: none;" 
               ontimeupdate="updateAudioProgress()" 
               onended="onAudioEnded()"
               onloadedmetadata="onAudioLoaded()">
        </audio>
    </div>

    <script>
        // State management
        let authToken = localStorage.getItem('oip-auth-token');
        let currentUser = localStorage.getItem('oip-user-email');
        let templates = {};
        let defaultTemplates = {};
        let recordTypes = [];
        let currentRecords = [];
        let currentPage = 1;
        let isLoading = false;
        let hasMoreRecords = true;
        let currentFilters = {
            search: '',
            recordType: '',
            sortBy: 'inArweaveBlock:desc',
            resolveDepth: 2,
            dateStart: '',
            dateEnd: '',
            tag: '',
            includeSigs: false,
            includePubKeys: false
        };
        let availableTags = [];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            // Setup authentication state
            if (authToken && currentUser) {
                showLoggedInState();
                await loadTemplates();
            }
            
            // Force hide the old browse tab and ensure it stays hidden
            forcehideBrowseTab();
            
            // Initialize the voice browse tab (now the default)
            initializeVoiceFeatures();
            
            console.log('[App] Initialized with voice browse tab as default');
            
            // Set up periodic checks to ensure interface stays clean
            setInterval(() => {
                forcehideBrowseTab();
                
                // Quick check that chat input is still visible
                const chatInput = document.getElementById('ai-chat-input');
                if (chatInput && (chatInput.offsetHeight === 0 || chatInput.style.display === 'none')) {
                    console.log('[App] Detected hidden chat input, restoring...');
                    ensureChatInputReady();
                }
            }, 2000); // Check every 2 seconds
        }

        // Force hide the old browse tab completely
        function forcehideBrowseTab() {
            const browseTab = document.getElementById('browse-tab');
            if (browseTab) {
                browseTab.style.display = 'none !important';
                browseTab.style.visibility = 'hidden !important';
                browseTab.style.height = '0 !important';
                browseTab.style.overflow = 'hidden !important';
                browseTab.style.position = 'absolute !important';
                browseTab.style.top = '-9999px !important';
                browseTab.classList.add('hidden');
                console.log('[App] Old browse tab forcefully hidden');
            }
        }

        // Navigation functions (showBrowseTab DISABLED - old tab is commented out)
        function showBrowseTab() {
            // OLD BROWSE TAB IS DISABLED - DO NOTHING
            console.log('[Nav] showBrowseTab called but disabled - old tab is commented out');
        }

        function showVoiceBrowseTab() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[0].classList.add('active'); // Now it's the first tab
            // document.getElementById('browse-tab').classList.add('hidden'); // Commented out tab
            document.getElementById('voice-browse-tab').classList.remove('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Initialize voice features when tab is shown
            initializeVoiceFeatures();
        }

        function showPublishTab() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[1].classList.add('active'); // Now it's the second tab
            // document.getElementById('browse-tab').classList.add('hidden'); // Commented out tab
            document.getElementById('voice-browse-tab').classList.add('hidden');
            document.getElementById('publish-tab').classList.remove('hidden');
        }

        // Authentication Modal functions
        function showAuthModal() {
            document.getElementById('auth-modal').classList.remove('hidden');
            showLoginForm();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.add('hidden');
            clearAuthForms();
        }

        function showLoginForm() {
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('register-form').classList.add('hidden');
        }

        function showRegisterForm() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.remove('hidden');
        }

        function clearAuthForms() {
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
            document.getElementById('register-email').value = '';
            document.getElementById('register-password').value = '';
            hideElement('auth-status');
            hideElement('auth-success');
        }

        // Authentication functions
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Login successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function register() {
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Registration successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            localStorage.removeItem('oip-auth-token');
            localStorage.removeItem('oip-user-email');
            showLoginState();
        }

        function showLoggedInState() {
            document.getElementById('user-info').classList.remove('hidden');
            document.getElementById('auth-buttons').classList.add('hidden');
            document.getElementById('publishing-content').classList.remove('hidden');
            document.getElementById('logged-in-display').textContent = currentUser;
        }

        function showLoginState() {
            document.getElementById('user-info').classList.add('hidden');
            document.getElementById('auth-buttons').classList.remove('hidden');
            document.getElementById('publishing-content').classList.add('hidden');
            hideAllPublishingSections();
        }

        // Core browsing functionality (DISABLED - redirected to voice version)
        async function loadRecords(reset = false) {
            console.log('[App] loadRecords called but redirected to loadVoiceRecords');
            // Redirect to the voice version instead
            return await loadVoiceRecords(reset);
        }

        // OLD loadRecords function (disabled)
        async function loadRecordsOLD(reset = false) {
            if (isLoading) return;
            
            isLoading = true;
            const loadingEl = document.getElementById('loading-indicator');
            const recordsGrid = document.getElementById('records-grid');
            const noResults = document.getElementById('no-results');
            
            if (reset) {
                currentPage = 1;
                currentRecords = [];
                recordsGrid.innerHTML = '';
                loadingEl.classList.remove('hidden');
                recordsGrid.classList.add('hidden');
                noResults.classList.add('hidden');
            }

            try {
                const params = buildApiParams();
                const response = await fetch(`https://api.oip.onl/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    displayRecords(data.records, !reset);
                    updatePaginationInfo(data);
                    
                    // Update tags if available
                    if (data.tagSummary) {
                        updateTagFilter(data.tagSummary);
                    }
                    
                    hasMoreRecords = data.records.length === 12; // Check if we got a full page
                } else {
                    if (reset) {
                        showNoResults();
                    }
                }
                
            } catch (error) {
                console.error('Error loading records:', error);
                showMessage('records-header', 'Error loading records: ' + error.message, 'error');
            } finally {
                isLoading = false;
                loadingEl.classList.add('hidden');
                updateLoadMoreButton();
            }
        }

        function buildApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '25',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.tag) {
                params.append('tags', currentFilters.tag);
            }

            return params.toString();
        }

        // Display and utility functions
        function displayRecords(records, append = false) {
            const grid = document.getElementById('records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = currentRecords.length - records.length;
            records.forEach((record, index) => {
                const card = createRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
        }

        // Media rendering functions (excluding images and audio which are handled separately)
        function renderOtherMediaContent(record, recordType, specificData) {
            let mediaHtml = '';
            
            // Handle direct media records (video, text only - images and audio handled separately)
            if (['video', 'text'].includes(recordType)) {
                mediaHtml += renderDirectMedia(specificData, recordType);
            }
            
            // Handle post records with embedded media (excluding featured image and audio)
            if (recordType === 'post' && specificData) {
                mediaHtml += renderPostVideoAndText(specificData);
            }
            
            // Handle recipe and workout records with media in ingredients/exercises
            if (['recipe', 'workout'].includes(recordType) && specificData) {
                mediaHtml += renderRecipeWorkoutNonAudioMedia(specificData, recordType);
            }
            
            return mediaHtml ? `<div class="media-content">${mediaHtml}</div>` : '';
        }

        function renderPostVideoAndText(postData) {
            let html = '';
            
            // Article text (dref resolved) - but not if it's already shown in the text toggle
            if (postData.articleText?.data?.text?.webUrl && !postData.articleText) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }

        function renderRecipeWorkoutNonAudioMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media (excluding audio/images)
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has video or text media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        function renderDirectMedia(data, type) {
            if (!data || !data.webUrl) return '';
            
            const webUrl = data.webUrl;
            const contentType = data.contentType || '';
            
            switch (type) {
                case 'image':
                    return `<div class="media-item">
                        <img src="${webUrl}" alt="Image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <audio controls style="width: 100%; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <video controls style="width: 100%; max-height: 300px; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <div class="text-preview" style="margin: 10px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }
        
        function renderPostMedia(postData) {
            let html = '';
            
            // Main article web URL (external link) - this should open in new tab
            if (postData.webUrl) {
                html += `<div class="media-item">
                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Read Original Article
                    </a>
                </div>`;
            }
            
            // Article text (dref resolved)
            if (postData.articleText?.data?.text?.webUrl) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Featured image (dref resolved)
            if (postData.featuredImage?.data?.image?.webUrl) {
                html += renderDirectMedia(postData.featuredImage.data.image, 'image');
            }
            
            // Audio items array
            if (postData.audioItems && Array.isArray(postData.audioItems)) {
                postData.audioItems.forEach((audioItem, index) => {
                    if (audioItem?.data?.audio?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Audio ${index + 1}:</label>
                            ${renderDirectMedia(audioItem.data.audio, 'audio')}
                        </div>`;
                    }
                });
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            // Image items array
            if (postData.imageItems && Array.isArray(postData.imageItems)) {
                postData.imageItems.forEach((imageItem, index) => {
                    if (imageItem?.data?.image?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Image ${index + 1}:</label>
                            ${renderDirectMedia(imageItem.data.image, 'image')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }
        
        function renderRecipeWorkoutMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['image', 'audio', 'video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        // Load text content dynamically
        async function loadTextContent(url, button) {
            const contentDiv = button.nextElementSibling;
            
            if (contentDiv.style.display === 'none') {
                try {
                    button.textContent = 'Loading...';
                    button.disabled = true;
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    
                    contentDiv.innerHTML = `
                        <div style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 14px;">
                            ${escapeHtml(text)}
                        </div>
                        <button onclick="this.parentElement.style.display='none'; this.parentElement.previousElementSibling.textContent='📄 View Text Content'; this.parentElement.previousElementSibling.disabled=false;" 
                                style="margin-top: 10px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Hide
                        </button>
                    `;
                    contentDiv.style.display = 'block';
                    button.textContent = '📄 Text Loaded';
                } catch (error) {
                    contentDiv.innerHTML = `<div style="color: #dc3545;">Error loading text content: ${error.message}</div>`;
                    contentDiv.style.display = 'block';
                    button.textContent = '❌ Failed to Load';
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createRecordCard(record, recordIndex) {
            const card = document.createElement('div');
            card.className = 'record-card';
            
            // Get record type from template or data
            const recordType = getRecordType(record);
            const basicData = record.data?.basic || {};
            const specificData = record.data?.[recordType] || {};
            
            // Get date - prefer dateReadable, fallback to formatted date
            const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            // Handle images - check multiple possible locations
            let imageHtml = '';
            let imageUrl = null;
            
            // Check various image field locations in order of preference
            if (basicData.featuredImage) {
                imageUrl = basicData.featuredImage;
            } else if (specificData.featuredImage?.data?.image?.webUrl) {
                imageUrl = specificData.featuredImage.data.image.webUrl;
            } else if (record.data?.image?.webUrl) {
                imageUrl = record.data.image.webUrl;
            } else if (basicData.imageItems && basicData.imageItems.length > 0) {
                imageUrl = basicData.imageItems[0];
            }
            
            if (imageUrl) {
                imageHtml = `<img src="${imageUrl}" alt="Record image" class="record-image" onerror="this.style.display='none';">`;
            }
            
            // Handle audio - create play button for master player
            let audioHtml = '';
            // Check for audio in specific data (e.g., post.audioItems) first, then basic data
            const audioItems = specificData.audioItems || basicData.audioItems;
            if (audioItems && Array.isArray(audioItems) && audioItems.length > 0) {
                // Get the first audio item's URL
                let firstAudioUrl = '';
                if (audioItems[0]?.data?.audio?.webUrl) {
                    firstAudioUrl = audioItems[0].data.audio.webUrl;
                } else if (typeof audioItems[0] === 'string') {
                    firstAudioUrl = audioItems[0];
                }
                
                if (firstAudioUrl) {
                    audioHtml = `
                        <div style="margin: 10px 0;">
                            <button onclick="playAudioInMaster('${firstAudioUrl}', '${(basicData.name || 'Unnamed Record').replace(/'/g, "\\'")}', '${recordType}', ${recordIndex})" 
                                    id="audioBtn-${recordIndex}" 
                                    class="audio-play-btn">
                                <span>▶️</span>
                                <span>Play Audio</span>
                            </button>
                            ${audioItems.length > 1 ? `<span style="font-size: 12px; color: #666; margin-left: 8px;">(${audioItems.length} audio files)</span>` : ''}
                        </div>
                    `;
                }
            }
            
            // Determine text content source and type
            let textSourceUrl = null;
            let textSourceType = 'static'; // 'static' or 'fetch'
            let staticTextContent = '';
            
            // Check for text file URLs first (highest priority)
            if (specificData.articleText?.data?.text?.webUrl) {
                textSourceUrl = specificData.articleText.data.text.webUrl;
                textSourceType = 'fetch';
            } else if (specificData.articleText?.webUrl) {
                textSourceUrl = specificData.articleText.webUrl;
                textSourceType = 'fetch';
            } else if (record.data?.text?.webUrl) {
                textSourceUrl = record.data.text.webUrl;
                textSourceType = 'fetch';
            } else if (specificData.instructions && typeof specificData.instructions === 'string' && specificData.instructions.length > 200) {
                staticTextContent = specificData.instructions;
                textSourceType = 'static';
            } else if (specificData.content && typeof specificData.content === 'string' && specificData.content.length > 200) {
                staticTextContent = specificData.content;
                textSourceType = 'static';
            } else if (basicData.description && basicData.description.length > 200) {
                staticTextContent = basicData.description;
                textSourceType = 'static';
            }
            
            // Text content toggle button
            let textToggleHtml = '';
            if (textSourceType === 'fetch' || (textSourceType === 'static' && staticTextContent)) {
                const buttonText = textSourceType === 'fetch' ? '📄 Load Full Article' : '📄 Show Full Text';
                textToggleHtml = `
                    <div style="margin: 10px 0;">
                        <button onclick="toggleTextContent(${recordIndex}, '${textSourceType}', '${textSourceUrl || ''}')" 
                                id="textBtn-${recordIndex}" 
                                class="toggle-text-btn">
                            ${buttonText}
                        </button>
                        <div id="textContent-${recordIndex}" class="text-content-preview hidden" data-static-content="${textSourceType === 'static' ? escapeHtml(staticTextContent) : ''}">
                            ${textSourceType === 'static' ? escapeHtml(staticTextContent) : '<div class="loading">Loading...</div>'}
                        </div>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="record-header">
                    <div class="record-type">${recordType}</div>
                    <div class="record-block">${dateDisplay}</div>
                </div>
                <div class="record-title">${basicData.name || 'Unnamed Record'}</div>
                ${imageHtml}
                <div class="record-content">
                    ${basicData.description || getContentPreview(specificData) || 'No description available'}
                </div>
                ${audioHtml}
                ${textToggleHtml}
                ${renderOtherMediaContent(record, recordType, specificData)}
                <div class="record-meta">
                    <div>DID: ${record.oip?.didTx || 'Unknown'}</div>
                    ${(specificData.webUrl || basicData.webUrl) ? `<div><a href="${specificData.webUrl || basicData.webUrl}" target="_blank" rel="noopener noreferrer">🌐 Read Original Article</a></div>` : ''}
                </div>
                ${createTagsDisplay(basicData.tagItems)}
            `;
            
            return card;
        }

        function getRecordType(record) {
            // First, check the authoritative source: oip.recordType
            if (record.oip && record.oip.recordType) {
                return record.oip.recordType;
            }
            
            // Fallback: Try to get from data structure
            if (record.data) {
                const keys = Object.keys(record.data);
                for (const key of keys) {
                    if (key !== 'basic' && typeof record.data[key] === 'object') {
                        return key;
                    }
                }
            }
            
            return 'unknown';
        }

        function getContentPreview(data) {
            if (!data) return '';
            
            // Try common content fields
            if (data.content) return truncateText(data.content, 150);
            if (data.articleText) return truncateText(data.articleText, 150);
            if (data.description) return truncateText(data.description, 150);
            
            return '';
        }

        function createTagsDisplay(tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) return '';
            
            const tagsHtml = tags.slice(0, 5).map(tag => 
                `<span class="tag" onclick="filterByTag('${tag}')">${tag}</span>`
            ).join('');
            
            return `<div class="tags-container">${tagsHtml}</div>`;
        }



        // Load templates from API
        async function loadTemplates() {
            try {
                const response = await fetch('/api/templates?limit=100');
                const data = await response.json();
                
                if (data.templates) {
                    templates = {};
                    data.templates.forEach(template => {
                        const recordType = template.data.recordType || template.data.template || 'unknown';
                        if (!templates[recordType]) {
                            templates[recordType] = [];
                        }
                        templates[recordType].push(template);
                    });
                    
                    // Load default templates
                    defaultTemplates = {
                        basic: "-9DirnjVO1FlbEW1lN8jITBESrTsQKEM_BoZ1ey_0mk",
                        creatorRegistration: "BKVvTSXmmJni-L82irZfPFXWWJLBcdvbxS34jP1FTG8",
                        post: "op6y-d_6bqivJ2a2oWQnbylD4X_LH6eQyR6rCGqtVZ8",
                        recipe: "46Ui_ifw5LnrRmf_o2zWwikNxgXsXk3sswPtbcJCzlc",
                        workout: "T_16JOpyRKt0dmuZikHPpDcIhwh4DR1ZspHU4BKa-qE",
                        video: "G73WplyxpNDOgDSFO6CP3O6hZXq8kNJXxkCqx3sgd1s",
                        image: "AkZnE1VckJJlRamgNJuIGE7KrYwDcCciWOMrMh68V4o"
                    };
                }
            } catch (error) {
                console.error('Error loading templates:', error);
            }
        }

        async function loadRecordTypes() {
            try {
                const response = await fetch('https://api.oip.onl/api/templates?limit=25&page=1');
                const data = await response.json();
                
                if (data.templates) {
                    const typeSet = new Set();
                    data.templates.forEach(template => {
                        if (template.data?.template) {
                            typeSet.add(template.data.template);
                        }
                    });
                    
                    recordTypes = Array.from(typeSet).sort();
                    populateRecordTypeFilter();
                }
            } catch (error) {
                console.error('Error loading record types:', error);
            }
        }

        function populateRecordTypeFilter() {
            // Populate voice record type filter (Browse + AI Chat tab)
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                
                recordTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    voiceSelect.appendChild(option);
                });
            }
        }

        // Utility functions
        function truncateText(text, length) {
            if (!text) return '';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function dateToUnixTime(dateString) {
            if (!dateString) return '';
            return Math.floor(new Date(dateString).getTime() / 1000).toString();
        }



        function setupInfiniteScroll() {
            window.addEventListener('scroll', () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
                    loadMoreRecords();
                }
            });
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = type === 'error' ? 'error-message' : 'success-message';
            element.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => element.classList.add('hidden'), 3000);
            }
        }

        function hideElement(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        // Publishing navigation functions
        function hideAllPublishingSections() {
            document.getElementById('creator-section').classList.add('hidden');
            document.getElementById('template-section').classList.add('hidden');
            document.getElementById('record-section').classList.add('hidden');
        }

        function showCreatorRegistration() {
            hideAllPublishingSections();
            document.getElementById('creator-section').classList.remove('hidden');
        }

        function showTemplateCreation() {
            hideAllPublishingSections();
            document.getElementById('template-section').classList.remove('hidden');
        }

        function showRecordPublishing() {
            hideAllPublishingSections();
            document.getElementById('record-section').classList.remove('hidden');
        }

        // Creator registration
        async function registerCreator() {
            const name = document.getElementById('creator-name').value;
            const description = document.getElementById('creator-description').value;
            const email = document.getElementById('creator-email').value;
            const website = document.getElementById('creator-website').value;

            if (!name) {
                showMessage('creator-status', 'Please enter a creator name', 'error');
                return;
            }

            const creatorData = {
                basic: {
                    name: name,
                    description: description,
                    language: 'en',
                    date: Math.floor(Date.now() / 1000),
                    nsfw: false
                },
                creatorRegistration: {
                    email: email || currentUser,
                    website: website,
                    verified: false
                }
            };

            try {
                const response = await fetch('/api/creators/newCreator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(creatorData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('creator-success', `Creator registered successfully! Transaction ID: ${data.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('creator-name').value = '';
                    document.getElementById('creator-description').value = '';
                    document.getElementById('creator-email').value = '';
                    document.getElementById('creator-website').value = '';
                } else {
                    showMessage('creator-status', data.error || 'Failed to register creator', 'error');
                }
            } catch (error) {
                showMessage('creator-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Template creation functions
        function addTemplateField() {
            const fieldsContainer = document.getElementById('template-fields');
            const fieldRow = document.createElement('div');
            fieldRow.className = 'field-row';
            fieldRow.innerHTML = `
                <div>
                    <label>Field Name:</label>
                    <input type="text" class="field-name" placeholder="e.g., title, content">
                </div>
                <div>
                    <label>Field Type:</label>
                    <select class="field-type">
                        <option value="string">String</option>
                        <option value="number">Number</option>
                        <option value="boolean">Boolean</option>
                        <option value="enum">Enum</option>
                        <option value="array">Array</option>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="removeField(this)">Remove</button>
                </div>
            `;
            fieldsContainer.appendChild(fieldRow);
        }

        function removeField(button) {
            button.closest('.field-row').remove();
        }

        async function createTemplate() {
            const templateName = document.getElementById('template-name').value;
            const recordType = document.getElementById('template-recordtype').value;

            if (!templateName || !recordType) {
                showMessage('template-status', 'Please fill in template name and record type', 'error');
                return;
            }

            const fieldRows = document.querySelectorAll('#template-fields .field-row');
            const templateFields = {};

            fieldRows.forEach(row => {
                const fieldName = row.querySelector('.field-name').value;
                const fieldType = row.querySelector('.field-type').value;
                
                if (fieldName && fieldType) {
                    templateFields[fieldName] = fieldType;
                }
            });

            if (Object.keys(templateFields).length === 0) {
                showMessage('template-status', 'Please add at least one field', 'error');
                return;
            }

            const templateData = {
                template: templateName,
                recordType: recordType,
                fields: JSON.stringify(templateFields)
            };

            try {
                const response = await fetch('/api/templates/newTemplate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(templateData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('template-success', `Template created successfully! Transaction ID: ${data.newTemplate.transactionId}`, 'success');
                    // Clear form and reload templates
                    document.getElementById('template-name').value = '';
                    document.getElementById('template-recordtype').value = '';
                    await loadTemplates();
                } else {
                    showMessage('template-status', data.error || 'Failed to create template', 'error');
                }
            } catch (error) {
                showMessage('template-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Record publishing functions
        function loadTemplateFields() {
            const recordType = document.getElementById('record-type').value;
            const fieldsContainer = document.getElementById('record-fields');
            const publishBtn = document.getElementById('publish-btn');
            
            if (!recordType) {
                fieldsContainer.innerHTML = '<div class="loading">Select a record type to see available fields</div>';
                publishBtn.disabled = true;
                return;
            }

            // Load template selector
            const templateSelect = document.getElementById('template-select');
            templateSelect.innerHTML = '<option value="">Select a template</option>';
            
            if (templates[recordType]) {
                templates[recordType].forEach(template => {
                    const option = document.createElement('option');
                    option.value = template.oip.didTx;
                    option.textContent = template.data.template || template.oip.didTx;
                    templateSelect.appendChild(option);
                });
            }

            // Add default template option
            if (defaultTemplates[recordType]) {
                const option = document.createElement('option');
                option.value = `did:arweave:${defaultTemplates[recordType]}`;
                option.textContent = `Default ${recordType} template`;
                option.selected = true;
                templateSelect.appendChild(option);
            }

            // Create basic fields for the record type
            fieldsContainer.innerHTML = createRecordFields(recordType);
            publishBtn.disabled = false;
        }

        function createRecordFields(recordType) {
            let fieldsHTML = '<h3>Basic Information</h3>';
            
            // Basic fields common to all records
            fieldsHTML += `
                <div class="form-group">
                    <label>Name/Title:</label>
                    <input type="text" id="basic-name" required>
                </div>
                <div class="form-group">
                    <label>Description:</label>
                    <textarea id="basic-description"></textarea>
                </div>
                <div class="form-group">
                    <label>Tags (comma-separated):</label>
                    <input type="text" id="basic-tags" placeholder="tag1, tag2, tag3">
                </div>
            `;

            // Simplified record-specific fields
            fieldsHTML += `<h3>${recordType.charAt(0).toUpperCase() + recordType.slice(1)} Fields</h3>`;
            
            if (recordType === 'post') {
                fieldsHTML += `
                    <div class="form-group">
                        <label>Article Text:</label>
                        <textarea id="post-articletext" required placeholder="Main article content"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Byline Writer:</label>
                        <input type="text" id="post-bylinewriter" placeholder="Author name">
                    </div>
                `;
            } else {
                fieldsHTML += `
                    <div class="form-group">
                        <label>Content:</label>
                        <textarea id="record-content" placeholder="Enter ${recordType} content"></textarea>
                    </div>
                `;
            }

            return fieldsHTML;
        }

        async function publishRecord() {
            const recordType = document.getElementById('record-type').value;
            
            if (!recordType) {
                showMessage('record-status', 'Please select a record type', 'error');
                return;
            }

            // Collect basic data
            const basicData = {
                name: document.getElementById('basic-name').value,
                description: document.getElementById('basic-description').value,
                language: 'en',
                tagItems: document.getElementById('basic-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag),
                nsfw: false,
                date: Math.floor(Date.now() / 1000)
            };

            if (!basicData.name) {
                showMessage('record-status', 'Please enter a name/title', 'error');
                return;
            }

            // Simplified record data collection
            let recordData = { basic: basicData };
            let endpoint = `/api/publish/new${recordType.charAt(0).toUpperCase() + recordType.slice(1)}`;

            if (recordType === 'post') {
                recordData.post = {
                    articleText: document.getElementById('post-articletext').value,
                    bylineWriter: document.getElementById('post-bylinewriter').value,
                    webUrl: '',
                    bylineWritersTitle: '',
                    bylineWritersLocation: '',
                    featuredImage: '',
                    imageItems: [],
                    imageCaptionItems: [],
                    videoItems: [],
                    audioItems: [],
                    audioCaptionItems: [],
                    replyTo: ''
                };
                
                if (!recordData.post.articleText) {
                    showMessage('record-status', 'Please enter the article text', 'error');
                    return;
                }
            } else {
                // For other record types, use generic content field
                const content = document.getElementById('record-content').value;
                recordData[recordType] = { content: content };
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recordData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('record-success', `${recordType} published successfully! Transaction ID: ${data.transactionId}`, 'success');
                    // Clear the form
                    document.getElementById('record-fields').innerHTML = '<div class="loading">Select a record type to see available fields</div>';
                    document.getElementById('record-type').value = '';
                    document.getElementById('publish-btn').disabled = true;
                    
                    // Refresh the browse tab to show new record
                    if (currentRecords.length > 0) {
                        loadRecords(true);
                    }
                } else {
                    showMessage('record-status', data.error || `Failed to publish ${recordType}`, 'error');
                }
            } catch (error) {
                showMessage('record-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Master Audio Player functions
        let currentAudioUrl = null;
        let currentAudioTitle = null;
        let currentAudioType = null;
        let currentPlayingIndex = null;

        function playAudioInMaster(audioUrl, title, recordType, recordIndex) {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            const audioTitle = document.getElementById('audio-title');
            const audioMeta = document.getElementById('audio-meta');
            const playBtn = document.getElementById('master-play-btn');
            
            // Update all audio buttons
            document.querySelectorAll('.audio-play-btn').forEach(btn => {
                btn.classList.remove('playing');
                btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
            });
            
            // If same audio is playing, toggle it
            if (currentAudioUrl === audioUrl && !masterAudio.paused) {
                masterAudio.pause();
                return;
            }
            
            // Set new audio
            currentAudioUrl = audioUrl;
            currentAudioTitle = title;
            currentAudioType = recordType;
            currentPlayingIndex = recordIndex;
            
            masterAudio.src = audioUrl;
            audioTitle.textContent = title;
            audioMeta.textContent = `${recordType} • Loading...`;
            
            // Show master player
            masterPlayer.classList.add('visible');
            
            // Update button states
            const currentBtn = document.getElementById(`audioBtn-${recordIndex}`);
            if (currentBtn) {
                currentBtn.classList.add('playing');
                currentBtn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
            }
            
            // Play audio
            masterAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                audioMeta.textContent = `${recordType} • Error loading audio`;
            });
            
            playBtn.textContent = '⏸️';
        }

        function toggleAudioPlayback() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            
            if (masterAudio.paused) {
                masterAudio.play();
                playBtn.textContent = '⏸️';
                updateCurrentPlayingButton(true);
            } else {
                masterAudio.pause();
                playBtn.textContent = '▶️';
                updateCurrentPlayingButton(false);
            }
        }

        function stopAudio() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            masterAudio.pause();
            masterAudio.currentTime = 0;
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Stopped`;
            updateCurrentPlayingButton(false);
        }

        function closeMasterPlayer() {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            
            masterAudio.pause();
            masterPlayer.classList.remove('visible');
            updateCurrentPlayingButton(false);
            
            currentAudioUrl = null;
            currentAudioTitle = null;
            currentAudioType = null;
            currentPlayingIndex = null;
        }

        function updateCurrentPlayingButton(isPlaying) {
            if (currentPlayingIndex !== null) {
                const btn = document.getElementById(`audioBtn-${currentPlayingIndex}`);
                if (btn) {
                    if (isPlaying) {
                        btn.classList.add('playing');
                        btn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                    } else {
                        btn.classList.remove('playing');
                        btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
                    }
                }
            }
        }

        function updateAudioProgress() {
            const masterAudio = document.getElementById('master-audio');
            const progressBar = document.getElementById('audio-progress-bar');
            const timeDisplay = document.getElementById('audio-time');
            
            if (masterAudio.duration) {
                const progress = (masterAudio.currentTime / masterAudio.duration) * 100;
                progressBar.style.width = progress + '%';
                
                const currentTime = formatTime(masterAudio.currentTime);
                const totalTime = formatTime(masterAudio.duration);
                timeDisplay.textContent = `${currentTime} / ${totalTime}`;
            }
        }

        function seekAudio(event) {
            const masterAudio = document.getElementById('master-audio');
            const progressContainer = event.currentTarget;
            const rect = progressContainer.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            
            if (masterAudio.duration) {
                masterAudio.currentTime = percent * masterAudio.duration;
            }
        }

        function onAudioLoaded() {
            const audioMeta = document.getElementById('audio-meta');
            const masterAudio = document.getElementById('master-audio');
            
            if (masterAudio.duration) {
                const duration = formatTime(masterAudio.duration);
                audioMeta.textContent = `${currentAudioType} • Duration: ${duration}`;
            }
        }

        function onAudioEnded() {
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Finished`;
            updateCurrentPlayingButton(false);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // AI Chat State Management
        let chatState = {
            isInitialized: false,
            isProcessing: false,
            conversation: [],
            selectedModel: 'llama3.2:3b',
            selectedLanguage: 'auto',
            lastQuery: '',
            appliedFilters: {},
            // Follow-up question tracking
            lastSearchResults: [],
            lastSearchSubject: '',
            lastSearchKeywords: [],
            // Voice recording state
            isRecording: false,
            isTranscribing: false,
            isListening: false,
            mediaStream: null,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            vadInterval: null,
            silenceTimeout: null,
            lastSpeechTime: 0
        };

        let voiceFilters = {
            search: '',
            recordType: '',
            sortBy: 'inArweaveBlock:desc',
            resolveDepth: 2,
            dateStart: '',
            dateEnd: '',
            tag: '',
            includeSigs: false,
            includePubKeys: false
        };

        let voiceRecords = [];
        let voicePage = 1;
        let voiceHasMoreRecords = true;
        let voiceIsLoading = false;

        // AI Chat Feature Initialization
        async function initializeVoiceFeatures() {
            if (chatState.isInitialized) return;
            
            console.log('[Chat] Initializing AI chat features...');
            updateAIStatus('Initializing...');
            
            try {
                // Initialize STT features
                
                updateAIStatus('Ready to answer questions!');
                
                chatState.isInitialized = true;
                
                // Load initial records for voice tab
                await loadVoiceRecords(true);
                
                console.log('[Chat] AI chat features initialized successfully');
                
            } catch (error) {
                console.error('[Chat] Initialization failed:', error);
                updateAIStatus('AI chat unavailable');
            }
        }


        async function loadVoiceSettings() {
            try {
                // Load available voices from backend
                const response = await fetch('/api/voice/voices');
                const data = await response.json();
                
                if (data.voices) {
                    voiceState.availableVoices = data.voices;
                    populateVoiceSelect();
                }
                
                // Load record types for voice tab filters
                await loadVoiceRecordTypes();
                
            } catch (error) {
                console.warn('[Voice] Could not load voice settings:', error);
                // Set default voices if API fails
                voiceState.availableVoices = [
                    { id: 'female_1', name: 'Female Voice 1', engine: 'TTS' },
                    { id: 'male_1', name: 'Male Voice 1', engine: 'TTS' }
                ];
                populateVoiceSelect();
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voice-style-select');
            
            // Keep existing options if populated (since we set them manually)
            if (select.children.length > 0) {
                // Just set the correct default value
                select.value = voiceState.selectedVoice;
                return;
            }
            
            // Fallback: populate from API if no options exist
            voiceState.availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} (${voice.engine})`;
                select.appendChild(option);
            });
            
            // Set default voice to Edge if available
            select.value = voiceState.selectedVoice;
        }

        async function loadVoiceRecordTypes() {
            try {
                const response = await fetch('/api/templates?limit=25&page=1');
                const data = await response.json();
                
                if (data.templates) {
                    const typeSet = new Set();
                    data.templates.forEach(template => {
                        if (template.data?.template) {
                            typeSet.add(template.data.template);
                        }
                    });
                    
                    const recordTypes = Array.from(typeSet).sort();
                    populateVoiceRecordTypeFilter(recordTypes);
                }
            } catch (error) {
                console.error('[Voice] Error loading record types:', error);
            }
        }

        function populateVoiceRecordTypeFilter(recordTypes) {
            const select = document.getElementById('voice-record-type-filter');
            select.innerHTML = '<option value="">All Types</option>';
            
            recordTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                select.appendChild(option);
            });
        }

        function updateAIStatus(main) {
            document.getElementById('ai-status-text').textContent = main;
        }

        // Chat Input Functions
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize textarea
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('ai-chat-input');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
            }
        });

        async function sendChatMessage() {
            const input = document.getElementById('ai-chat-input');
            const question = input.value.trim();
            
            if (!question || chatState.isProcessing) {
                return;
            }
            
            // Clear input and disable send button temporarily
            input.value = '';
            input.style.height = '44px'; // Reset textarea height
            const sendBtn = document.getElementById('ai-chat-send-btn');
            sendBtn.disabled = true;
            
            try {
                // Add user message to conversation immediately
                addToConversation('user', question);
                
                // Update selected model and voice
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                await processTextWithAI(question);
            } catch (error) {
                console.error('[Chat] Error processing message:', error);
                updateAIStatus('Error occurred');
                addToConversation('system', `Error: ${error.message}`);
            } finally {
                // Re-enable send button
                sendBtn.disabled = false;
                
                // Ensure chat input is ready for next message - multiple attempts
                ensureChatInputReady();
                setTimeout(() => ensureChatInputReady(), 100);
                setTimeout(() => ensureChatInputReady(), 300);
            }
        }

        // AI Processing Functions

        async function processTextWithAI(text) {
            try {
                updateAIStatus('Analyzing question...');
                chatState.isProcessing = true;
                
                // Determine if this is a follow-up question or new subject
                const isFollowUp = await detectFollowUpQuestion(text);
                
                if (isFollowUp && chatState.lastSearchResults.length > 0) {
                    updateAIStatus('Processing follow-up with existing data...');
                    await processFollowUpQuestion(text);
                } else {
                    updateAIStatus('Searching for new information...');
                    await processNewQuestion(text);
                }
                
                updateAIStatus('Ready to answer questions!');
                
            } catch (error) {
                console.error('[Chat] AI processing error:', error);
                updateAIStatus('AI processing failed');
                addToConversation('system', `AI Error: ${error.message}`);
            } finally {
                chatState.isProcessing = false;
                // Immediately restore input when processing completes
                ensureChatInputReady();
            }
        }

        async function detectFollowUpQuestion(text) {
            // If no previous conversation, definitely not a follow-up
            if (chatState.conversation.length === 0 || !chatState.lastSearchSubject) {
                return false;
            }

            const lowerText = text.toLowerCase();
            
            // Obvious new subject indicators
            const newSubjectPatterns = [
                /^(find|search|show|get|tell me about|what is|who is|where is|when is|how is)/,
                /recipe for/,
                /workout for/,
                /video about/,
                /image of/,
                /post about/,
                /information about/,
                /data on/
            ];
            
            if (newSubjectPatterns.some(pattern => pattern.test(lowerText))) {
                // Check if it mentions the same subject as before
                const lastSubjectWords = chatState.lastSearchSubject.toLowerCase().split(' ');
                const hasCommonSubject = lastSubjectWords.some(word => 
                    word.length > 3 && lowerText.includes(word)
                );
                
                if (!hasCommonSubject) {
                    return false; // Definitely new subject
                }
            }
            
            // Follow-up indicators
            const followUpPatterns = [
                /^(how many|how much|what about|what else|also|and|more|any other|tell me more)/,
                /^(where|when|why|who|which|whose)/,
                /(more|additional|other|else|further|next)/,
                /^(can you|could you|please)/
            ];
            
            if (followUpPatterns.some(pattern => pattern.test(lowerText))) {
                return true;
            }
            
            // Check for context continuity
            const lastSearchWords = chatState.lastSearchKeywords;
            if (lastSearchWords.length > 0) {
                const hasContextOverlap = lastSearchWords.some(keyword => 
                    lowerText.includes(keyword.toLowerCase())
                );
                
                if (hasContextOverlap) {
                    return true;
                }
            }
            
            return false;
        }

        async function processFollowUpQuestion(text) {
            console.log('[Chat] Processing follow-up question with existing data');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 20000);
            
            try {
                // Send the question with context and existing search results
                const response = await fetch('/api/voice/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: false, // Don't perform new search
                        is_follow_up: true,
                        conversation_context: chatState.conversation.slice(-4), // Last 4 messages for context
                        existing_search_results: chatState.lastSearchResults
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Follow-up processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] Follow-up Response:', aiData);
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: chatState.lastSearchResults,
                    searchResults: chatState.lastSearchResults.length,
                    isFollowUp: true
                });
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                throw fetchError;
            }
        }

        async function processNewQuestion(text) {
            console.log('[Chat] Processing new question with fresh search');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 25000);
            
            try {
                // Send to chat endpoint for new search
                const response = await fetch('/api/voice/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: true,
                        is_follow_up: false
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 408 || response.status === 504) {
                        throw new Error('Request timeout - service may be busy, please try again');
                    }
                    throw new Error(`AI processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] New Question Response:', aiData);
                
                // Store search results and subject for future follow-ups
                chatState.lastSearchResults = aiData.search_results || [];
                chatState.lastSearchSubject = aiData.extracted_subject || text;
                chatState.lastSearchKeywords = aiData.extracted_keywords || [];
                
                // Use applied filters from backend (enhanced RAG service)
                const appliedFilters = aiData.applied_filters || {};
                
                // Apply the filters to the UI and reload records
                await applyAIFilters(appliedFilters, aiData.sources);
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: aiData.sources,
                    searchResults: aiData.search_results_count,
                    filtersApplied: appliedFilters,
                    isFollowUp: false
                });
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                if (fetchError.message.includes('Failed to fetch')) {
                    throw new Error('Connection failed - please check your connection and try again');
                }
                
                throw fetchError;
            }
        }



        async function applyAIFilters(filters, sources = []) {
            // Update the voice filters state
            Object.assign(voiceFilters, filters);
            
            // Update the UI elements
            if (filters.search) {
                document.getElementById('voice-search-input').value = filters.search;
            }
            if (filters.recordType) {
                document.getElementById('voice-record-type-filter').value = filters.recordType;
            }
            if (filters.sortBy) {
                document.getElementById('voice-sort-by').value = filters.sortBy;
            }
            
            // Update applied filters display
            displayAppliedFilters(filters, sources);
            
            // Reload records with new filters
            await loadVoiceRecords(true);
            
            console.log('[Voice] Applied AI filters:', filters);
        }

        function displayAppliedFilters(filters, sources) {
            const display = document.getElementById('applied-filters-display');
            const container = document.getElementById('filter-chips-container');
            const rationale = document.getElementById('filter-rationale');
            
            // Clear existing chips
            container.innerHTML = '';
            
            // Create filter chips
            let hasFilters = false;
            if (filters.search) {
                addFilterChip(container, 'Search', filters.search);
                hasFilters = true;
            }
            if (filters.recordType) {
                addFilterChip(container, 'Type', filters.recordType);
                hasFilters = true;
            }
            if (filters.sortBy && filters.sortBy !== 'inArweaveBlock:desc') {
                addFilterChip(container, 'Sort', filters.sortBy.replace(':', ' '));
                hasFilters = true;
            }
            
            if (hasFilters) {
                display.classList.remove('hidden');
                
                // Use rationale from backend or generate fallback
                const rationaleText = filters.rationale || `AI applied these filters automatically based on your query.`;
                rationale.textContent = rationaleText;
            } else {
                display.classList.add('hidden');
            }
        }

        function addFilterChip(container, label, value) {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';
            chip.textContent = `${label}: ${value}`;
            container.appendChild(chip);
        }

        // No audio playback needed for text chat

        // Conversation Management
        function addToConversation(role, content, metadata = {}) {
            const message = {
                role,
                content,
                timestamp: new Date().toISOString(),
                ...metadata
            };
            
            chatState.conversation.push(message);
            updateConversationDisplay();
        }

        function updateConversationDisplay() {
            const container = document.getElementById('chat-messages');
            const emptyState = document.getElementById('chat-empty-state');
            
            if (chatState.conversation.length === 0) {
                emptyState.style.display = 'flex';
                container.innerHTML = '';
                return;
            }
            
            emptyState.style.display = 'none';
            container.innerHTML = '';
            
            // Show all messages
            chatState.conversation.forEach((message, index) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}`;
                
                const avatar = getMessageAvatar(message.role);
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                
                                 // No action buttons needed for text-only chat
                
                let sourcesHtml = '';
                if (message.role === 'assistant' && message.sources && message.sources.length > 0) {
                    sourcesHtml = `
                        <div class="message-sources">
                            <span class="source-count">📚 ${message.sources.length} sources found</span>
                        </div>
                    `;
                }
                
                                 messageDiv.innerHTML = `
                     <div class="message-avatar">${avatar}</div>
                     <div class="message-content">
                         <div class="message-text">${escapeHtml(message.content)}</div>
                         ${sourcesHtml}
                         <div class="message-meta">
                             <span class="message-timestamp">${timestamp}</span>
                         </div>
                     </div>
                 `;
                
                container.appendChild(messageDiv);
            });
            
            // Scroll to bottom
            const chatConversation = document.getElementById('chat-conversation');
            chatConversation.scrollTop = chatConversation.scrollHeight;
            
            // Ensure chat input is visible and enabled after display update - multiple attempts
            ensureChatInputReady();
            setTimeout(() => ensureChatInputReady(), 50);
            setTimeout(() => ensureChatInputReady(), 200);
        }

        function ensureChatInputReady() {
            // First, ensure the old browse tab isn't interfering
            forcehideBrowseTab();
            
            const chatInput = document.getElementById('ai-chat-input');
            const sendBtn = document.getElementById('ai-chat-send-btn');
            const chatContainer = document.querySelector('.chat-input-container');
            const chatInputRow = document.querySelector('.chat-input-row');
            
            if (chatInput) {
                // Force input to be visible and enabled
                chatInput.disabled = false;
                chatInput.style.display = 'block !important';
                chatInput.style.visibility = 'visible !important';
                chatInput.style.opacity = '1 !important';
                chatInput.style.pointerEvents = 'auto !important';
                chatInput.style.position = 'relative !important';
                chatInput.style.zIndex = '999 !important';
                chatInput.removeAttribute('readonly');
                chatInput.removeAttribute('hidden');
                chatInput.classList.remove('hidden');
                
                // Ensure the input is not being hidden by other elements
                if (chatInput.offsetHeight === 0 || chatInput.offsetWidth === 0) {
                    chatInput.style.height = '44px';
                    chatInput.style.width = '100%';
                    chatInput.style.minHeight = '44px';
                }
                
                console.log('[Chat] Input restored - height:', chatInput.offsetHeight, 'width:', chatInput.offsetWidth);
            }
            
            if (sendBtn) {
                sendBtn.disabled = chatState.isProcessing;
                sendBtn.style.display = 'inline-block !important';
                sendBtn.style.visibility = 'visible !important';
                sendBtn.style.opacity = '1 !important';
                sendBtn.style.pointerEvents = 'auto !important';
                sendBtn.removeAttribute('hidden');
                sendBtn.classList.remove('hidden');
            }
            
            if (chatContainer) {
                chatContainer.style.display = 'block !important';
                chatContainer.style.visibility = 'visible !important';
                chatContainer.style.opacity = '1 !important';
                chatContainer.style.pointerEvents = 'auto !important';
                chatContainer.removeAttribute('hidden');
                chatContainer.classList.remove('hidden');
            }
            
            if (chatInputRow) {
                chatInputRow.style.display = 'flex !important';
                chatInputRow.style.visibility = 'visible !important';
                chatInputRow.style.opacity = '1 !important';
                chatInputRow.removeAttribute('hidden');
                chatInputRow.classList.remove('hidden');
            }
            
            console.log('[Chat] Input availability forcefully ensured');
        }

        function getMessageAvatar(role) {
            switch (role) {
                case 'user': return '👤';
                case 'assistant': return '🤖';
                case 'system': return '⚠️';
                default: return '💬';
            }
        }

        // STT (Speech-to-Text) Functions
        
        // Voice Activity Detection configuration
        const VAD_CONFIG = {
            silenceThreshold: 0.01,
            silenceTimeoutMs: 2000,
            minRecordingMs: 1500,
            volumeThreshold: 0.12,
        };

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator?.mediaDevices?.getUserMedia);
            const hasMediaRecorder = typeof MediaRecorder !== 'undefined';
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            
            return hasMediaDevices && hasMediaRecorder && hasAudioContext;
        }

        async function toggleRecording() {
            if (chatState.isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            if (!checkBrowserSupport()) {
                updateAIStatus('Browser does not support voice recording');
                return;
            }

            try {
                chatState.mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                await setupVAD(chatState.mediaStream);

                chatState.mediaRecorder = new MediaRecorder(chatState.mediaStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                chatState.audioChunks = [];

                chatState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chatState.audioChunks.push(event.data);
                    }
                };

                chatState.mediaRecorder.onstop = async () => {
                    if (chatState.audioChunks.length > 0) {
                        const audioBlob = new Blob(chatState.audioChunks, { type: 'audio/webm' });
                        await processAudioBlob(audioBlob);
                    }
                };

                chatState.mediaRecorder.start();
                chatState.isRecording = true;
                updateMicrophoneButton();
                updateAIStatus('Recording... Speak now');

            } catch (error) {
                console.error('Error starting recording:', error);
                updateAIStatus('Microphone access denied');
                cleanupRecording();
            }
        }

        async function setupVAD(stream) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            chatState.audioContext = new AudioContext();

            if (chatState.audioContext.state === 'suspended') {
                await chatState.audioContext.resume();
            }

            chatState.analyser = chatState.audioContext.createAnalyser();
            chatState.analyser.fftSize = 512;

            const source = chatState.audioContext.createMediaStreamSource(stream);
            source.connect(chatState.analyser);

            const bufferLength = chatState.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const monitorAudio = () => {
                if (!chatState.analyser || !chatState.isRecording) return;

                chatState.analyser.getByteFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength) / 255;

                const now = Date.now();

                if (rms > VAD_CONFIG.volumeThreshold) {
                    chatState.lastSpeechTime = now;
                    chatState.isListening = true;
                    updateMicrophoneButton();

                    if (chatState.silenceTimeout) {
                        clearTimeout(chatState.silenceTimeout);
                        chatState.silenceTimeout = null;
                    }
                } else {
                    const recordingDuration = now - (chatState.lastSpeechTime || now);

                    if (recordingDuration > VAD_CONFIG.minRecordingMs && chatState.lastSpeechTime > 0) {
                        if (!chatState.silenceTimeout) {
                            chatState.silenceTimeout = setTimeout(() => {
                                stopRecording();
                            }, VAD_CONFIG.silenceTimeoutMs);
                        }
                    }

                    chatState.isListening = false;
                    updateMicrophoneButton();
                }
            };

            chatState.vadInterval = setInterval(monitorAudio, 100);
        }

        function stopRecording() {
            if (chatState.mediaRecorder && chatState.isRecording) {
                chatState.mediaRecorder.stop();
            }
            
            chatState.isRecording = false;
            chatState.isListening = false;
            updateMicrophoneButton();
            cleanupVAD();

            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            updateAIStatus('Processing speech...');
        }

        function cleanupVAD() {
            if (chatState.vadInterval) {
                clearInterval(chatState.vadInterval);
                chatState.vadInterval = null;
            }

            if (chatState.silenceTimeout) {
                clearTimeout(chatState.silenceTimeout);
                chatState.silenceTimeout = null;
            }

            if (chatState.analyser) {
                chatState.analyser = null;
            }
        }

        function cleanupRecording() {
            cleanupVAD();
            
            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            if (chatState.audioContext && chatState.audioContext.state !== 'closed') {
                chatState.audioContext.close();
                chatState.audioContext = null;
            }

            chatState.isRecording = false;
            chatState.isTranscribing = false;
            chatState.isListening = false;
            updateMicrophoneButton();
        }

        async function processAudioBlob(audioBlob) {
            try {
                chatState.isTranscribing = true;
                updateMicrophoneButton();
                updateAIStatus('Transcribing speech...');

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                
                // Add language if specified
                const language = document.getElementById('stt-language').value;
                if (language && language !== 'auto') {
                    formData.append('language', language);
                }

                const response = await fetch('/api/voice/transcribe', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Speech transcription failed');
                }

                const data = await response.json();
                const transcribedText = data.text?.trim();

                if (!transcribedText) {
                    updateAIStatus('No speech detected. Try again.');
                    return;
                }

                console.log('[STT] Transcribed:', transcribedText);

                // Put transcribed text in the input field
                const input = document.getElementById('ai-chat-input');
                input.value = transcribedText;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 120) + 'px';

                updateAIStatus('Speech transcribed! Click "Ask AI" or press Enter');

            } catch (error) {
                console.error('Transcription error:', error);
                updateAIStatus('Speech transcription failed');
            } finally {
                chatState.isTranscribing = false;
                updateMicrophoneButton();
            }
        }

        function updateMicrophoneButton() {
            const micBtn = document.getElementById('mic-btn');
            
            // Reset all classes
            micBtn.classList.remove('recording', 'listening', 'transcribing');
            
            if (chatState.isTranscribing) {
                micBtn.classList.add('transcribing');
                micBtn.innerHTML = '🔄';
                micBtn.title = 'Processing speech...';
            } else if (chatState.isRecording) {
                if (chatState.isListening) {
                    micBtn.classList.add('listening');
                    micBtn.innerHTML = '🎤';
                    micBtn.title = 'Listening... (click to stop)';
                } else {
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = '🔴';
                    micBtn.title = 'Recording... (click to stop)';
                }
            } else {
                micBtn.innerHTML = '🎤';
                micBtn.title = 'Click to record voice message';
            }
        }

        function clearConversation() {
            // Stop any current recording
            if (chatState.isRecording) {
                stopRecording();
            }
            
            // Clear conversation array
            chatState.conversation = [];
            
            // Clear follow-up tracking state
            chatState.lastSearchResults = [];
            chatState.lastSearchSubject = '';
            chatState.lastSearchKeywords = [];
            
            // Update display
            updateConversationDisplay();
            
            // Clear any applied filters
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            // Ensure input is ready
            ensureChatInputReady();
            
            updateAIStatus('Ready to answer questions!');
        }

        // No conversation mode needed for text chat

        // Voice Filtering Functions
        function applyVoiceFilters() {
            collectVoiceFilters();
            loadVoiceRecords(true);
        }

        function collectVoiceFilters() {
            voiceFilters.search = document.getElementById('voice-search-input').value.trim();
            voiceFilters.recordType = document.getElementById('voice-record-type-filter').value;
            voiceFilters.sortBy = document.getElementById('voice-sort-by').value;
            voiceFilters.resolveDepth = parseInt(document.getElementById('voice-resolve-depth').value) || 2;
            voiceFilters.dateStart = document.getElementById('voice-date-start').value;
            voiceFilters.dateEnd = document.getElementById('voice-date-end').value;
            voiceFilters.tag = document.getElementById('voice-tag-filter').value;
            voiceFilters.includeSigs = document.getElementById('voice-include-sigs-toggle').classList.contains('active');
            voiceFilters.includePubKeys = document.getElementById('voice-include-pubkeys-toggle').classList.contains('active');
        }

        function handleVoiceSearchKeyup(event) {
            if (event.key === 'Enter') {
                applyVoiceFilters();
            }
        }

        function clearVoiceFilters() {
            document.getElementById('voice-search-input').value = '';
            document.getElementById('voice-record-type-filter').value = '';
            document.getElementById('voice-sort-by').value = 'inArweaveBlock:desc';
            document.getElementById('voice-resolve-depth').value = '2';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-tag-filter').value = '';
            document.getElementById('voice-include-sigs-toggle').classList.remove('active');
            document.getElementById('voice-include-pubkeys-toggle').classList.remove('active');
            
            // Clear applied filters display
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            applyVoiceFilters();
        }

        function toggleVoiceSwitch(elementId) {
            document.getElementById(elementId).classList.toggle('active');
        }

        // Voice Records Loading Functions
        async function loadVoiceRecords(reset = false) {
            if (voiceIsLoading) return;
            
            try {
                voiceIsLoading = true;
                
                if (reset) {
                    voicePage = 1;
                    voiceRecords = [];
                    document.getElementById('voice-records-grid').innerHTML = '';
                }
                
                document.getElementById('voice-loading-indicator').classList.remove('hidden');
                
                const params = buildVoiceApiParams();
                const response = await fetch(`/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        voiceRecords = data.records;
                    } else {
                        voiceRecords = [...voiceRecords, ...data.records];
                    }
                    
                    voiceHasMoreRecords = data.totalPages > voicePage;
                    displayVoiceRecords(data.records, !reset);
                    updateVoicePaginationInfo(data);
                    updateVoiceTagFilter(data.tagSummary);
                } else {
                    showVoiceNoResults();
                }
                
                updateVoiceLoadMoreButton();
                
            } catch (error) {
                console.error('[Voice] Error loading records:', error);
                showVoiceNoResults();
            } finally {
                voiceIsLoading = false;
                document.getElementById('voice-loading-indicator').classList.add('hidden');
            }
        }

        function buildVoiceApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: voicePage.toString(),
                sortBy: voiceFilters.sortBy,
                resolveDepth: voiceFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '25',
                includeSigs: voiceFilters.includeSigs.toString(),
                includePubKeys: voiceFilters.includePubKeys.toString()
            });

            if (voiceFilters.search) {
                params.append('search', voiceFilters.search.trim());
            }
            
            if (voiceFilters.recordType) {
                params.append('recordType', voiceFilters.recordType);
            }
            
            if (voiceFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(voiceFilters.dateStart));
            }
            
            if (voiceFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(voiceFilters.dateEnd));
            }
            
            if (voiceFilters.tag) {
                params.append('tags', voiceFilters.tag);
            }

            return params.toString();
        }

        function displayVoiceRecords(records, append = false) {
            const grid = document.getElementById('voice-records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = voiceRecords.length - records.length;
            records.forEach((record, index) => {
                const card = createVoiceRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
            document.getElementById('voice-no-results').classList.add('hidden');
        }

                 function createVoiceRecordCard(record, recordIndex) {
             // Use the same card creation logic as the main browse tab
             // but with voice- prefixed IDs for unique identification
             const card = createRecordCard(record, recordIndex);
             
             // Update any IDs to be voice-specific to avoid conflicts
             const audioBtn = card.querySelector('.audio-play-btn');
             if (audioBtn) {
                 audioBtn.id = `voice-audioBtn-${recordIndex}`;
                 
                 // Extract audio URL from record data
                 let audioUrl = '';
                 const recordType = getRecordType(record);
                 const specificData = record.data?.[recordType] || {};
                 const basicData = record.data?.basic || {};
                 
                 if (specificData.audioItems && specificData.audioItems.length > 0) {
                     audioUrl = specificData.audioItems[0]?.data?.audio?.webUrl || specificData.audioItems[0];
                 } else if (basicData.audioItems && basicData.audioItems.length > 0) {
                     audioUrl = basicData.audioItems[0]?.data?.audio?.webUrl || basicData.audioItems[0];
                 }
                 
                 audioBtn.onclick = () => playAudioInMaster(
                     audioUrl, 
                     record.data?.basic?.name || 'Unnamed Record',
                     recordType,
                     recordIndex
                 );
             }
             
             // Fix the text toggle button (for embedded text content)
             const textBtn = card.querySelector('.toggle-text-btn');
             if (textBtn) {
                 textBtn.id = `voice-textBtn-${recordIndex}`;
                 textBtn.onclick = () => toggleVoiceTextContent(recordIndex, 
                     textBtn.getAttribute('data-type') || 'static',
                     textBtn.getAttribute('data-url') || ''
                 );
             }
             
             // Fix the view article button (for opening original webUrl)
             const viewBtn = card.querySelector('.view-article-btn');
             if (viewBtn) {
                 viewBtn.id = `voice-viewBtn-${recordIndex}`;
                 // Keep the original onclick functionality for opening in new tab
             }
             
             const textContent = card.querySelector('.text-content-preview');
             if (textContent) {
                 textContent.id = `voice-textContent-${recordIndex}`;
             }
             
             return card;
         }

        function showVoiceNoResults() {
            document.getElementById('voice-records-grid').classList.add('hidden');
            document.getElementById('voice-no-results').classList.remove('hidden');
        }

        function updateVoicePaginationInfo(data) {
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${voiceRecords.length} of ${data.totalRecords || 'many'} records`;
        }

        function updateVoiceTagFilter(tagSummary) {
            if (!tagSummary) return;
            
            const select = document.getElementById('voice-tag-filter');
            const currentValue = select.value;
            select.innerHTML = '<option value="">All Tags</option>';
            
            tagSummary.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag.tag;
                option.textContent = `${tag.tag} (${tag.count})`;
                select.appendChild(option);
            });
            
            select.value = currentValue;
        }

        function updateVoiceLoadMoreButton() {
            const container = document.getElementById('voice-load-more-container');
            const button = document.getElementById('voice-load-more-btn');
            
            if (voiceHasMoreRecords && voiceRecords.length > 0) {
                container.classList.remove('hidden');
                button.disabled = voiceIsLoading;
                button.textContent = voiceIsLoading ? 'Loading...' : 'Load More Records';
            } else {
                container.classList.add('hidden');
            }
        }

        function loadMoreVoiceRecords() {
            if (!voiceHasMoreRecords || voiceIsLoading) return;
            voicePage++;
            loadVoiceRecords(false);
        }

                 // Voice-specific text content toggle (for embedded text content)
         async function toggleVoiceTextContent(recordIndex, sourceType, sourceUrl) {
             const textContent = document.getElementById(`voice-textContent-${recordIndex}`);
             const toggleBtn = document.getElementById(`voice-textBtn-${recordIndex}`);
             
             if (textContent.classList.contains('hidden')) {
                 // Show content
                 textContent.classList.remove('hidden');
                 
                 if (sourceType === 'fetch' && sourceUrl) {
                     // Check if we already fetched the content
                     if (!textContent.dataset.fetched) {
                         try {
                             toggleBtn.textContent = '📄 Loading...';
                             toggleBtn.disabled = true;
                             
                             const response = await fetch(sourceUrl);
                             if (!response.ok) {
                                 throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                             }
                             const text = await response.text();
                             
                             textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                             textContent.dataset.fetched = 'true';
                             toggleBtn.textContent = '📄 Hide Full Text';
                             toggleBtn.disabled = false;
                         } catch (error) {
                             console.error('Error fetching text content:', error);
                             textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                 <strong>Error loading text:</strong><br>
                                 ${escapeHtml(error.message)}<br>
                                 <small>URL: ${escapeHtml(sourceUrl)}</small>
                             </div>`;
                             toggleBtn.textContent = '❌ Failed to Load';
                             toggleBtn.disabled = false;
                         }
                     } else {
                         toggleBtn.textContent = '📄 Hide Full Text';
                     }
                 } else if (sourceType === 'static') {
                     // Static content - just show it
                     const staticContent = textContent.dataset.staticContent;
                     if (staticContent) {
                         textContent.innerHTML = staticContent;
                     }
                     toggleBtn.textContent = '📄 Hide Full Text';
                 }
             } else {
                 // Hide content
                 textContent.classList.add('hidden');
                 if (sourceType === 'fetch') {
                     toggleBtn.textContent = '📄 Show Full Text';
                 } else {
                     toggleBtn.textContent = '📄 Show Full Text';
                 }
             }
         }

        // Text content toggle function
        async function toggleTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Article';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading article:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Article';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Load Full Article';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }


    </script>
</body>
</html> 