<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ΛLΞXΛNDRIΛ - A decentralized library of art, history, knowledge and memes</title>
    <link rel="icon" type="image/png" href="blue-alexandria-logo.png">
    <script src="/config.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            min-height: 100vh;
            color: #2d3748;
            margin: 0;
            padding: 0;
        }

        .header {
            background: #1a1a1a;
            color: white;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.8rem;
            font-weight: 100;
            letter-spacing: 3px;
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            text-transform: uppercase;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
        }

        .nav-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #a0a0a0;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            position: relative;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .nav-tab.active {
            color: white;
            background: rgba(255,255,255,0.15);
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .jwt-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .jwt-indicator {
            font-size: 14px;
        }

        .jwt-user-info {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .ai-drawer-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-drawer-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .ai-drawer-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .gun-sync-status {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 8px;
        }

        .gun-sync-status:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .gun-sync-status.healthy {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
        }

        .gun-sync-status.unhealthy {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
        }

        .gun-sync-status.disabled {
            background: rgba(156, 163, 175, 0.2);
            border-color: rgba(156, 163, 175, 0.4);
            opacity: 0.7;
        }

        /* User Menu Styles */
        .user-menu {
            position: relative;
        }

        .user-menu-button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 100px;
        }

        .user-menu-button:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .user-menu-button.authenticated {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
        }

        .user-menu-indicator {
            font-size: 16px;
        }

        .user-menu-text {
            flex: 1;
            text-align: left;
        }

        .user-menu-arrow {
            font-size: 12px;
            transition: transform 0.2s ease;
        }

        .user-menu-button.open .user-menu-arrow {
            transform: rotate(180deg);
        }

        .user-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 280px;
            margin-top: 8px;
            border: 1px solid #e5e7eb;
            backdrop-filter: blur(10px);
        }

        .user-menu-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
        }

        .user-details {
            flex: 1;
        }

        .user-email {
            font-weight: 600;
            color: #1f2937;
            font-size: 14px;
        }

        .user-key {
            font-size: 12px;
            color: #6b7280;
            font-family: monospace;
        }

        .user-menu-section {
            padding: 12px 0;
        }

        .menu-section-title {
            padding: 0 16px 8px 16px;
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .user-menu-item {
            width: 100%;
            padding: 12px 16px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: #374151;
        }

        .user-menu-item:hover {
            background: #f3f4f6;
        }

        .user-menu-item.logout-item {
            color: #dc2626;
        }

        .user-menu-item.logout-item:hover {
            background: #fef2f2;
        }

        .user-menu-divider {
            height: 1px;
            background: #e5e7eb;
            margin: 8px 0;
        }

        .jwt-status-inline {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #6b7280;
        }

        /* Header Search Styles */
        .header-search {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            max-width: 600px;
            margin: 0 20px;
        }

        .header-search input {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .header-search input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .header-search input:focus {
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.15);
        }

        .filters-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }

        .filters-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .filters-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        /* Filters Drawer Styles */
        .filters-drawer {
            position: fixed;
            top: 64px;
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 998;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            max-height: calc(100vh - 64px);
            overflow-y: auto;
        }

        .filters-drawer.open {
            transform: translateY(0);
        }

        .filters-drawer-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px 24px;
        }

        /* AI Drawer Styles */
        .ai-drawer {
            position: fixed;
            top: 64px;
            right: -50vw;
            width: 50vw;
            height: calc(100vh - 64px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-drawer.open {
            right: 0;
        }

        .ai-drawer-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            color: white;
            flex-shrink: 0;
        }

        .ai-drawer-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Main content with drawer */
        .main-content {
            transition: margin-right 0.3s ease;
            min-height: calc(100vh - 64px);
        }

        .main-content.drawer-open {
            margin-right: 50vw;
        }

        /* Welcome Interface Styles */
        .welcome-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 164px);
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        .welcome-title {
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            font-size: 4rem;
            font-weight: 100;
            letter-spacing: 4px;
            color: #2d3748;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: #718096;
            margin-bottom: 60px;
            font-weight: 400;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 30px;
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
        }

        .category-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
        }

        .category-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            color: inherit;
            text-decoration: none;
        }

        .category-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .category-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #4a5568;
        }

        /* Search Bar in Welcome */
        .welcome-search {
            max-width: 600px;
            width: 100%;
            margin-bottom: 40px;
        }

        .welcome-search input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .welcome-search input:focus {
            border-color: #667eea;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .advanced-search-toggle {
            margin-top: 20px;
        }

        .advanced-search-toggle button {
            background: transparent;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .advanced-search-toggle button:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: none;
            box-shadow: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        #publish-tab {
            position: relative;
            top: 0;
            padding-top: 20px;
            margin-top: 0;
        }

        .filters-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .filters-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .filter-group.wide {
            flex: 1;
            min-width: 180px;
        }

        .filter-group.compact {
            flex: 0 0 auto;
            min-width: 140px;
        }

        .search-container {
            flex: 3;
            min-width: 300px;
        }

        .records-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 600px;
        }

        /* Records Header Styles */
        #voice-records-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            gap: 20px;
        }

        .records-header-left {
            flex: 1;
        }

        .records-header-right {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .header-control-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .header-control-group label {
            font-size: 0.9rem;
            color: #555;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .header-control-group select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }

        /* Records Grid View */
        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* Records List View */
        .records-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .record-card.list-view {
            display: flex;
            gap: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
            transition: all 0.3s ease;
            max-height: 180px;
            overflow: hidden;
        }

        .record-card.list-view:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .record-card.list-view .media-preview {
            width: 140px;
            height: 100px;
            flex-shrink: 0;
            border-radius: 8px;
            overflow: hidden;
        }

        .record-card.list-view .record-content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .record-card.list-view .record-header {
            margin-bottom: 8px;
        }

        .record-card.list-view .record-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .record-card.list-view .record-description {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #666;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .record-card.list-view .list-meta-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .record-card.list-view .list-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .record-card.list-view .play-btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .record-card.list-view .tags-container {
            margin: 8px 0 0 0;
        }

        .record-card.list-view .tag-chip {
            font-size: 10px;
            padding: 2px 6px;
        }

        /* Podcast List View Specific */
        .podcast-show-card.list-view {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #667eea;
        }

        .podcast-show-card.list-view .podcast-show-header {
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .podcast-show-card.list-view .podcast-show-header img {
            width: 60px;
            height: 60px;
        }

        .record-card.list-view .podcast-date {
            font-size: 11px;
        }

        .record-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
            transition: all 0.3s ease;
        }

        .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-type {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .record-block {
            color: #666;
            font-size: 0.9rem;
        }

        .record-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .record-content {
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .record-meta {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.8rem;
            color: #999;
        }

        .tags-container {
            margin-top: 10px;
        }

        .tag {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin: 2px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag:hover {
            background: #667eea;
            color: white;
        }

        /* Media content styling */
        .media-content {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .media-item {
            margin: 10px 0;
        }

        .media-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .media-item img:hover {
            transform: scale(1.02);
        }

        .media-item audio,
        .media-item video {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .media-item button {
            transition: all 0.2s;
        }

        .media-item button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .text-content {
            border: 1px solid #dee2e6;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .media-item label {
            color: #495057;
            font-size: 14px;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        /* Upload Progress Styles */
        .upload-progress {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #45a049);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Media Preview Styles */
        .media-preview {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }

        .media-preview h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        /* Info Box Styles */
        .info-box {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .info-box h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .info-box ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .info-box li {
            margin-bottom: 5px;
        }

        /* GIF Reference Row Styles */
        .gif-ref-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fafafa;
        }

        .gif-ref-row:hover {
            background: #f0f0f0;
        }

        .gif-ref-row label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }

        .gif-ref-row input {
            font-size: 12px;
            padding: 4px 6px;
        }

        /* Button Group Styles */
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 120px;
        }

        /* Status Message Styles */
        .status-message {
            margin-top: 15px;
        }

        .success-message {
            padding: 10px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            border-radius: 4px;
            font-size: 14px;
        }

        .error-message {
            padding: 10px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            .gif-ref-row {
                flex-direction: column;
                gap: 8px;
            }
            
            .gif-ref-row > div {
                flex: none !important;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                min-width: auto;
            }
            
            .jwt-user-info {
                max-width: 80px;
            }
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 28px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .logged-in-user {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            font-size: 14px;
        }

        .dynamic-fields {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background: white;
        }

        .field-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .field-row > div {
            flex: 1;
        }

        .field-row button {
            margin: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .date-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-inputs input {
            width: 143px;
            min-width: 130px;
            flex: 0 0 auto;
        }

        .date-inputs span {
            color: #666;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .advanced-filters {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .toggle-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .load-more {
            text-align: center;
            margin: 20px 0;
        }

        .no-results {
            text-align: center;
            color: #999;
        }

        /* Multi-Tag Filter Styles */
        .multi-tag-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tag-mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-mode-selector label {
            font-size: 0.9rem;
            color: #666;
            margin: 0;
            font-weight: 500;
        }

        .tag-mode-selector select {
            padding: 4px 8px;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .tag-filters-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tag-filter-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-filter-select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .add-tag-btn, .remove-tag-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
        }

        .add-tag-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .remove-tag-btn {
            border-color: #dc3545;
            color: #dc3545;
        }

        .remove-tag-btn:hover {
            background: #dc3545;
            color: white;
            transform: translateY(-1px);
        }

        .tag-filter-row:first-child .remove-tag-btn {
            display: none; /* Hide remove button on first row */
        }

        /* Resolve hint styling */
        .resolve-hint {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px dashed #6c757d;
            color: #495057;
            text-align: center;
            padding: 20px;
            cursor: help;
        }

        .resolve-hint:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: none; /* Override hover transform */
        }

        /* Responsive Layout for Multi-Tag Filters */
        @media (max-width: 768px) {
            .filters-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .filter-group.compact,
            .filter-group.wide {
                min-width: 100%;
            }
            
            .date-inputs input {
                width: 156px;
            }
        }

        /* When many tag filters are present, optimize spacing */
        .tag-filters-container.has-many-tags {
            gap: 6px;
        }

        .tag-filters-container.has-many-tags .tag-filter-select {
            padding: 6px 10px;
            font-size: 13px;
        }

        .tag-filters-container.has-many-tags .add-tag-btn,
        .tag-filters-container.has-many-tags .remove-tag-btn {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }

        /* Master Audio Player */
        .master-audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .master-audio-player.visible {
            transform: translateY(0);
        }

        .audio-player-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .audio-info {
            flex: 1;
            min-width: 0;
        }

        .audio-title {
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .audio-meta {
            font-size: 12px;
            opacity: 0.8;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .audio-controls button:hover {
            background: rgba(255,255,255,0.3);
            transform: none;
            box-shadow: none;
        }

        .audio-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        .audio-progress-bar {
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .audio-time {
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .record-card .audio-play-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .record-card .audio-play-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .record-card .audio-play-btn.playing {
            background: #dc3545;
        }

        .record-card .audio-play-btn.playing:hover {
            background: #c82333;
        }

        .text-content-preview {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .toggle-text-btn {
            background: #17a2b8;
            font-size: 12px;
            padding: 4px 8px;
        }

        .toggle-text-btn:hover {
            background: #138496;
        }

        .record-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .record-image:hover {
            transform: scale(1.02);
        }

                    /* Ensure body has padding for fixed audio player */
        body {
            margin-bottom: 80px;
        }
        
        /* Main content adjustments for fixed header on mobile */
        @media (max-width: 768px) {
            .main-content {
                margin-top: 0;
                padding-top: 0;
            }
            
            .container {
                padding: 15px;
            }
        }

        /* AI Chat Integration Styles */
        .ai-chat-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 500px;
            max-height: 700px;
            overflow: hidden;
            contain: layout;
        }

        .chat-header {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 15px;
            flex-shrink: 0;
        }

        .chat-conversation {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            min-height: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .chat-message .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .message-avatar {
            background: rgba(59, 130, 246, 0.8);
        }

        .chat-message.assistant .message-avatar {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-avatar {
            background: rgba(239, 68, 68, 0.8);
        }

        .message-content {
            flex: 1;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            position: relative;
        }

        .chat-message.user .message-content {
            background: rgba(59, 130, 246, 0.8);
            margin-left: auto;
        }

        .chat-message.assistant .message-content {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-content {
            background: rgba(239, 68, 68, 0.8);
            font-style: italic;
        }

        .message-text {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.8;
        }

        .message-timestamp {
            font-size: 11px;
            opacity: 0.7;
        }

        .mic-btn {
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            padding: 16px 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 60px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-left: 20px;
        }

        .mic-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .mic-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .mic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .mic-btn.recording {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(239, 68, 68, 1);
            animation: pulse 1.5s infinite;
        }

        .mic-btn.listening {
            background: rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 1);
            animation: pulse 2s infinite;
        }

        .mic-btn.transcribing {
            background: rgba(59, 130, 246, 0.8);
            border-color: rgba(59, 130, 246, 1);
            animation: spin 1s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .message-sources {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
        }

        .source-count {
            font-weight: bold;
        }

        .chat-input-container {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        #ai-chat-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-height: 60px;
            resize: vertical;
            max-height: 200px;
            display: block !important;
            visibility: visible !important;
            font-family: inherit;
            line-height: 1.5;
        }

        #ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #ai-chat-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .chat-send-btn {
            padding: 16px 32px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(10px);
            min-height: 60px;
        }

        .chat-send-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-status {
            text-align: left;
            padding: 8px 8px 8px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            backdrop-filter: blur(10px);
            opacity: 0.9;
            font-size: 12px;
        }

        .chat-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            opacity: 0.8;
        }

        .chat-empty-state .emoji {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .chat-empty-state h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .chat-empty-state p {
            font-size: 14px;
            opacity: 0.8;
        }

        .ai-settings {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .ai-setting {
            flex: 1;
            min-width: 200px;
        }

        .ai-setting label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }

        .ai-setting select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .applied-filters {
            background: rgba(59, 130, 246, 0.15);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .filter-chip {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 16px;
            margin: 4px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .conversation-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .conversation-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .conversation-message.user {
            background: rgba(59, 130, 246, 0.3);
            margin-left: 20px;
        }

        .conversation-message.assistant {
            background: rgba(34, 197, 94, 0.3);
            margin-right: 20px;
        }

        .conversation-message .timestamp {
            font-size: 11px;
            opacity: 0.7;
            display: block;
            margin-top: 4px;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots:after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Microphone icon styles */
        .microphone-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .pagination-info {
            text-align: center;
            color: #666;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        /* Dynamic Template Debugging Styles */
        .template-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
            color: #1976d2;
        }

        .field-type-indicator {
            background: #f3e5f5;
            color: #7b1fa2;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        .dref-resolved {
            border-left: 3px solid #4caf50;
            margin-left: 10px;
            padding-left: 10px;
            background: #f1f8e9;
            border-radius: 0 4px 4px 0;
        }

        /* ========================================================================
           MODERN MEDIA-FOCUSED CARD STYLES (YouTube/SoundCloud/Flickr Style)
           ======================================================================== */
        
        /* Media Preview Styles */
        .media-preview {
            position: relative;
            width: 100%;
            height: 200px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .media-preview:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .preview-image, .preview-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        .preview-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 48px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .audio-artwork {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .audio-icon {
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-visualizer {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .audio-visualizer .bar {
            width: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 2px;
            animation: audio-bounce 1.5s infinite ease-in-out;
        }

        .audio-visualizer .bar:nth-child(1) { height: 20px; animation-delay: -0.32s; }
        .audio-visualizer .bar:nth-child(2) { height: 15px; animation-delay: -0.16s; }
        .audio-visualizer .bar:nth-child(3) { height: 25px; animation-delay: 0s; }
        .audio-visualizer .bar:nth-child(4) { height: 18px; animation-delay: -0.24s; }

        @keyframes audio-bounce {
            0%, 80%, 100% { transform: scaleY(0.6); opacity: 0.8; }
            40% { transform: scaleY(1); opacity: 1; }
        }

        .media-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }

        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .video-preview:hover .play-overlay, 
        .podcast-preview:hover .play-overlay {
            opacity: 1;
        }

        .play-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .play-button:hover {
            transform: scale(1.1);
        }

        /* Record Content Styles */
        .record-content {
            padding: 0 5px;
        }

        .record-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .record-description {
            color: #7f8c8d;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
        }

        /* Media Control Styles */
        .media-controls, .article-controls, .web-controls {
            margin: 12px 0;
        }

        .play-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            font-size: 14px;
        }

        .play-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .play-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .play-btn.primary.playing {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.3);
        }

        .play-btn.secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .play-btn.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .article-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }

        .article-btn:hover {
            background: #e9ecef;
            border-color: #dee2e6;
            transform: translateY(-1px);
        }

        .web-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .web-btn:hover {
            background: #218838;
            transform: translateY(-1px);
            color: white;
        }

        .media-count {
            color: #6c757d;
            font-size: 12px;
            margin-left: 10px;
        }

        /* Record Footer Styles */
        .record-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid #e9ecef;
        }

        .show-structure-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #dee2e6;
            border-radius: 15px;
            color: #6c757d;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .show-structure-btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
            color: #495057;
        }

        .record-did {
            font-size: 10px;
            color: #adb5bd;
            font-family: monospace;
        }

        /* Record Structure (Collapsible Technical Details) */
        .record-structure {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .structure-header {
            padding: 12px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
        }

        .structure-header h4 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 14px;
        }

        /* Article Content Styles */
        .article-content {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #fff;
            overflow: hidden;
        }

        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .article-header h4 {
            margin: 0;
            color: #495057;
            font-size: 14px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .article-text {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap;
        }

        .article-error {
            padding: 15px;
            color: #dc3545;
            text-align: center;
        }

        /* Modal Styles */
        .video-modal, .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }

        .video-modal-content, .image-modal-content {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 90vh;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .video-modal-header, .image-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .video-modal-header h3, .image-modal-header h3 {
            margin: 0;
            color: #495057;
            font-size: 16px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Record Header Updates */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .record-type {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .record-date {
            color: #6c757d;
            font-size: 12px;
        }

        /* Enhanced Tags */
        .tags-container {
            margin: 12px 0;
        }

        .tag-chip {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px 4px 2px 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag-chip:hover {
            background: #dee2e6;
            transform: translateY(-1px);
        }

        /* Podcast Specific Styles */
        .podcast-preview {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
        }

        .podcast-info {
            margin-bottom: 10px;
        }

        .podcast-show {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .podcast-date {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #6c757d;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .podcast-citations {
            border-top: 1px solid #e9ecef;
            padding-top: 12px;
            margin-top: 15px;
        }

        .podcast-sources {
            max-height: 300px;
            overflow-y: auto;
        }

        .source-item {
            transition: all 0.2s ease;
        }

        .source-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .field-debug {
            background: #fff3e0;
            border: 1px solid #ff9800;
            padding: 5px;
            margin: 2px 0;
            font-size: 10px;
            border-radius: 3px;
        }

        .unresolved-dref {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .header {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1001;
            }
            
            .header-content {
                flex-direction: row;
                height: 64px;
                padding: 8px 15px;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
            }
            
            .logo {
                font-size: 1.2rem;
                letter-spacing: 1px;
                flex: 1;
            }
            
            .logo-icon {
                width: 28px;
                height: 28px;
            }
            
            .nav-tabs {
                display: flex;
                gap: 4px;
                flex-shrink: 0;
            }
            
            .nav-tab {
                padding: 6px 12px;
                font-size: 13px;
            }
            
            .auth-section {
                flex-shrink: 0;
            }
            
            .ai-drawer-toggle {
                padding: 6px 10px;
                font-size: 12px;
                gap: 4px;
            }
            
            .ai-drawer-toggle svg {
                width: 14px;
                height: 14px;
            }
            
            /* Add padding to body to account for fixed header */
            body {
                padding-top: 64px;
            }
            
            /* Header Search Mobile */
            .header-search {
                flex: 1;
                margin: 0 10px;
                max-width: none;
            }
            
            /* AI Drawer Mobile */
            .ai-drawer {
                width: 100%;
                right: -100%;
                top: 64px;
                height: calc(100vh - 64px);
                position: fixed;
                z-index: 9999;
            }
            
            .main-content.drawer-open {
                margin-right: 0;
                transform: translateX(-100%);
            }
            
            /* Mobile AI drawer content adjustments */
            .ai-drawer-content {
                height: calc(100% - 160px); /* More space for header and input */
                display: flex;
                flex-direction: column;
            }
            
            .chat-conversation {
                flex: 1;
                min-height: 150px;
                max-height: calc(100vh - 400px); /* Reduced to make room for input */
                overflow-y: auto;
                margin-bottom: 20px;
            }
            
            .ai-drawer.open .chat-input-container {
                position: fixed;
                bottom: 100px; /* Move up from bottom */
                left: 0;
                right: 0;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 20px;
                border-top: 2px solid rgba(255, 255, 255, 0.3);
                flex-shrink: 0;
                z-index: 10000;
                backdrop-filter: blur(10px);
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            }
            
            /* Welcome Interface Mobile */
            .welcome-interface {
                padding: 20px 15px;
                min-height: calc(100vh - 64px);
                margin-top: 0;
            }
            
            .welcome-title {
                font-size: 2.5rem;
                letter-spacing: 2px;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
                margin-bottom: 40px;
            }
            
            .categories-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                max-width: 400px;
            }
            
            .category-item {
                padding: 15px 10px;
            }
            
            .category-icon {
                font-size: 2rem;
                margin-bottom: 8px;
            }
            
            .category-label {
                font-size: 0.8rem;
            }
            
            .welcome-search input {
                padding: 14px 18px;
                font-size: 16px;
            }
            
            /* Search Interface Mobile */
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group,
            .filter-group.wide,
            .search-container {
                min-width: auto;
                flex: none;
            }
            
            /* Records Header Mobile */
            #voice-records-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .records-header-right {
                justify-content: flex-end;
                gap: 10px;
            }
            
            .header-control-group {
                min-width: 100px;
            }
            
            .header-control-group select {
                font-size: 12px;
                padding: 5px 8px;
            }
            
            .records-grid {
                grid-template-columns: 1fr;
            }
            
            /* List View Mobile */
            .records-list {
                gap: 10px;
            }
            
            .record-card.list-view {
                flex-direction: column;
                max-height: none;
                gap: 15px;
            }
            
            .record-card.list-view .media-preview {
                width: 100%;
                height: 120px;
            }
            
            .record-card.list-view .list-meta-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .record-card.list-view .list-controls {
                justify-content: center;
            }
            
            .field-row {
                flex-direction: column;
                gap: 5px;
            }
            
            .date-inputs {
                flex-direction: column;
            }
            
            .toggle-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            /* Mobile adjustments for AI drawer */
            .ai-drawer-header {
                padding: 15px;
                position: sticky;
                top: 0;
                background: inherit;
                z-index: 10001;
            }
            
            .ai-settings {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .ai-setting {
                flex: 1;
                min-width: auto;
            }
            
            /* AI status area adjustments */
            .ai-drawer.open .ai-status {
                position: fixed;
                bottom: 200px; /* Above the input area */
                left: 20px;
                right: 20px;
                z-index: 9999;
                text-align: center;
                background: rgba(102, 126, 234, 0.9);
                border-radius: 8px;
                margin: 0;
            }
            
            .chat-input-row {
                flex-direction: row;
                align-items: flex-end;
                gap: 10px;
                margin-bottom: 0;
            }
            
            #ai-chat-input {
                flex: 1;
                min-height: 44px;
                max-height: 120px;
                font-size: 16px;
                padding: 12px 16px;
            }
            
            .chat-send-btn {
                flex-shrink: 0;
                min-width: 80px;
                height: 44px;
                padding: 8px 16px;
                white-space: nowrap;
                font-size: 14px;
            }
            
            .mic-btn {
                flex-shrink: 0;
                width: 44px;
                height: 44px;
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
                margin-left: 0;
                margin-right: 10px;
            }
            
            .mic-btn svg {
                width: 20px;
                height: 20px;
            }
            
            .message-content {
                max-width: 85%;
            }
            
            /* Ensure input area stays visible */
            .ai-drawer.open {
                height: 100vh;
                height: 100dvh; /* Use dvh for better mobile support */
            }
            
            /* Applied filters adjustments for mobile */
            .applied-filters-display {
                position: relative;
                margin-bottom: 15px;
                z-index: 9998;
            }
            
            /* Only apply fixed positioning on small screens */
            @media (max-width: 768px) and (max-height: 800px) {
                .ai-drawer.open .chat-input-container {
                    bottom: 120px; /* Even higher on smaller screens */
                }
                
                .ai-drawer.open .ai-status {
                    bottom: 220px;
                }
            }
            
            /* Fix for iOS Safari bottom bar */
            @supports (-webkit-touch-callout: none) {
                .ai-drawer.open {
                    height: calc(100vh - env(safe-area-inset-bottom));
                }
                
                .ai-drawer.open .chat-input-container {
                    bottom: calc(100px + env(safe-area-inset-bottom));
                }
            }
        }

        /* Publishing Interface Styles */
        .publish-form {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        /* Smart Buttons Styles */
        .smart-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .smart-buttons button {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin: 0;
        }

        .smart-buttons .btn-secondary {
            background: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }

        .smart-buttons .btn-secondary:hover {
            background: #5a6268;
            border-color: #545b62;
        }

        .smart-buttons .btn-small {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 1px solid #667eea;
        }

        .smart-buttons .btn-small:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .smart-buttons .btn-small:disabled,
        .smart-buttons .btn-secondary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .publish-form h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .publish-form .form-group {
            margin-bottom: 20px;
        }

        .publish-form .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .publish-form input,
        .publish-form textarea,
        .publish-form select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .publish-form input:focus,
        .publish-form textarea:focus,
        .publish-form select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .publish-form textarea {
            resize: vertical;
            min-height: 120px;
            font-family: inherit;
            line-height: 1.5;
        }

        .publish-form small {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .media-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .media-section h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1rem;
        }

        .ingredient-row,
        .exercise-row {
            display: grid;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .ingredient-row {
            grid-template-columns: 80px 100px 1fr 40px;
        }

        .exercise-row {
            grid-template-columns: 1fr 80px 80px 80px 40px;
        }

        .ingredient-row input,
        .exercise-row input {
            margin-bottom: 0;
        }

        .ingredient-row button,
        .exercise-row button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid #dc3545;
            background: white;
            color: #dc3545;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ingredient-row button:hover,
        .exercise-row button:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }

        .publish-form input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            transform: scale(1.2);
        }

        .publish-form label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            font-weight: 500;
            cursor: pointer;
        }

        .publish-progress {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .publish-progress h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .publish-form {
                margin: 0;
                padding: 15px;
                border-radius: 0;
            }

            .ingredient-row {
                grid-template-columns: 60px 80px 1fr 35px;
                gap: 8px;
            }

            .exercise-row {
                grid-template-columns: 1fr 60px 60px 60px 35px;
                gap: 8px;
            }

            .ingredient-row input,
            .exercise-row input {
                font-size: 13px;
                padding: 8px 10px;
            }

            .media-section {
                margin: 15px 0;
                padding: 15px;
            }
        }

        /* Record View Interface Styles */
        .record-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e5e7eb;
        }

        .back-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .back-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .record-view-meta {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .record-type-badge {
            background: #f0f4ff;
            color: #3730a3;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .record-did-badge {
            background: #f3f4f6;
            color: #6b7280;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-family: monospace;
        }

        .record-view-content {
            background: white;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Post Article Layout Styles */
        .post-article-layout {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px 16px;
        }

        .post-article-header {
            margin-bottom: 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 16px;
        }

        .post-article-title {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1.2;
            color: #1f2937;
            margin-bottom: 16px;
        }

        .post-article-summary {
            font-size: 1.125rem;
            line-height: 1.6;
            color: #6b7280;
            margin-bottom: 8px;
            font-style: italic;
        }

        .post-article-summary.collapsed {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .keep-reading-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            padding: 4px 0;
            margin-top: 4px;
            margin-bottom: 8px;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .keep-reading-btn:hover {
            color: #5a67d8;
            text-decoration: underline;
        }

        .post-article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .post-article-byline {
            font-size: 14px;
            color: #374151;
        }

        .post-article-byline strong {
            color: #1f2937;
        }

        .post-article-date {
            font-size: 14px;
            color: #6b7280;
        }

        .post-featured-media {
            margin: 8px 0 8px 0;
        }

        .post-featured-image {
            float: left;
            width: 100%;
            max-width: 350px;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin: 0 20px 12px 0;
            shape-outside: margin-box;
        }

        .post-featured-video {
            width: 100%;
            max-width: 600px;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .post-audio-section {
            margin: 6px 0 0 0;
            padding: 10px 14px;
            background: #f0f4ff;
            border-radius: 6px;
            border: 1px solid #c7d2fe;
            display: inline-block;
            max-width: 100%;
        }

        .post-audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .post-summary-with-audio {
            margin-bottom: 16px;
        }

        .post-content {
            font-size: 1.125rem;
            line-height: 1.8;
            color: #374151;
            margin-top: 12px;
        }

        .post-content-wrapper {
            overflow: hidden; /* Clearfix for floating image */
        }

        .post-content::after {
            content: "";
            display: table;
            clear: both;
        }

        .post-content p {
            margin-bottom: 20px;
        }

        .post-content h1, .post-content h2, .post-content h3,
        .post-content h4, .post-content h5, .post-content h6 {
            margin: 32px 0 16px 0;
            color: #1f2937;
        }

        .post-content h1 { font-size: 2rem; }
        .post-content h2 { font-size: 1.75rem; }
        .post-content h3 { font-size: 1.5rem; }

        .post-content blockquote {
            border-left: 4px solid #667eea;
            padding-left: 16px;
            margin: 24px 0;
            font-style: italic;
            color: #6b7280;
        }

        .post-content ul, .post-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .post-content li {
            margin-bottom: 8px;
        }

        .post-tags {
            margin-top: 32px;
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
        }

        .post-tags .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .post-tags .tag-chip {
            background: #e0e7ff;
            color: #3730a3;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Responsive adjustments for record view */
        @media (max-width: 768px) {
            .post-article-layout {
                padding: 16px 12px;
            }
            
            .post-article-title {
                font-size: 1.75rem;
            }
            
            .post-featured-image {
                float: none;
                max-width: 100%;
                margin: 0 0 16px 0;
                display: block;
            }
            
            .post-featured-media {
                margin: 12px 0;
            }
            
            .post-summary-with-audio {
                margin-bottom: 12px;
            }
            
            .record-view-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }
            
            .record-view-meta {
                align-self: flex-end;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo" onclick="showWelcomeInterface()" style="cursor: pointer;">
                <img src="blue-alexandria-logo.png" alt="ALEXANDRIA" class="logo-icon">
                ΛLΞXΛNDRIΛ
            </div>
            
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="showSearchInterface()">Browse</div>
                <div class="nav-tab" onclick="showPublishTab()">Publish</div>
            </div>
            
            <div id="header-search" class="header-search hidden">
                <input type="text" id="header-search-input" placeholder="Search the archive..." onkeydown="handleHeaderSearch(event)">
                <button id="filters-toggle" class="filters-toggle" onclick="toggleFiltersDrawer()" title="Show filters">⋯</button>
            </div>
            
            <div class="auth-section">
                <button id="gun-sync-status" class="gun-sync-status" onclick="showGunSyncModal()" title="Check GUN sync status">
                    <span id="gun-sync-indicator">🔄</span>
                    <span>Sync</span>
                </button>
                <button id="ai-drawer-toggle" class="ai-drawer-toggle" onclick="toggleAIDrawer()">
                    <img src="alfred.gif" alt="ΛLFRED" style="width: 16px; height: 16px; margin-right: 6px;">
                    ΛLFRED
                </button>
                
                <!-- Unified User Menu -->
                <div id="user-menu" class="user-menu">
                    <button id="user-menu-button" class="user-menu-button" onclick="toggleUserMenu()">
                        <span id="user-menu-indicator" class="user-menu-indicator">🔓</span>
                        <span id="user-menu-text" class="user-menu-text">Account</span>
                        <span class="user-menu-arrow">▼</span>
                    </button>
                    
                    <div id="user-menu-dropdown" class="user-menu-dropdown hidden">
                        <!-- Authenticated User Menu -->
                        <div id="authenticated-menu" class="hidden">
                            <div class="user-menu-header">
                                <div class="user-avatar">👤</div>
                                <div class="user-details">
                                    <div id="user-email-display" class="user-email">user@example.com</div>
                                    <div id="user-key-display" class="user-key">...abc123</div>
                                </div>
                            </div>
                            
                            <div class="user-menu-section">
                                <div class="menu-section-title">🔑 Wallet Management</div>
                                <button onclick="showMnemonicModal()" class="user-menu-item">
                                    <span>📝</span>
                                    <span>View Recovery Phrase</span>
                                </button>
                            </div>
                            
                            <div class="user-menu-section">
                                <div class="menu-section-title">🔐 Authentication</div>
                                <button onclick="showJWTModal()" class="user-menu-item">
                                    <span>🎫</span>
                                    <span>JWT Token</span>
                                </button>
                                <div class="jwt-status-inline">
                                    <span id="jwt-status-icon">🔓</span>
                                    <span id="jwt-status-text">Token Status</span>
                                </div>
                            </div>
                            
                            <div class="user-menu-divider"></div>
                            
                            <button onclick="logout()" class="user-menu-item logout-item">
                                <span>🚪</span>
                                <span>Logout</span>
                            </button>
                        </div>
                        
                        <!-- Unauthenticated User Menu -->
                        <div id="unauthenticated-menu">
                            <div class="user-menu-section">
                                <div class="menu-section-title">🔐 Account Access</div>
                                <button onclick="showAuthModal('login')" class="user-menu-item">
                                    <span>🔑</span>
                                    <span>Login</span>
                                </button>
                                <button onclick="showAuthModal('register')" class="user-menu-item">
                                    <span>📝</span>
                                    <span>Register</span>
                                </button>
                                <button onclick="showAuthModal('import')" class="user-menu-item">
                                    <span>📥</span>
                                    <span>Import Wallet</span>
                                </button>
                            </div>
                            
                            <div class="user-menu-divider"></div>
                            
                            <div class="user-menu-section">
                                <div class="menu-section-title">🎫 Advanced</div>
                                <button onclick="showJWTModal()" class="user-menu-item">
                                    <span>🎫</span>
                                    <span>JWT Token</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Filters Drawer -->
    <div id="filters-drawer" class="filters-drawer">
        <div class="filters-drawer-content">
            <!-- This will contain the moved filters content -->
        </div>
    </div>

    <!-- AI Drawer -->
    <div id="ai-drawer" class="ai-drawer">
        <div class="ai-drawer-header">
            <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                <img src="alfred.gif" alt="ΛLFRED" style="width: 20px; height: 20px;">
                ΛLFRED
            </h3>
            
            <div class="ai-settings" style="margin-top: 15px;">
                <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                    <label for="ai-model-select">AI Model</label>
                    <select id="ai-model-select">
                        <option value="llama3.2:3b">LLaMA 3.2 3B (Fast)</option>
                        <option value="mistral:latest">Mistral 7B (Balanced)</option>
                        <option value="llama2:latest">LLaMA 2 7B (Quality)</option>
                        <option value="tinyllama:latest" selected>TinyLlama (Ultra Fast)</option>
                        <option value="grok-4">Grok-4 (Premium Cloud)</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                    <label for="stt-language">Speech Language</label>
                    <select id="stt-language">
                        <option value="auto">Auto-detect</option>
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block;">
                    <label for="voice-engine">Voice Engine</label>
                    <select id="voice-engine" onchange="switchVoiceEngine()">
                        <option value="chatterbox">Chatterbox TTS (High Quality + Voice Cloning)</option>
                        <option value="edge_tts">Edge TTS (Fast + Many Voices)</option>
                        <option value="elevenlabs" selected>ElevenLabs (Premium + Ultra Fast)</option>
                    </select>
                </div>
            </div>

            <!-- Voice Selection -->
            <div class="ai-settings" style="margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 200px;">
                    <label for="voice-select" id="voice-select-label">Voice:</label>
                    <select id="voice-select" onchange="updateVoiceSelection()">
                        <option value="loading">Loading voices...</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block;">
                    <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; color: rgba(255, 255, 255, 0.8); cursor: pointer;">
                        <input type="checkbox" id="tts-enabled" checked style="accent-color: #3b82f6;" onchange="toggleTTSEnabled()">
                        <span id="tts-enable-label">Enable Voice Synthesis</span>
                    </label>
                </div>
            </div>

            <!-- Chatterbox-specific controls -->
            <div id="chatterbox-controls" class="ai-settings" style="margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">Chatterbox Voice Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="emotion-slider" style="font-size: 12px;">Emotion Level: <span id="emotion-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>😐</span>
                        <input type="range" id="emotion-slider" min="0" max="100" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateEmotion(this.value)">
                        <span>🎭</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="pacing-slider" style="font-size: 12px;">Speech Pacing: <span id="pacing-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🐌</span>
                        <input type="range" id="pacing-slider" min="30" max="70" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updatePacing(this.value)">
                        <span>🚀</span>
                    </div>
                </div>
            </div>

            <!-- Edge TTS-specific controls -->
            <div id="edge-controls" class="ai-settings" style="display: none; margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">Edge TTS Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="edge-speed" style="font-size: 12px;">Speech Speed: <span id="speed-value">100%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🐌</span>
                        <input type="range" id="edge-speed" min="50" max="200" value="100" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateSpeed(this.value)">
                        <span>🚀</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="edge-pitch" style="font-size: 12px;">Pitch: <span id="pitch-value">0Hz</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔽</span>
                        <input type="range" id="edge-pitch" min="-10" max="10" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updatePitch(this.value)">
                        <span>🔼</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="edge-volume" style="font-size: 12px;">Volume: <span id="volume-value">0%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔉</span>
                        <input type="range" id="edge-volume" min="-20" max="20" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateVolume(this.value)">
                        <span>🔊</span>
                    </div>
                </div>
            </div>

            <!-- ElevenLabs-specific controls -->
            <div id="elevenlabs-controls" class="ai-settings" style="display: none; margin-top: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.8); font-weight: 600; margin-bottom: 8px;">ElevenLabs Controls</div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-stability" style="font-size: 12px;">Stability: <span id="stability-value">50%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🎯</span>
                        <input type="range" id="elevenlabs-stability" min="0" max="100" value="50" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateStability(this.value)">
                        <span>🏔️</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-similarity" style="font-size: 12px;">Similarity Boost: <span id="similarity-value">75%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>🔀</span>
                        <input type="range" id="elevenlabs-similarity" min="0" max="100" value="75" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateSimilarity(this.value)">
                        <span>🎭</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; margin-right: 15px; min-width: 140px;">
                    <label for="elevenlabs-style" style="font-size: 12px;">Style Intensity: <span id="style-value">0%</span></label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>📖</span>
                        <input type="range" id="elevenlabs-style" min="0" max="100" value="0" 
                               style="flex: 1; accent-color: #3b82f6;" oninput="updateStyle(this.value)">
                        <span>🎨</span>
                    </div>
                </div>
                <div class="ai-setting" style="display: inline-block; min-width: 140px;">
                    <label for="elevenlabs-model" style="font-size: 12px;">Model:</label>
                    <select id="elevenlabs-model" onchange="updateModel(this.value)">
                        <option value="eleven_turbo_v2" selected>Turbo v2 (Fastest)</option>
                        <option value="eleven_monolingual_v1">Monolingual v1 (Quality)</option>
                        <option value="eleven_multilingual_v2">Multilingual v2 (Multi-lang)</option>
                    </select>
                </div>
            </div>

            <div id="applied-filters-display" class="applied-filters hidden" style="margin-top: 15px; background: rgba(59, 130, 246, 0.2); border: 2px solid rgba(59, 130, 246, 0.5); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <div style="margin-bottom: 8px; font-weight: bold; color: #1e40af; background: rgba(255, 255, 255, 0.8); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(30, 64, 175, 0.3);">AI Applied Filters:</div>
                <div id="filter-chips-container"></div>
                <div id="filter-rationale" style="margin-top: 8px; font-size: 12px; color: #374151; opacity: 0.9;"></div>
            </div>
        </div>
        
        <div class="ai-drawer-content">
            <div id="chat-conversation" class="chat-conversation">
                <div id="chat-empty-state" class="chat-empty-state">
                    <h3>Start a conversation</h3>
                    <p>Ask questions about your data and I'll help you find answers!</p>
                </div>
                <div id="chat-messages"></div>
            </div>

            <div class="chat-input-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div class="ai-status" id="ai-status" style="flex: 1; margin-bottom: 0; margin-right: 10px;">
                        <div id="ai-status-text">Ready to answer questions!</div>
                    </div>
                    <button onclick="clearConversation()" class="btn-secondary btn-small" style="background: #6b7280; border: 1px solid #9ca3af; color: white; margin: 0;">
                        Clear Chat
                    </button>
                </div>
                
                <div class="chat-input-row">
                    <button id="mic-btn" onclick="toggleRecording()" class="mic-btn" title="Click to record voice message">
                        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <path d="M50,10 C43.373,10 38,15.373 38,22 L38,50 C38,56.627 43.373,62 50,62 C56.627,62 62,56.627 62,50 L62,22 C62,15.373 56.627,10 50,10 Z M50,15 C53.866,15 57,18.134 57,22 L57,50 C57,53.866 53.866,57 50,57 C46.134,57 43,53.866 43,50 L43,22 C43,18.134 46.134,15 50,15 Z M20,45 L20,50 C20,66.568 33.432,80 50,80 C66.568,80 80,66.568 80,50 L80,45 L85,45 L85,50 C85,69.33 69.33,85 50,85 L50,90 L60,90 L60,95 L40,95 L40,90 L50,90 L50,85 C30.67,85 15,69.33 15,50 L15,45 L20,45 Z"/>
                        </svg>
                    </button>
                    <textarea id="ai-chat-input" placeholder="Ask a question about your data or click the microphone..." onkeydown="handleChatKeydown(event)" rows="1"></textarea>
                    <button id="ai-chat-send-btn" onclick="sendChatMessage()" class="chat-send-btn">
                        <span>Ask AI</span>
                    </button>
                </div>
                <div style="margin-top: 8px; font-size: 12px; opacity: 0.9; display: flex; gap: 8px; align-items: center;">
                    <label for="alfred-pinned-did" style="min-width: 120px;">Pinned Record DID:</label>
                    <input id="alfred-pinned-did" type="text" placeholder="did:arweave:... (optional)" style="flex:1; padding:6px; border-radius:4px; border:1px solid #888;" onchange="onPinnedDidChange(this.value)" />
                    <button class="btn-small" onclick="clearPinnedDid()">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="main-content">
        <!-- Welcome Interface -->
        <div id="welcome-interface" class="welcome-interface">
            <h1 class="welcome-title">ΛLΞXΛNDRIΛ</h1>
            <p class="welcome-subtitle">A decentralized library of art, history, knowledge and memes.</p>
            
            <div class="welcome-search">
                <input type="text" id="welcome-search-input" placeholder="Search the archive..." onkeydown="handleWelcomeSearch(event)">
                <div class="advanced-search-toggle">
                    <button onclick="showAdvancedSearch()">Advanced Search</button>
                </div>
            </div>
            
            <div id="categories-grid" class="categories-grid">
                <!-- Categories will be populated dynamically from recordTypes -->
            </div>
        </div>

        <!-- Search Interface -->
        <div id="search-interface" class="container hidden">
            <!-- Filters Section (Enhanced Version) -->
            <div class="filters-section" style="position: relative; z-index: 1; background: white; border: 2px solid rgba(102, 126, 234, 0.1);">
                <!-- Hidden search input for backward compatibility -->
                <input type="hidden" id="voice-search-input" value="">
                
                <div class="filters-row">
                    <div class="filter-group">
                        <label for="voice-record-type-filter">Record Type</label>
                        <select id="voice-record-type-filter" onchange="applyVoiceFilters()">
                            <option value="">All Types</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-storage-filter">Storage Type</label>
                        <select id="voice-storage-filter" onchange="applyVoiceFilters()">
                            <option value="all" selected>All Sources</option>
                            <option value="arweave">Arweave (Permanent)</option>
                            <option value="gun">GUN (Private/Drafts)</option>
                            <option value="irys">Irys (Permanent)</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-search-match-mode" title="Controls how search terms are matched">
                            Search Mode
                            <span style="opacity: 0.6; font-size: 0.8rem;">(?)</span>
                        </label>
                        <select id="voice-search-match-mode" onchange="applyVoiceFilters()" 
                                title="AND = all terms required, OR = any term matches">
                            <option value="AND">Match ALL terms</option>
                            <option value="OR">Match ANY term</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-resolve-depth" title="Higher values resolve more linked records. Set to 1+ to see recipe images.">
                            Resolve Depth
                            <span style="opacity: 0.6; font-size: 0.8rem;">(?)</span>
                        </label>
                        <input type="number" id="voice-resolve-depth" value="2" min="0" max="5" onchange="applyVoiceFilters()" 
                               title="2 recommended for images. 0=fastest, 5=most complete">
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-did-tx">DID TX</label>
                        <input type="text" id="voice-did-tx" placeholder="did:arweave:..." onchange="validateAndApplyDidTx()" oninput="clearDidTxError()">
                        <div id="did-tx-error" class="hidden" style="color: #dc3545; font-size: 0.8rem; margin-top: 4px;">Please provide a valid DID address</div>
                    </div>
                </div>
                
                <div class="filters-row">
                    <div class="filter-group compact">
                        <label>Date Range</label>
                        <div class="date-inputs">
                            <input type="date" id="voice-date-start" onchange="applyVoiceFilters()" placeholder="Start Date">
                            <span>to</span>
                            <input type="date" id="voice-date-end" onchange="applyVoiceFilters()" placeholder="End Date">
                        </div>
                    </div>
                    
                    <div class="filter-group wide">
                        <label for="multi-tag-container">Filter by Tags</label>
                        <div id="multi-tag-container" class="multi-tag-container">
                            <!-- Tag Match Mode Selector -->
                            <div class="tag-mode-selector">
                                <label for="tag-match-mode">Match:</label>
                                <select id="tag-match-mode" onchange="applyVoiceFilters()">
                                    <option value="OR">ANY tag (OR)</option>
                                    <option value="AND">ALL tags (AND)</option>
                                </select>
                            </div>
                            
                            <!-- Tag Filters Container -->
                            <div id="tag-filters-container" class="tag-filters-container">
                                <div class="tag-filter-row" data-tag-index="0">
                                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                                        <option value="">Select a tag...</option>
                                    </select>
                                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                                </div>
                            </div>
                            
                            <!-- Legacy single tag filter (hidden) for backward compatibility -->
                            <select id="voice-tag-filter" style="display: none;">
                                <option value="">All Tags</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="advanced-filters">
                    <div class="toggle-row">
                        <div class="toggle-group">
                            <label>Include Signatures:</label>
                            <div class="toggle-switch" id="voice-include-sigs-toggle" onclick="toggleVoiceSwitch('voice-include-sigs-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Include Public Keys:</label>
                            <div class="toggle-switch" id="voice-include-pubkeys-toggle" onclick="toggleVoiceSwitch('voice-include-pubkeys-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Includes Audio:</label>
                            <div class="toggle-switch" id="voice-includes-audio-toggle" onclick="toggleVoiceSwitch('voice-includes-audio-toggle')"></div>
                        </div>
                        
                        <button onclick="clearVoiceFilters()" class="btn-secondary btn-small">Clear Filters</button>
                        <button onclick="applyVoiceFilters()" class="btn-small">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Records Display (Enhanced Version) -->
            <div class="records-container">
                <div id="voice-records-header">
                    <div class="records-header-left">
                        <h2>OIP Records</h2>
                        <div id="voice-pagination-info" class="pagination-info"></div>
                    </div>
                    <div class="records-header-right">
                        <div class="header-control-group">
                            <label for="voice-sort-by">Sort By</label>
                            <select id="voice-sort-by" onchange="applyVoiceFilters()">
                                <option value="matchCount:desc" selected>Relevance (Highest)</option>
                                <option value="matchCount:asc">Relevance (Lowest)</option>
                                <option value="inArweaveBlock:desc">Block (Newest)</option>
                                <option value="inArweaveBlock:asc">Block (Oldest)</option>
                                <option value="date:desc">Date (Newest)</option>
                                <option value="date:asc">Date (Oldest)</option>
                            </select>
                        </div>
                        <div class="header-control-group">
                            <label for="voice-view-as">View As</label>
                            <select id="voice-view-as" onchange="changeViewMode()">
                                <option value="grid">Grid</option>
                                <option value="list">List</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div id="voice-loading-indicator" class="loading">
                    <div class="spinner"></div>
                    Loading records...
                </div>
                
                <div id="voice-records-grid" class="records-grid hidden"></div>
                
                <div id="voice-no-results" class="no-results hidden">
                    No records found matching your criteria.
                </div>
                
                <div id="voice-load-more-container" class="load-more hidden">
                    <button onclick="loadMoreVoiceRecords()" id="voice-load-more-btn">Load More Records</button>
                </div>
            </div>
        </div>

        <!-- Publish Tab Content -->
        <div id="publish-tab" class="container hidden">
            <div class="section">
                <h2>Publishing Platform</h2>
                <p>Please log in to access publishing features.</p>
                
                <div id="publishing-content" class="hidden">
                    <div class="filters-row">
                        <button onclick="showCreatorRegistration()">Register Creator</button>
                        <button onclick="showTemplateCreation()">Create Template</button>
                        <button onclick="showRecordPublishing()">Publish Record</button>
                    </div>
                </div>
            </div>

            <!-- Creator Registration -->
            <div id="creator-section" class="section hidden">
                <h2>Creator Registration</h2>
                <div class="form-group">
                    <label for="creator-name">Creator Name:</label>
                    <input type="text" id="creator-name" required>
                </div>
                <div class="form-group">
                    <label for="creator-description">Description:</label>
                    <textarea id="creator-description"></textarea>
                </div>
                <div class="form-group">
                    <label for="creator-email">Email:</label>
                    <input type="email" id="creator-email">
                </div>
                <div class="form-group">
                    <label for="creator-website">Website:</label>
                    <input type="url" id="creator-website">
                </div>
                <button onclick="registerCreator()">Register Creator</button>
                <div id="creator-status" class="error-message hidden"></div>
                <div id="creator-success" class="success-message hidden"></div>
            </div>

            <!-- Template Creation -->
            <div id="template-section" class="section hidden">
                <h2>Template Creation</h2>
                <div class="form-group">
                    <label for="template-name">Template Name:</label>
                    <input type="text" id="template-name" required>
                </div>
                <div class="form-group">
                    <label for="template-recordtype">Record Type:</label>
                    <input type="text" id="template-recordtype" required placeholder="e.g., post, recipe, workout">
                </div>
                <div class="dynamic-fields">
                    <h3>Template Fields</h3>
                    <div id="template-fields">
                        <div class="field-row">
                            <div>
                                <label>Field Name:</label>
                                <input type="text" class="field-name" placeholder="e.g., title, content">
                            </div>
                            <div>
                                <label>Field Type:</label>
                                <select class="field-type">
                                    <option value="string">String</option>
                                    <option value="number">Number</option>
                                    <option value="boolean">Boolean</option>
                                    <option value="enum">Enum</option>
                                    <option value="array">Array</option>
                                </select>
                            </div>
                            <div>
                                <button type="button" onclick="removeField(this)">Remove</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" onclick="addTemplateField()">Add Field</button>
                </div>
                <button onclick="createTemplate()">Create Template</button>
                <div id="template-status" class="error-message hidden"></div>
                <div id="template-success" class="success-message hidden"></div>
            </div>

            <!-- Record Publishing -->
            <div id="record-section" class="section hidden">
                <h2>Publish Record</h2>
                
                                    <!-- Record Type Selection -->
                    <div class="form-group">
                        <label for="publish-record-type">Record Type:</label>
                        <select id="publish-record-type" onchange="loadPublishInterface()">
                            <option value="">Select Record Type</option>
                            <option value="post">Post / Article</option>
                            <option value="video">Video</option>
                            <option value="audio">Audio / Podcast</option>
                            <option value="music">Music</option>
                            <option value="image">Image</option>
                            <option value="recipe">Recipe</option>
                            <option value="workout">Workout</option>
                            <option value="exercise">Exercise</option>
                            <option value="exerciseBundle">🎯 Exercise Bundle (Complete Workflow)</option>
                            <option value="fitnessEquipment">Fitness Equipment</option>
                            <option value="media">Media File</option>
                            <option value="multiResolutionGif">Multi-Resolution GIF</option>
                            <option value="text">Text Document</option>
                            <option value="organization">Organization</option>
                        </select>
                    </div>

                    <!-- Storage Type Selection -->
                    <div class="form-group">
                        <label for="publish-storage-type">Storage Type:</label>
                        <select id="publish-storage-type">
                            <option value="arweave">Arweave (Permanent & Public)</option>
                            <option value="gun">GUN + BitTorrent (Private with P2P Distribution)</option>
                            <option value="irys">Irys (Permanent & Fast)</option>
                        </select>
                        <small>
                            <strong>Arweave:</strong> Permanent, public, immutable storage<br>
                            <strong>GUN + BitTorrent:</strong> Private storage with automatic BitTorrent distribution for P2P sharing<br>
                            <strong>Irys:</strong> Permanent, fast confirmation
                        </small>
                    </div>

                <!-- Dynamic Publishing Interface -->
                <div id="publish-interface" class="dynamic-fields">
                    <div class="loading">Select a record type to see publishing interface</div>
                </div>
                
                <div id="publish-status" class="error-message hidden"></div>
                <div id="publish-success" class="success-message hidden"></div>
            </div>
        </div>

        <!-- Individual Record View Interface -->
        <div id="record-view-interface" class="container hidden">
            <div class="record-view-header">
                <button onclick="goBackToBrowse()" class="back-btn">
                    ← Back to Browse
                </button>
                <div class="record-view-meta">
                    <span id="record-view-type" class="record-type-badge"></span>
                    <span id="record-view-did" class="record-did-badge"></span>
                </div>
            </div>
            
            <div id="record-view-content" class="record-view-content">
                <!-- Record content will be dynamically loaded here -->
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="auth-modal" class="modal hidden">
        <div class="modal-content">
            <div id="login-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" required>
                </div>
                <button onclick="login()">Login</button>
                <button onclick="showRegisterForm()" class="btn-secondary">Register Instead</button>
                <button onclick="showImportWalletForm()" class="btn-secondary">Import Wallet</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="register-form" class="hidden">
                <h2>Register New Account</h2>
                <div class="form-group">
                    <label for="register-email">Email:</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password:</label>
                    <input type="password" id="register-password" required>
                </div>
                <button onclick="register()">Register</button>
                <button onclick="showLoginForm()" class="btn-secondary">Login Instead</button>
                <button onclick="showImportWalletForm()" class="btn-secondary">Import Wallet</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="import-wallet-form" class="hidden">
                <h2>Import Existing Wallet</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Import your wallet using your recovery phrase from another OIP node.
                    <br><small>You'll need your 12-word recovery phrase and credentials.</small>
                </p>
                
                <div class="form-group">
                    <label for="import-email">Email:</label>
                    <input type="email" id="import-email" required>
                </div>
                <div class="form-group">
                    <label for="import-password">Password:</label>
                    <input type="password" id="import-password" required>
                </div>
                <div class="form-group">
                    <label for="import-mnemonic">Recovery Phrase (12 words):</label>
                    <textarea id="import-mnemonic" placeholder="abandon ability able about above absent absorb abstract absurd abuse access accident" 
                             style="height: 80px; font-family: monospace; font-size: 12px; resize: vertical;" required></textarea>
                    <small>Enter your 12-word recovery phrase separated by spaces</small>
                </div>
                
                <button onclick="importWallet()">Import Wallet</button>
                <button onclick="showLoginForm()" class="btn-secondary">Login Instead</button>
                <button onclick="showRegisterForm()" class="btn-secondary">Register New</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="auth-status" class="error-message hidden"></div>
            <div id="auth-success" class="success-message hidden"></div>
        </div>
    </div>
    
    <!-- Mnemonic Modal -->
    <div id="mnemonic-modal" class="modal hidden">
        <div class="modal-content">
            <h2 style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                <span>🔑</span>
                Your Wallet Recovery Phrase
            </h2>
            
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">⚠️ Security Warning</h4>
                <ul style="margin: 0; padding-left: 20px; color: #856404;">
                    <li>Never share your recovery phrase with anyone</li>
                    <li>Store it securely offline (write it down)</li>
                    <li>This phrase can restore your wallet on any OIP node</li>
                    <li>Anyone with this phrase can access your account</li>
                </ul>
            </div>
            
            <div class="form-group">
                <label for="mnemonic-password">Enter your password to view recovery phrase:</label>
                <input type="password" id="mnemonic-password" placeholder="Your account password" required>
            </div>
            
            <div id="mnemonic-display" class="hidden" style="background: #f8f9fa; border: 2px solid #667eea; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="margin: 0 0 15px 0; color: #667eea;">📝 Your Recovery Phrase:</h4>
                <div id="mnemonic-words" style="font-family: monospace; font-size: 16px; font-weight: 600; color: #1f2937; background: white; padding: 15px; border-radius: 6px; border: 1px solid #d1d5db; word-spacing: 8px; line-height: 1.8;"></div>
                <div style="margin-top: 15px; display: flex; gap: 10px;">
                    <button onclick="copyMnemonicToClipboard()" class="btn-secondary" style="flex: 1;">
                        📋 Copy to Clipboard
                    </button>
                    <button onclick="hideMnemonic()" class="btn-secondary" style="flex: 1;">
                        👁️ Hide Phrase
                    </button>
                </div>
            </div>
            
            <div id="mnemonic-status" class="hidden" style="margin: 15px 0;"></div>
            
            <div class="button-group">
                <button onclick="showMnemonic()" class="btn-primary">Show Recovery Phrase</button>
                <button onclick="hideMnemonicModal()" class="btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- JWT Token Modal -->
    <div id="jwt-modal" class="modal hidden">
        <div class="modal-content">
            <h2>JWT Token Authentication</h2>
            <p style="color: #666; margin-bottom: 20px;">
                Enter your JWT token to access private GUN records and media uploads.
                <br><small>Get your token by logging in via the API or registering a new account.</small>
            </p>
            
            <div class="form-group">
                <label for="jwt-token-input">JWT Token:</label>
                <textarea id="jwt-token-input" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." 
                         style="height: 80px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="jwt-remember" checked>
                    Remember token in localStorage
                </label>
            </div>
            
            <div class="button-group">
                <button onclick="setJWTToken()" class="btn-primary">Set Token</button>
                <button onclick="clearJWTToken()" class="btn-secondary">Clear Token</button>
                <button onclick="hideJWTModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="jwt-token-status" class="status-message" style="margin-top: 15px;"></div>
            
            <details style="margin-top: 20px;">
                <summary style="cursor: pointer; color: #666;">How to get a JWT token</summary>
                <div style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px;">
                    <p><strong>Option 1: Register via API</strong></p>
                    <pre style="background: #fff; padding: 8px; border-radius: 4px; overflow-x: auto;">POST /api/user/completeRegistration
{
  "email": "your@email.com",
  "password": "your_password"
}</pre>
                    
                    <p style="margin-top: 15px;"><strong>Option 2: Login via API</strong></p>
                    <pre style="background: #fff; padding: 8px; border-radius: 4px; overflow-x: auto;">POST /api/user/login
{
  "email": "your@email.com", 
  "password": "your_password"
}</pre>
                    
                    <p style="margin-top: 10px; color: #666;">
                        The API will return a JWT token that includes your HD wallet public key for private record access.
                    </p>
                </div>
            </details>
        </div>
    </div>

    <!-- GUN Sync Status Modal -->
    <div id="gun-sync-modal" class="modal hidden">
        <div class="modal-content">
            <h2 style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                <span id="gun-sync-modal-indicator">🔄</span>
                GUN Record Sync Status
            </h2>
            
            <div id="gun-sync-loading" class="loading" style="text-align: center; padding: 20px;">
                <div class="spinner"></div>
                Loading sync status...
            </div>
            
            <div id="gun-sync-content" class="hidden">
                <!-- Service Status -->
                <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #495057;">📊 Service Status</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div><strong>Status:</strong> <span id="sync-service-status">-</span></div>
                        <div><strong>Running:</strong> <span id="sync-service-running">-</span></div>
                        <div><strong>Node ID:</strong> <span id="sync-node-id" style="font-family: monospace; font-size: 12px;">-</span></div>
                        <div><strong>Last Sync:</strong> <span id="sync-last-time">-</span></div>
                    </div>
                </div>
                
                <!-- Sync Metrics -->
                <div class="form-group" style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #1976d2;">📈 Sync Metrics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div><strong>Records Discovered:</strong> <span id="sync-total-discovered">-</span></div>
                        <div><strong>Records Synced:</strong> <span id="sync-total-synced">-</span></div>
                        <div><strong>Success Rate:</strong> <span id="sync-success-rate">-</span></div>
                        <div><strong>Sync Cycles:</strong> <span id="sync-cycles">-</span></div>
                        <div><strong>Errors:</strong> <span id="sync-total-errors">-</span></div>
                        <div><strong>Avg Sync Time:</strong> <span id="sync-avg-time">-</span></div>
                    </div>
                </div>
                
                <!-- Registry Statistics -->
                <div class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #3730a3;">📋 Registry Statistics</h4>
                    <div style="font-size: 14px;">
                        <div><strong>Total Records Registered:</strong> <span id="registry-total-records">-</span></div>
                        <div style="margin-top: 8px;"><strong>Records by Type:</strong></div>
                        <div id="registry-by-type" style="margin-left: 15px; font-size: 13px; color: #666;">-</div>
                    </div>
                </div>
                
                <!-- Configuration -->
                <div class="form-group" style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #f57c00;">⚙️ Configuration</h4>
                    <div style="font-size: 14px;">
                        <div><strong>Private Records:</strong> <span id="sync-config-private">-</span></div>
                        <div><strong>Trusted Nodes:</strong> <span id="sync-config-trusted">-</span></div>
                        <div><strong>Sync Interval:</strong> <span id="sync-config-interval">-</span></div>
                    </div>
                </div>
            </div>
            
            <div id="gun-sync-error" class="hidden" style="background: #f8d7da; color: #721c24; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0;">❌ Sync Service Error</h4>
                <div id="gun-sync-error-message">-</div>
            </div>
            
            <div class="button-group">
                <button id="force-sync-btn" onclick="forceSyncCycle()" class="btn-primary" disabled>
                    🔄 Force Sync Now
                </button>
                <button onclick="refreshGunSyncStatus()" class="btn-secondary">
                    🔄 Refresh Status
                </button>
                <button onclick="hideGunSyncModal()" class="btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- Master Audio Player -->
    <div id="master-audio-player" class="master-audio-player">
        <div class="audio-player-content">
            <div class="audio-info">
                <div class="audio-title" id="audio-title">No audio selected</div>
                <div class="audio-meta" id="audio-meta">Select an audio file to play</div>
            </div>
            
            <div class="audio-controls">
                <button onclick="toggleAudioPlayback()" id="master-play-btn">▶️</button>
                <button onclick="stopAudio()">⏹️</button>
                <div class="audio-progress" onclick="seekAudio(event)">
                    <div class="audio-progress-bar" id="audio-progress-bar"></div>
                </div>
                <div class="audio-time" id="audio-time">0:00 / 0:00</div>
                <button onclick="closeMasterPlayer()">✕</button>
            </div>
        </div>
        
        <audio id="master-audio" style="display: none;" 
               ontimeupdate="updateAudioProgress()" 
               onended="onAudioEnded()"
               onloadedmetadata="onAudioLoaded()">
        </audio>
    </div>

    <script>
        // State management
        let authToken = localStorage.getItem('oip-auth-token');
        let currentUser = localStorage.getItem('oip-user-email');
        let templates = {};
        let defaultTemplates = {};
        // Enhanced template system variables
        let allTemplates = {}; // Maps template names and TxIds to template objects
        let templateFieldMap = {}; // Maps template names and TxIds to field definitions
        let showDebugInfo = false; // Controls debug information display
        let recordTypes = [];
        let currentRecords = [];
        let currentPage = 1;
        let isLoading = false;
        let hasMoreRecords = true;
        let currentFilters = {
            search: '',
            recordType: '',
            sortBy: 'date:desc',
            resolveDepth: 2,
            dateStart: '',
            dateEnd: '',
            tag: '',
            includeSigs: false,
            includePubKeys: false
        };
        let availableTags = [];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            console.log('[App] Starting enhanced initialization with dynamic templates...');
            
            // Initialize JWT token from localStorage
            initializeJWTToken();
            
            // Initialize GUN sync status checking
            initializeGunSyncStatus();
            
            // Initialize user menu state
            updateUserMenuState();
            
            // Always load templates first for dynamic rendering
            await loadTemplates();
            
            // Setup authentication state
            if (authToken && currentUser) {
                showLoggedInState();
            }
            
            // Load actual record types from the index
            await loadActualRecordTypes();
            
            // Force hide the old browse tab and ensure it stays hidden
            forcehideBrowseTab();
            
            // Initialize URL routing
            initializeRouting();
            
            // Don't show welcome interface by default anymore - let routing handle it
            // showWelcomeInterface();
            
            console.log('[App] Initialized with enhanced dynamic template system');
            
            // Set up periodic checks to ensure interface stays clean
            setInterval(() => {
                forcehideBrowseTab();
                
                // Quick check that chat input is still visible
                const chatInput = document.getElementById('ai-chat-input');
                if (chatInput && (chatInput.offsetHeight === 0 || chatInput.style.display === 'none')) {
                    console.log('[App] Detected hidden chat input, restoring...');
                    ensureChatInputReady();
                }
            }, 2000); // Check every 2 seconds
        }

        // Load actual record types from the index
        async function loadActualRecordTypes() {
            try {
                console.log('[App] Loading actual record types from index...');
                const response = await fetch('/api/records/recordTypes');
                const data = await response.json();
                
                if (response.ok && data.recordTypes) {
                    console.log('[App] Loaded record types:', data.recordTypes);
                    
                    // Store the actual record types with counts
                    recordTypes = data.recordTypes.map(rt => rt.recordType).sort();
                    
                    // Populate all record type dropdowns
                    populateAllRecordTypeDropdowns(data.recordTypes);
                    
                    console.log('[App] Populated record type dropdowns with', recordTypes.length, 'types');
                } else {
                    console.error('[App] Failed to load record types:', data.error || 'Unknown error');
                    // Fallback to basic types if API fails
                    recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                    populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
                }
            } catch (error) {
                console.error('[App] Error loading record types:', error);
                // Fallback to basic types if API fails
                recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
            }
        }

        // Populate all record type dropdowns with actual data
        function populateAllRecordTypeDropdowns(recordTypesData) {
            // Voice browse tab dropdown
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    voiceSelect.appendChild(option);
                });
                console.log('[App] Populated voice record type filter with', recordTypesData.length, 'types');
            }
            
            // Publishing record type dropdown
            const publishSelect = document.getElementById('record-type');
            if (publishSelect) {
                // Keep the first option as "Select Record Type"
                const firstOption = publishSelect.querySelector('option[value=""]');
                publishSelect.innerHTML = '';
                if (firstOption) {
                    publishSelect.appendChild(firstOption);
                } else {
                    publishSelect.innerHTML = '<option value="">Select Record Type</option>';
                }
                
                // Add actual record types
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    publishSelect.appendChild(option);
                });
                console.log('[App] Populated publishing record type filter with', recordTypesData.length, 'types');
            }
            
            // Populate categories grid
            populateCategoriesGrid(recordTypesData);
        }
        
        // Populate the categories grid dynamically from recordTypes
        function populateCategoriesGrid(recordTypesData) {
            const grid = document.getElementById('categories-grid');
            if (!grid) return;
            
            // Icon mapping for different record types - using SVG icons
            const iconMap = {
                'post': '<img src="noun-copywriting-4038314-9B9B9B.svg" alt="Post" style="width: 40px; height: 40px;">',
                'video': '📹', 
                'audio': '<img src="noun-speaker-1445776-9B9B9B.svg" alt="Audio" style="width: 40px; height: 40px;">',
                'recipe': '<img src="noun-plate-4303489-9B9B9B.svg" alt="Recipe" style="width: 40px; height: 40px;">',
                'workout': '💪',
                'podcast': '<img src="noun-podcast-7882058-9B9B9B.svg" alt="Podcast" style="width: 40px; height: 40px;">',
                'movie': '🎬',
                'music': '🎵',
                'book': '📚',
                'document': '📄',
                'software': '💻',
                'archive': '🗃️',
                'thing': '🏛️'
            };
            
            // Record types to exclude from home page buttons
            const excludedTypes = ['deletemessage', 'replyto', 'nutritionalinfo', 'image', 'text', 'audioitems', 'imageitems', 'videoitems', '0', 'featuredimage', 'delete'];
            
            grid.innerHTML = '';
            
            // If no recordTypes data, show default categories
            if (!recordTypesData || recordTypesData.length === 0) {
                const defaultTypes = [
                    { recordType: 'post', count: 0 },
                    { recordType: 'video', count: 0 },
                    { recordType: 'audio', count: 0 },
                    { recordType: 'recipe', count: 0 },
                    { recordType: 'workout', count: 0 }
                ];
                recordTypesData = defaultTypes;
            }
            
            // Filter out excluded types and sort by count (descending)
            const filteredTypes = recordTypesData
                .filter(rt => !excludedTypes.includes(rt.recordType.toLowerCase()))
                .sort((a, b) => b.count - a.count)
                .slice(0, 12); // Limit to 12 categories max
            
            filteredTypes.forEach(rt => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category-item';
                categoryDiv.onclick = () => searchByRecordType(rt.recordType);
                
                const icon = iconMap[rt.recordType] || '📋';
                const label = rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1);
                
                categoryDiv.innerHTML = `
                    <div class="category-icon">${icon}</div>
                    <div class="category-label">${label}</div>
                `;
                
                grid.appendChild(categoryDiv);
            });
            
            console.log('[App] Populated categories grid with', filteredTypes.length, 'categories (excluded:', excludedTypes.join(', '), ')');
        }

        // Legacy function - now redirects to new implementation
        async function loadRecordTypes() {
            console.log('[App] Legacy loadRecordTypes called - redirecting to loadActualRecordTypes');
            await loadActualRecordTypes();
        }

        // Legacy function - now uses new implementation
        function populateRecordTypeFilter() {
            console.log('[App] Legacy populateRecordTypeFilter called - record types already populated');
        }

        // Legacy function - now uses new implementation
        function populateVoiceRecordTypeFilter(recordTypes) {
            console.log('[App] Legacy populateVoiceRecordTypeFilter called - record types already populated');
        }

        // Force hide the old browse tab completely
        function forcehideBrowseTab() {
            const browseTab = document.getElementById('browse-tab');
            if (browseTab) {
                browseTab.style.display = 'none !important';
                browseTab.style.visibility = 'hidden !important';
                browseTab.style.height = '0 !important';
                browseTab.style.overflow = 'hidden !important';
                browseTab.style.position = 'absolute !important';
                browseTab.style.top = '-9999px !important';
                browseTab.classList.add('hidden');
                console.log('[App] Old browse tab forcefully hidden');
            }
        }

        // Navigation functions (Updated for new interface)
        function showWelcomeInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            // No tab should be active when on home/welcome
            
            document.getElementById('welcome-interface').classList.remove('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        function showSearchInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[0].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.remove('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Show header search when on browse tab
            showHeaderSearch();
            
            // Ensure filters start in drawer, not on page
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            const filtersSection = document.querySelector('.filters-section');
            
            if (filtersSection && !drawer.contains(filtersSection)) {
                // Move filters to drawer initially
                document.querySelector('.filters-drawer-content').appendChild(filtersSection);
                drawer.classList.remove('open');
                toggle.classList.remove('active');
            }
            
            // Sync search values
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                headerSearch.value = hiddenSearch.value;
            }
            
            // Initialize voice features when search interface is shown
            initializeVoiceFeatures();
        }

        // URL Routing Functions
        function initializeRouting() {
            // Handle browser back/forward buttons
            window.addEventListener('popstate', (event) => {
                console.log('[Routing] Handling popstate:', event.state);
                handleUrlChange();
            });
            
            // Handle initial page load
            handleUrlChange();
        }

        function handleUrlChange() {
            const hash = window.location.hash.substr(1); // Remove the #
            console.log('[Routing] Handling URL change:', hash);
            
            if (hash.startsWith('browse/record=')) {
                // Individual record view
                const truncatedDidTx = hash.replace('browse/record=', '');
                // We need to reconstruct the full DID since we only have the truncated version
                // For now, we'll try to find it from current records or load it
                handleRecordNavigation(truncatedDidTx);
            } else if (hash === 'browse' || hash === '') {
                // Browse/search interface
                showSearchInterface();
            } else {
                // Default to browse interface
                showSearchInterface();
            }
        }

        async function handleRecordNavigation(truncatedDidTx) {
            console.log('[Routing] Handling record navigation for:', truncatedDidTx);
            
            // First try to find the record in current records
            const foundRecord = currentRecords.find(record => {
                const didTx = record.oip?.did || record.oip?.didTx || '';
                const recordTruncated = didTx.replace('did:arweave:', '').substring(0, 7);
                return recordTruncated === truncatedDidTx;
            });
            
            if (foundRecord) {
                console.log('[Routing] Found record in current records');
                showRecordView(foundRecord.oip.didTx, foundRecord);
            } else {
                // Try to search for records that match this truncated DID
                console.log('[Routing] Searching for record with truncated DID:', truncatedDidTx);
                try {
                    // Add authentication header if available
                    const headers = {};
                    if (authToken) {
                        headers['Authorization'] = `Bearer ${authToken}`;
                    }
                    
                    const response = await fetch(`/api/records?limit=50&resolveDepth=3`, { headers });
                    const data = await response.json();
                    
                    if (data.records) {
                        const matchingRecord = data.records.find(record => {
                            const didTx = record.oip?.did || record.oip?.didTx || '';
                            const recordTruncated = didTx.replace('did:arweave:', '').substring(0, 7);
                            return recordTruncated === truncatedDidTx;
                        });
                        
                        if (matchingRecord) {
                            console.log('[Routing] Found matching record via search');
                            showRecordView(matchingRecord.oip.didTx, matchingRecord);
                        } else {
                            console.log('[Routing] No matching record found, redirecting to browse');
                            showSearchInterface();
                        }
                    } else {
                        console.log('[Routing] No records found, redirecting to browse');
                        showSearchInterface();
                    }
                } catch (error) {
                    console.error('[Routing] Error searching for record:', error);
                    showSearchInterface();
                }
            }
        }

        function showPublishTab() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[1].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.remove('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        // Record View Navigation Functions
        function showRecordView(didTx, record = null) {
            console.log('[RecordView] Showing record view for:', didTx);
            
            // Update URL
            const truncatedDidTx = didTx.replace('did:arweave:', '').substring(0, 7);
            window.history.pushState({ view: 'record', didTx: didTx }, '', `#browse/record=${truncatedDidTx}`);
            
            // Hide all interfaces and nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('record-view-interface').classList.remove('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Hide header search
            hideHeaderSearch();
            
            // Load record if not provided
            if (record) {
                displayRecordView(record);
            } else {
                loadRecordForView(didTx);
            }

            // If ALFRED drawer is open, set pinned record DID to this record
            try {
                const drawer = document.getElementById('ai-drawer');
                if (drawer && drawer.classList.contains('open')) {
                    window.__alfredPinnedDid = didTx;
                    const pinnedInput = document.getElementById('alfred-pinned-did');
                    if (pinnedInput) pinnedInput.value = didTx;
                }
            } catch (e) {
                console.warn('[RecordView] Unable to set pinned DID for ALFRED:', e);
            }
        }

        function goBackToBrowse() {
            console.log('[RecordView] Going back to browse');
            
            // Update URL
            window.history.pushState({ view: 'browse' }, '', '#browse');
            
            // Show search interface
            showSearchInterface();
        }

        async function loadRecordForView(didTx) {
            try {
                console.log('[RecordView] Loading record:', didTx);
                document.getElementById('record-view-content').innerHTML = '<div class="loading" style="text-align: center; padding: 40px;">Loading record...</div>';
                
                // Add authentication header if available
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`/api/records?didTx=${encodeURIComponent(didTx)}&resolveDepth=3&limit=1`, { headers });
                const data = await response.json();
                
                if (data.records && data.records.length > 0) {
                    displayRecordView(data.records[0]);
                } else {
                    document.getElementById('record-view-content').innerHTML = '<div class="error" style="text-align: center; padding: 40px; color: #dc3545;">Record not found</div>';
                }
            } catch (error) {
                console.error('[RecordView] Error loading record:', error);
                document.getElementById('record-view-content').innerHTML = '<div class="error" style="text-align: center; padding: 40px; color: #dc3545;">Error loading record</div>';
            }
        }

        function displayRecordView(record) {
            console.log('[RecordView] Displaying record:', record);
            
            const recordType = record.oip?.recordType || 'unknown';
            const didTx = record.oip?.didTx || 'Unknown';
            const truncatedDidTx = didTx.replace('did:arweave:', '').substring(0, 7);
            
            // Update header meta
            document.getElementById('record-view-type').textContent = recordType;
            document.getElementById('record-view-did').textContent = `...${truncatedDidTx}`;
            
            // Render content based on record type
            if (recordType === 'post') {
                displayPostRecord(record);
            } else {
                // For now, show a generic view for other record types
                displayGenericRecord(record);
            }
        }

        function displayPostRecord(record) {
            console.log('[RecordView] Displaying post record:', record);
            
            const basicData = record.data?.basic || {};
            const postData = record.data?.post || {};
            
            // Extract title, description, and other basic info
            const title = basicData.name || postData.title || 'Untitled Post';
            const description = basicData.description || postData.summary || '';
            const date = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            const byline = postData.bylineWriter || 'Unknown Author';
            const tags = basicData.tagItems || [];
            
            // Extract media content
            const mediaContent = extractMediaContent(record);
            
            let html = `<div class="post-article-layout">`;
            
            // Article Header
            html += `<div class="post-article-header">`;
            html += `<h1 class="post-article-title">${escapeHtml(title)}</h1>`;
            
            html += `<div class="post-article-meta">
                <div class="post-article-byline">By <strong>${escapeHtml(byline)}</strong></div>
                <div class="post-article-date">${escapeHtml(date)}</div>
            </div>`;
            html += `</div>`;
            
            // Content wrapper with floating image and text wrap
            html += `<div class="post-content-wrapper">`;
            
            // Featured Media Section - Image floated left
            if (mediaContent.featuredImage) {
                const img = mediaContent.featuredImage;
                html += `<div class="post-featured-media">
                    <img src="${img.url}" alt="${escapeHtml(img.alt || 'Featured Image')}" 
                         class="post-featured-image" 
                         onerror="this.style.display='none';">
                </div>`;
            }
            
            // Summary with attached audio section
            html += `<div class="post-summary-with-audio">`;
            
            // Collapsible summary with "Keep Reading" button
            if (description) {
                const summaryId = `summary-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}`;
                html += `<div class="post-article-summary collapsed" id="${summaryId}">${escapeHtml(description)}</div>`;
                html += `<button class="keep-reading-btn" onclick="toggleSummary('${summaryId}', this)" id="${summaryId}-btn">Keep Reading</button>`;
            }
            
            // Featured Audio Section - Attached to summary
            if (mediaContent.featuredAudio || mediaContent.audioItems?.length > 0) {
                const audio = mediaContent.featuredAudio || mediaContent.audioItems[0];
                if (audio) {
                    html += `<div class="post-audio-section">
                        <div class="post-audio-controls">
                            <button class="play-btn primary" 
                                    onclick="playAudioInMaster('${audio.url}', '${escapeHtml(audio.title || title)}', 'post', 'record-view')"
                                    id="record-view-audio-btn">
                                ▶ Play Summary
                            </button>
                            ${audio.duration ? `<span class="audio-duration">${audio.duration}</span>` : ''}
                        </div>
                    </div>`;
                }
            }
            
            html += `</div>`; // End post-summary-with-audio
            
            // Featured Video Section (if present, below summary)
            if (mediaContent.featuredVideo) {
                const video = mediaContent.featuredVideo;
                html += `<div style="clear: both; margin: 20px 0;">
                    <video src="${video.url}" controls class="post-featured-video" 
                           poster="${video.thumbnail || ''}">
                        Your browser does not support the video tag.
                    </video>
                </div>`;
            }
            
            // Article Content - Auto-load article text
            html += `<div class="post-content" id="post-content-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}">`;
            
            // Try to get article text content and load it automatically
            let articleContent = '';
            let shouldLoadArticle = false;
            let articleUrl = '';
            
            if (postData.articleText) {
                if (typeof postData.articleText === 'string') {
                    articleContent = postData.articleText;
                } else if (postData.articleText.data?.text?.webUrl) {
                    // This is a dref to a text record - load it automatically
                    articleUrl = postData.articleText.data.text.webUrl;
                    shouldLoadArticle = true;
                    html += `<div class="article-loading">📄 Loading full article text...</div>`;
                } else if (postData.articleText.webUrl) {
                    // Direct text URL - load it automatically
                    articleUrl = postData.articleText.webUrl;
                    shouldLoadArticle = true;
                    html += `<div class="article-loading">📄 Loading full article text...</div>`;
                }
            }
            
            if (articleContent) {
                // Convert plain text to HTML with basic formatting
                const formattedContent = articleContent
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');
                html += `<div class="article-text"><p>${formattedContent}</p></div>`;
            } else if (!postData.articleText) {
                html += `<p><em>No article content available.</em></p>`;
            }
            
            html += `</div>`; // End post-content
            
            html += `</div>`; // End post-content-wrapper
            
            // Tags Section
            if (tags && tags.length > 0) {
                html += `<div class="post-tags" style="clear: both;">
                    <div class="tags-container">
                        ${tags.map(tag => `<span class="tag-chip">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>`;
            }
            
            html += `</div>`; // End post-article-layout
            
            document.getElementById('record-view-content').innerHTML = html;
            
            // Auto-load article text if needed
            if (shouldLoadArticle && articleUrl) {
                const contentId = `post-content-${record.oip?.didTx?.replace(/[^a-zA-Z0-9]/g, '') || 'unknown'}`;
                loadArticleTextInRecordViewById(articleUrl, contentId);
            }
        }

        function displayGenericRecord(record) {
            console.log('[RecordView] Displaying generic record:', record);
            
            const recordType = record.oip?.recordType || 'unknown';
            const basicData = record.data?.basic || {};
            const title = basicData.name || 'Untitled Record';
            const description = basicData.description || '';
            const date = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            let html = `<div class="post-article-layout">
                <div class="post-article-header">
                    <h1 class="post-article-title">${escapeHtml(title)}</h1>
                    ${description ? `<div class="post-article-summary">${escapeHtml(description)}</div>` : ''}
                    <div class="post-article-meta">
                        <div class="post-article-byline">Record Type: <strong>${escapeHtml(recordType)}</strong></div>
                        <div class="post-article-date">${escapeHtml(date)}</div>
                    </div>
                </div>
                
                <div class="post-content">
                    <p><em>Detailed view for ${recordType} records is not yet implemented. This is the generic record view.</em></p>
                    
                    <h3>Record Data Structure:</h3>
                    <pre style="background: #f8f9fa; padding: 20px; border-radius: 8px; overflow-x: auto; font-size: 14px;">${escapeHtml(JSON.stringify(record, null, 2))}</pre>
                </div>
            </div>`;
            
            document.getElementById('record-view-content').innerHTML = html;
        }

        async function loadArticleTextInRecordView(textUrl) {
            try {
                console.log('[RecordView] Loading article text from:', textUrl);
                
                const response = await fetch(textUrl);
                const text = await response.text();
                
                // Find the loader div and replace it with the content
                const loader = document.querySelector('.article-text-loader');
                if (loader) {
                    const formattedContent = text
                        .replace(/\n\n/g, '</p><p>')
                        .replace(/\n/g, '<br>');
                    loader.innerHTML = `<div class="loaded-article-text"><p>${formattedContent}</p></div>`;
                }
            } catch (error) {
                console.error('[RecordView] Error loading article text:', error);
                const loader = document.querySelector('.article-text-loader');
                if (loader) {
                    loader.innerHTML = `<div class="error" style="color: #dc3545; padding: 16px;">Failed to load article text</div>`;
                }
            }
        }

        async function loadArticleTextInRecordViewById(textUrl, contentId) {
            try {
                console.log('[RecordView] Auto-loading article text from:', textUrl);
                
                const response = await fetch(textUrl);
                const text = await response.text();
                
                // Find the content div and replace loading message with the content
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    const loadingDiv = contentDiv.querySelector('.article-loading');
                    if (loadingDiv) {
                        const formattedContent = text
                            .replace(/\n\n/g, '</p><p>')
                            .replace(/\n/g, '<br>');
                        loadingDiv.outerHTML = `<div class="article-text"><p>${formattedContent}</p></div>`;
                    }
                }
            } catch (error) {
                console.error('[RecordView] Error auto-loading article text:', error);
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    const loadingDiv = contentDiv.querySelector('.article-loading');
                    if (loadingDiv) {
                        loadingDiv.innerHTML = `<div class="error" style="color: #dc3545; padding: 16px;">Failed to load article text</div>`;
                    }
                }
            }
        }

        function toggleSummary(summaryId, button) {
            const summaryDiv = document.getElementById(summaryId);
            if (summaryDiv) {
                if (summaryDiv.classList.contains('collapsed')) {
                    summaryDiv.classList.remove('collapsed');
                    button.textContent = 'Show Less';
                } else {
                    summaryDiv.classList.add('collapsed');
                    button.textContent = 'Keep Reading';
                }
            }
        }

        // AI Drawer Functions
        function toggleAIDrawer() {
            const drawer = document.getElementById('ai-drawer');
            const mainContent = document.getElementById('main-content');
            const toggle = document.getElementById('ai-drawer-toggle');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                mainContent.classList.remove('drawer-open');
                toggle.classList.remove('active');
            } else {
                drawer.classList.add('open');
                mainContent.classList.add('drawer-open');
                toggle.classList.add('active');
                
                // Initialize AI features when drawer is first opened
                if (!chatState.isInitialized) {
                    initializeVoiceFeatures();
                }
            }
        }

        // Welcome Interface Functions
        function handleWelcomeSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                if (searchTerm) {
                    // Set the search term in both search inputs
                    document.getElementById('voice-search-input').value = searchTerm;
                    document.getElementById('header-search-input').value = searchTerm;
                    // Switch to search interface
                    showSearchInterface();
                    // Apply the search
                    applyVoiceFilters();
                }
            }
        }

        function searchByRecordType(recordType) {
            // Clear current search field (don't put record type name in search)
            document.getElementById('voice-search-input').value = '';
            
            // Special handling for audio - search for records with audio content, not audio record type
            if (recordType === 'audio') {
                console.log('[Search] 🎵 Searching for records with embedded audio content (any record type that contains audio)');
                // Don't set record type filter for audio
                document.getElementById('voice-record-type-filter').value = '';
                // Enable the "Includes Audio" toggle
                document.getElementById('voice-includes-audio-toggle').classList.add('active');
            } else {
                // Set the record type filter for other types
                document.getElementById('voice-record-type-filter').value = recordType;
                // Clear the "Includes Audio" toggle
                document.getElementById('voice-includes-audio-toggle').classList.remove('active');
            }
            
            // Clear other filters to get clean results for this record type
            document.getElementById('voice-sort-by').value = 'matchCount:desc';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-did-tx').value = '';
            clearDidTxError();
            clearAllTagFilters();
            
            // Switch to search interface
            showSearchInterface();
            
            // Apply the search (ensure we wait for UI to be ready)
            setTimeout(() => {
                // Ensure voice features are initialized first
                if (!chatState.isInitialized) {
                    initializeVoiceFeatures().then(() => {
                        applyVoiceFilters();
                    });
                } else {
                    applyVoiceFilters();
                }
            }, 200);
        }
        
        // Legacy function for backward compatibility
        function searchByCategory(category) {
            searchByRecordType(category);
        }

        function showAdvancedSearch() {
            showSearchInterface();
        }

        // Legacy function for compatibility
        function showVoiceBrowseTab() {
            showSearchInterface();
        }

        // User Menu Functions
        function toggleUserMenu() {
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-button');
            
            if (dropdown.classList.contains('hidden')) {
                dropdown.classList.remove('hidden');
                button.classList.add('open');
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', closeUserMenuOnClickOutside);
                }, 0);
            } else {
                dropdown.classList.add('hidden');
                button.classList.remove('open');
                document.removeEventListener('click', closeUserMenuOnClickOutside);
            }
        }

        function closeUserMenuOnClickOutside(event) {
            const userMenu = document.getElementById('user-menu');
            if (!userMenu.contains(event.target)) {
                const dropdown = document.getElementById('user-menu-dropdown');
                const button = document.getElementById('user-menu-button');
                dropdown.classList.add('hidden');
                button.classList.remove('open');
                document.removeEventListener('click', closeUserMenuOnClickOutside);
            }
        }

        function updateUserMenuState() {
            const button = document.getElementById('user-menu-button');
            const indicator = document.getElementById('user-menu-indicator');
            const text = document.getElementById('user-menu-text');
            const authenticatedMenu = document.getElementById('authenticated-menu');
            const unauthenticatedMenu = document.getElementById('unauthenticated-menu');
            
            // Check if user menu elements exist
            if (!button || !indicator || !text || !authenticatedMenu || !unauthenticatedMenu) {
                console.warn('User menu elements not found, skipping update');
                return;
            }
            
            if (authToken && currentUser) {
                // Authenticated state
                button.classList.add('authenticated');
                indicator.textContent = '👤';
                text.textContent = currentUser.split('@')[0]; // Show username part of email
                authenticatedMenu.classList.remove('hidden');
                unauthenticatedMenu.classList.add('hidden');
                
                // Update user details in dropdown
                document.getElementById('user-email-display').textContent = currentUser;
                
                // Get public key from JWT if available
                try {
                    if (authToken) {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            const publicKey = payload.publicKey;
                            if (publicKey) {
                                document.getElementById('user-key-display').textContent = `...${publicKey.slice(-8)}`;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Could not extract public key from JWT:', error);
                }
            } else {
                // Unauthenticated state
                button.classList.remove('authenticated');
                indicator.textContent = '🔓';
                text.textContent = 'Account';
                authenticatedMenu.classList.add('hidden');
                unauthenticatedMenu.classList.remove('hidden');
            }
            
            // Update inline JWT status
            updateInlineJWTStatus();
        }

        function updateInlineJWTStatus() {
            const statusIcon = document.getElementById('jwt-status-icon');
            const statusText = document.getElementById('jwt-status-text');
            
            // Check if elements exist
            if (!statusIcon || !statusText) {
                return;
            }
            
            if (authToken) {
                try {
                    const parts = authToken.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        statusIcon.textContent = '🔐';
                        statusText.textContent = 'Token Active';
                    }
                } catch (error) {
                    statusIcon.textContent = '⚠️';
                    statusText.textContent = 'Invalid Token';
                }
            } else {
                statusIcon.textContent = '🔓';
                statusText.textContent = 'No Token';
            }
        }

        // Authentication Modal functions
        function showAuthModal(mode = 'login') {
            document.getElementById('auth-modal').classList.remove('hidden');
            
            if (mode === 'login') {
                showLoginForm();
            } else if (mode === 'register') {
                showRegisterForm();
            } else if (mode === 'import') {
                showImportWalletForm();
            } else {
                showLoginForm();
            }
            
            // Close user menu
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-button');
            dropdown.classList.add('hidden');
            button.classList.remove('open');
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.add('hidden');
            clearAuthForms();
        }

        function showLoginForm() {
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('register-form').classList.add('hidden');
            document.getElementById('import-wallet-form').classList.add('hidden');
        }

        function showRegisterForm() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.remove('hidden');
            document.getElementById('import-wallet-form').classList.add('hidden');
        }

        function showImportWalletForm() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.add('hidden');
            document.getElementById('import-wallet-form').classList.remove('hidden');
        }

        function clearAuthForms() {
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
            document.getElementById('register-email').value = '';
            document.getElementById('register-password').value = '';
            document.getElementById('import-email').value = '';
            document.getElementById('import-password').value = '';
            document.getElementById('import-mnemonic').value = '';
            hideElement('auth-status');
            hideElement('auth-success');
        }

        // Authentication functions
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    
                    // Also store in the JWT token localStorage for consistency
                    localStorage.setItem('oip-jwt-token', authToken);
                    
                    // Update JWT status display
                    try {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            updateJWTStatus(payload);
                            currentUser = payload.email; // Ensure currentUser is set
                        }
                    } catch (error) {
                        console.error('Error updating JWT status after login:', error);
                        // Set currentUser from response if JWT parsing fails
                        currentUser = email;
                    }
                    
                    showLoggedInState();
                    updateUserMenuState();
                    await loadTemplates();
                    showMessage('auth-success', 'Login successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function register() {
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    
                    // Also store in the JWT token localStorage for consistency
                    localStorage.setItem('oip-jwt-token', authToken);
                    
                    // Update JWT status display
                    try {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            updateJWTStatus(payload);
                        }
                    } catch (error) {
                        console.error('Error updating JWT status after registration:', error);
                    }
                    
                    showLoggedInState();
                    updateUserMenuState();
                    await loadTemplates();
                    
                    // Show mnemonic for new registration
                    if (data.mnemonic) {
                        showMessage('auth-success', 'Registration successful! Please save your recovery phrase.', 'success');
                        setTimeout(() => {
                            hideAuthModal();
                            showRegistrationMnemonicModal(data.mnemonic);
                        }, 1500);
                    } else {
                        showMessage('auth-success', 'Registration successful!', 'success');
                        setTimeout(hideAuthModal, 1500);
                    }
                } else {
                    showMessage('auth-status', data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Import wallet function
        async function importWallet() {
            const email = document.getElementById('import-email').value;
            const password = document.getElementById('import-password').value;
            const mnemonic = document.getElementById('import-mnemonic').value.trim();
            
            if (!email || !password || !mnemonic) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            // Validate mnemonic (should be 12 words)
            const words = mnemonic.split(/\s+/).filter(w => w.length > 0);
            if (words.length !== 12) {
                showMessage('auth-status', 'Recovery phrase must be exactly 12 words', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/import-wallet', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password, mnemonic })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    
                    // Also store in the JWT token localStorage for consistency
                    localStorage.setItem('oip-jwt-token', authToken);
                    
                    // Update JWT status display
                    try {
                        const parts = authToken.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            updateJWTStatus(payload);
                        }
                    } catch (error) {
                        console.error('Error updating JWT status after import:', error);
                    }
                    
                    showLoggedInState();
                    updateUserMenuState();
                    await loadTemplates();
                    showMessage('auth-success', 'Wallet imported successfully!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Wallet import failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            localStorage.removeItem('oip-auth-token');
            localStorage.removeItem('oip-user-email');
            localStorage.removeItem('oip-jwt-token');
            
            // Update JWT status display
            updateJWTStatus(null);
            
            showLoginState();
            updateUserMenuState();
            
            // Close user menu
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-button');
            dropdown.classList.add('hidden');
            button.classList.remove('open');
        }

        function showLoggedInState() {
            // Legacy elements (keep for compatibility) - check if they exist
            const userInfo = document.getElementById('user-info');
            const authButtons = document.getElementById('auth-buttons');
            const publishingContent = document.getElementById('publishing-content');
            const loggedInDisplay = document.getElementById('logged-in-display');
            
            if (userInfo) userInfo.classList.remove('hidden');
            if (authButtons) authButtons.classList.add('hidden');
            if (publishingContent) publishingContent.classList.remove('hidden');
            if (loggedInDisplay) loggedInDisplay.textContent = currentUser;
            
            // Update new user menu
            updateUserMenuState();
        }

        function showLoginState() {
            // Legacy elements (keep for compatibility) - check if they exist
            const userInfo = document.getElementById('user-info');
            const authButtons = document.getElementById('auth-buttons');
            const publishingContent = document.getElementById('publishing-content');
            
            if (userInfo) userInfo.classList.add('hidden');
            if (authButtons) authButtons.classList.remove('hidden');
            if (publishingContent) publishingContent.classList.add('hidden');
            hideAllPublishingSections();
            
            // Update new user menu
            updateUserMenuState();
        }

        // Mnemonic Management Functions
        function showMnemonicModal() {
            document.getElementById('mnemonic-modal').classList.remove('hidden');
            // Clear previous state
            document.getElementById('mnemonic-display').classList.add('hidden');
            document.getElementById('mnemonic-password').value = '';
            document.getElementById('mnemonic-status').classList.add('hidden');
            
            // Close user menu
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-button');
            dropdown.classList.add('hidden');
            button.classList.remove('open');
        }

        function hideMnemonicModal() {
            document.getElementById('mnemonic-modal').classList.add('hidden');
            // Clear sensitive data
            document.getElementById('mnemonic-words').textContent = '';
            document.getElementById('mnemonic-password').value = '';
        }

        async function showMnemonic() {
            const password = document.getElementById('mnemonic-password').value;
            
            if (!password) {
                showMnemonicStatus('Please enter your password', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/user/mnemonic?password=${encodeURIComponent(password)}`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('mnemonic-words').textContent = data.mnemonic;
                    document.getElementById('mnemonic-display').classList.remove('hidden');
                    showMnemonicStatus('Recovery phrase retrieved successfully', 'success');
                } else {
                    showMnemonicStatus(data.error || 'Failed to retrieve recovery phrase', 'error');
                }
            } catch (error) {
                showMnemonicStatus('Network error: ' + error.message, 'error');
            }
        }

        function hideMnemonic() {
            document.getElementById('mnemonic-display').classList.add('hidden');
            document.getElementById('mnemonic-words').textContent = '';
        }

        function copyMnemonicToClipboard() {
            const mnemonicText = document.getElementById('mnemonic-words').textContent;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(mnemonicText).then(() => {
                    showMnemonicStatus('Recovery phrase copied to clipboard!', 'success');
                }).catch(error => {
                    showMnemonicStatus('Failed to copy to clipboard', 'error');
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = mnemonicText;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showMnemonicStatus('Recovery phrase copied to clipboard!', 'success');
                } catch (error) {
                    showMnemonicStatus('Failed to copy to clipboard', 'error');
                }
                document.body.removeChild(textArea);
            }
        }

        function showMnemonicStatus(message, type) {
            const statusElement = document.getElementById('mnemonic-status');
            statusElement.innerHTML = `<div class="${type === 'success' ? 'success-message' : 'error-message'}">${message}</div>`;
            statusElement.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => statusElement.classList.add('hidden'), 3000);
            }
        }

        function showRegistrationMnemonicModal(mnemonic) {
            // Show the mnemonic modal with the new user's mnemonic pre-filled
            const modal = document.getElementById('mnemonic-modal');
            const passwordGroup = document.getElementById('mnemonic-password').closest('.form-group');
            const showButton = document.querySelector('[onclick="showMnemonic()"]');
            
            modal.classList.remove('hidden');
            document.getElementById('mnemonic-words').textContent = mnemonic;
            document.getElementById('mnemonic-display').classList.remove('hidden');
            
            // Hide the password field since we're showing it directly after registration
            passwordGroup.style.display = 'none';
            showButton.style.display = 'none';
            
            showMnemonicStatus('🎉 Account created! Please save your recovery phrase securely.', 'success');
            
            // Add a special close handler to restore the modal to normal state
            const closeButton = modal.querySelector('[onclick="hideMnemonicModal()"]');
            if (closeButton) {
                const originalOnClick = closeButton.onclick;
                closeButton.onclick = function() {
                    // Restore normal modal state
                    passwordGroup.style.display = 'block';
                    showButton.style.display = 'inline-block';
                    closeButton.onclick = originalOnClick;
                    hideMnemonicModal();
                };
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            localStorage.removeItem('oip-auth-token');
            localStorage.removeItem('oip-user-email');
            localStorage.removeItem('oip-jwt-token');
            
            // Update JWT status display
            updateJWTStatus(null);
            
            showLoginState();
            updateUserMenuState();
            
            // Close user menu
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-button');
            dropdown.classList.add('hidden');
            button.classList.remove('open');
        }

        // JWT Token Management Functions
        function showJWTModal() {
            document.getElementById('jwt-modal').classList.remove('hidden');
            // Pre-fill if token exists
            const existingToken = localStorage.getItem('oip-jwt-token');
            if (existingToken) {
                document.getElementById('jwt-token-input').value = existingToken;
            }
        }

        function hideJWTModal() {
            document.getElementById('jwt-modal').classList.add('hidden');
            document.getElementById('jwt-token-status').innerHTML = '';
        }

        function setJWTToken() {
            const tokenInput = document.getElementById('jwt-token-input').value.trim();
            const rememberToken = document.getElementById('jwt-remember').checked;
            
            if (!tokenInput) {
                showJWTStatus('Please enter a JWT token', 'error');
                return;
            }

            try {
                // Basic JWT validation - check if it has 3 parts
                const parts = tokenInput.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }

                // Try to decode the payload (without verification)
                const payload = JSON.parse(atob(parts[1]));
                
                // Set the token
                authToken = tokenInput;
                
                // Store in localStorage if requested
                if (rememberToken) {
                    localStorage.setItem('oip-jwt-token', tokenInput);
                } else {
                    localStorage.removeItem('oip-jwt-token');
                }

                // Update UI
                updateJWTStatus(payload);
                updateUserMenuState();
                showJWTStatus(`Token set successfully! User: ${payload.email || 'Unknown'}`, 'success');
                
                // Auto-hide modal after success
                setTimeout(() => {
                    hideJWTModal();
                }, 2000);
                
            } catch (error) {
                showJWTStatus('Invalid JWT token format: ' + error.message, 'error');
            }
        }

        function clearJWTToken() {
            authToken = null;
            localStorage.removeItem('oip-jwt-token');
            document.getElementById('jwt-token-input').value = '';
            updateJWTStatus(null);
            updateUserMenuState();
            showJWTStatus('Token cleared', 'success');
        }

        function updateJWTStatus(payload) {
            // Legacy JWT status elements (may not exist with new user menu)
            const indicator = document.getElementById('jwt-indicator');
            const userInfo = document.getElementById('jwt-user-info');
            
            if (indicator && userInfo) {
                if (payload && authToken) {
                    indicator.textContent = '🔐';
                    const userEmail = payload.email || 'Unknown';
                    const publicKey = payload.publicKey ? `...${payload.publicKey.slice(-6)}` : 'No key';
                    userInfo.textContent = `${userEmail} (${publicKey})`;
                    userInfo.title = `Email: ${userEmail}\\nPublic Key: ${payload.publicKey || 'None'}`;
                } else {
                    indicator.textContent = '🔓';
                    userInfo.textContent = 'Not authenticated';
                    userInfo.title = '';
                }
            }
            
            // Update user menu state regardless
            if (payload && authToken) {
                currentUser = payload.email;
            }
            updateUserMenuState();
        }

        function showJWTStatus(message, type) {
            const statusElement = document.getElementById('jwt-token-status');
            statusElement.innerHTML = `<div class="${type === 'success' ? 'success-message' : 'error-message'}">${message}</div>`;
        }

        // Initialize JWT token from localStorage on page load
        function initializeJWTToken() {
            // Check both token storage locations for consistency
            const savedToken = localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
            if (savedToken) {
                try {
                    const parts = savedToken.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        authToken = savedToken;
                        
                        // Ensure both storage locations are synchronized
                        localStorage.setItem('oip-jwt-token', savedToken);
                        localStorage.setItem('oip-auth-token', savedToken);
                        
                        updateJWTStatus(payload);
                        console.log('JWT token initialized from localStorage:', payload.email);
                    }
                } catch (error) {
                    console.warn('Invalid saved JWT token, clearing:', error);
                    localStorage.removeItem('oip-jwt-token');
                    localStorage.removeItem('oip-auth-token');
                }
            }
        }

        // GUN Sync Status Management
        let gunSyncStatus = {
            isHealthy: false,
            lastChecked: null,
            checkInterval: null
        };

        // Show GUN sync status modal
        function showGunSyncModal() {
            document.getElementById('gun-sync-modal').classList.remove('hidden');
            loadGunSyncStatus();
        }

        // Hide GUN sync status modal
        function hideGunSyncModal() {
            document.getElementById('gun-sync-modal').classList.add('hidden');
        }

        // Load GUN sync status from API
        async function loadGunSyncStatus() {
            const loadingDiv = document.getElementById('gun-sync-loading');
            const contentDiv = document.getElementById('gun-sync-content');
            const errorDiv = document.getElementById('gun-sync-error');
            
            // Show loading state
            loadingDiv.classList.remove('hidden');
            contentDiv.classList.add('hidden');
            errorDiv.classList.add('hidden');
            
            try {
                console.log('[GUN Sync] Fetching sync status...');
                
                const response = await fetch('/api/health/gun-sync');
                const data = await response.json();
                
                if (response.ok) {
                    displayGunSyncStatus(data);
                    gunSyncStatus.isHealthy = data.status === 'healthy';
                    gunSyncStatus.lastChecked = new Date();
                    updateHeaderSyncIndicator(data);
                } else {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.error('[GUN Sync] Error loading status:', error);
                displayGunSyncError(error.message);
                gunSyncStatus.isHealthy = false;
                updateHeaderSyncIndicator({ status: 'error' });
            } finally {
                loadingDiv.classList.add('hidden');
            }
        }

        // Display GUN sync status in modal
        function displayGunSyncStatus(data) {
            const contentDiv = document.getElementById('gun-sync-content');
            const errorDiv = document.getElementById('gun-sync-error');
            
            // Hide error and show content
            errorDiv.classList.add('hidden');
            contentDiv.classList.remove('hidden');
            
            // Update modal indicator
            const modalIndicator = document.getElementById('gun-sync-modal-indicator');
            if (data.status === 'healthy') {
                modalIndicator.textContent = '✅';
            } else if (data.status === 'unhealthy') {
                modalIndicator.textContent = '⚠️';
            } else {
                modalIndicator.textContent = '❌';
            }
            
            // Service Status
            document.getElementById('sync-service-status').textContent = data.status || 'unknown';
            document.getElementById('sync-service-running').textContent = data.running ? 'Yes' : 'No';
            document.getElementById('sync-node-id').textContent = data.nodeId || 'unknown';
            document.getElementById('sync-last-time').textContent = data.metrics?.lastSyncAgo || 'never';
            
            // Sync Metrics
            document.getElementById('sync-total-discovered').textContent = data.metrics?.totalDiscovered || '0';
            document.getElementById('sync-total-synced').textContent = data.metrics?.totalSynced || '0';
            document.getElementById('sync-success-rate').textContent = data.metrics?.successRate || '0%';
            document.getElementById('sync-cycles').textContent = data.metrics?.syncCycles || '0';
            document.getElementById('sync-total-errors').textContent = data.metrics?.totalErrors || '0';
            document.getElementById('sync-avg-time').textContent = data.metrics?.averageSyncTime || '0ms';
            
            // Registry Statistics
            document.getElementById('registry-total-records').textContent = data.registry?.totalRecordsRegistered || '0';
            
            const recordsByType = data.registry?.recordsByType || {};
            const typesList = Object.entries(recordsByType)
                .map(([type, count]) => `${type}: ${count}`)
                .join(', ') || 'No records registered';
            document.getElementById('registry-by-type').textContent = typesList;
            
            // Configuration
            const config = data.configuration || {};
            document.getElementById('sync-config-private').textContent = config.privateRecordsEnabled ? 'Enabled' : 'Disabled';
            document.getElementById('sync-config-trusted').textContent = 
                config.trustedNodes && config.trustedNodes.length > 0 ? config.trustedNodes.join(', ') : 'All nodes trusted';
            document.getElementById('sync-config-interval').textContent = 
                data.metrics?.syncInterval ? `${data.metrics.syncInterval / 1000}s` : '30s';
            
            // Enable/disable force sync button
            const forceSyncBtn = document.getElementById('force-sync-btn');
            forceSyncBtn.disabled = !data.running;
            
            console.log('[GUN Sync] Status displayed successfully');
        }

        // Display GUN sync error in modal
        function displayGunSyncError(errorMessage) {
            const contentDiv = document.getElementById('gun-sync-content');
            const errorDiv = document.getElementById('gun-sync-error');
            const errorMessageDiv = document.getElementById('gun-sync-error-message');
            
            // Show error and hide content
            contentDiv.classList.add('hidden');
            errorDiv.classList.remove('hidden');
            
            // Update modal indicator
            const modalIndicator = document.getElementById('gun-sync-modal-indicator');
            modalIndicator.textContent = '❌';
            
            // Show error message
            errorMessageDiv.textContent = errorMessage;
            
            // Disable force sync button
            const forceSyncBtn = document.getElementById('force-sync-btn');
            forceSyncBtn.disabled = true;
        }

        // Update header sync indicator
        function updateHeaderSyncIndicator(data) {
            const syncButton = document.getElementById('gun-sync-status');
            const syncIndicator = document.getElementById('gun-sync-indicator');
            
            // Remove all status classes
            syncButton.classList.remove('healthy', 'unhealthy', 'disabled');
            
            if (data.status === 'healthy') {
                syncButton.classList.add('healthy');
                syncIndicator.textContent = '✅';
                syncButton.title = `GUN sync healthy - Last sync: ${data.metrics?.lastSyncAgo || 'unknown'}`;
            } else if (data.status === 'unhealthy') {
                syncButton.classList.add('unhealthy');
                syncIndicator.textContent = '⚠️';
                syncButton.title = 'GUN sync has issues - Click for details';
            } else if (data.status === 'unavailable') {
                syncButton.classList.add('disabled');
                syncIndicator.textContent = '⏸️';
                syncButton.title = 'GUN sync service not available';
            } else {
                syncButton.classList.add('unhealthy');
                syncIndicator.textContent = '❌';
                syncButton.title = 'GUN sync error - Click for details';
            }
        }

        // Refresh sync status
        async function refreshGunSyncStatus() {
            await loadGunSyncStatus();
        }

        // Force a sync cycle
        async function forceSyncCycle() {
            const forceSyncBtn = document.getElementById('force-sync-btn');
            const originalText = forceSyncBtn.textContent;
            
            try {
                forceSyncBtn.disabled = true;
                forceSyncBtn.textContent = '🔄 Forcing sync...';
                
                const response = await fetch('/api/health/gun-sync/force', {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Show success and refresh status after a delay
                    forceSyncBtn.textContent = '✅ Sync triggered!';
                    setTimeout(async () => {
                        await refreshGunSyncStatus();
                        forceSyncBtn.textContent = originalText;
                        forceSyncBtn.disabled = false;
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Failed to trigger sync');
                }
                
            } catch (error) {
                console.error('[GUN Sync] Error forcing sync:', error);
                forceSyncBtn.textContent = '❌ Failed';
                setTimeout(() => {
                    forceSyncBtn.textContent = originalText;
                    forceSyncBtn.disabled = false;
                }, 2000);
            }
        }

        // Initialize sync status checking on page load
        function initializeGunSyncStatus() {
            // Check sync status immediately
            checkGunSyncStatusQuiet();
            
            // Set up periodic status checking (every 60 seconds)
            gunSyncStatus.checkInterval = setInterval(checkGunSyncStatusQuiet, 60000);
        }

        // Quietly check sync status (no modal, just update header indicator)
        async function checkGunSyncStatusQuiet() {
            try {
                const response = await fetch('/api/health/gun-sync');
                const data = await response.json();
                
                if (response.ok) {
                    updateHeaderSyncIndicator(data);
                    gunSyncStatus.isHealthy = data.status === 'healthy';
                    gunSyncStatus.lastChecked = new Date();
                } else {
                    updateHeaderSyncIndicator({ status: 'error' });
                    gunSyncStatus.isHealthy = false;
                }
                
            } catch (error) {
                // Silently handle errors for background checks
                updateHeaderSyncIndicator({ status: 'unavailable' });
                gunSyncStatus.isHealthy = false;
            }
        }

        // Core browsing functionality (DISABLED - redirected to voice version)
        async function loadRecords(reset = false) {
            console.log('[App] loadRecords called but redirected to loadVoiceRecords');
            // Redirect to the voice version instead
            return await loadVoiceRecords(reset);
        }

        // OLD loadRecords function (disabled)
        async function loadRecordsOLD(reset = false) {
            if (isLoading) return;
            
            isLoading = true;
            const loadingEl = document.getElementById('loading-indicator');
            const recordsGrid = document.getElementById('records-grid');
            const noResults = document.getElementById('no-results');
            
            if (reset) {
                currentPage = 1;
                currentRecords = [];
                recordsGrid.innerHTML = '';
                loadingEl.classList.remove('hidden');
                recordsGrid.classList.add('hidden');
                noResults.classList.add('hidden');
            }

            try {
                const params = buildApiParams();
                const base = (typeof window !== 'undefined' && window.API_BASE_URL) ? window.API_BASE_URL : '';
                // Add authentication header if available
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${base}/api/records?${params}`, { headers });
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    displayRecords(data.records, !reset);
                    updatePaginationInfo(data);
                    
                    // Update tags if available
                    if (data.tagSummary) {
                        updateTagFilter(data.tagSummary);
                    }
                    
                    hasMoreRecords = data.records.length === 12; // Check if we got a full page
                } else {
                    if (reset) {
                        showNoResults();
                    }
                }
                
            } catch (error) {
                console.error('Error loading records:', error);
                showMessage('records-header', 'Error loading records: ' + error.message, 'error');
            } finally {
                isLoading = false;
                loadingEl.classList.add('hidden');
                updateLoadMoreButton();
            }
        }

        function buildApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.searchMatchMode) {
                params.append('searchMatchMode', currentFilters.searchMatchMode);
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.tag) {
                params.append('tags', currentFilters.tag);
            }

            return params.toString();
        }

        // Display and utility functions
        function displayRecords(records, append = false) {
            const grid = document.getElementById('records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = currentRecords.length - records.length;
            records.forEach((record, index) => {
                const card = createRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
        }

        // Media rendering functions (excluding images and audio which are handled separately)
        function renderOtherMediaContent(record, recordType, specificData) {
            let mediaHtml = '';
            
            // Handle direct media records (video, text only - images and audio handled separately)
            if (['video', 'text'].includes(recordType)) {
                mediaHtml += renderDirectMedia(specificData, recordType);
            }
            
            // Handle post records with embedded media (excluding featured image and audio)
            if (recordType === 'post' && specificData) {
                mediaHtml += renderPostVideoAndText(specificData);
            }
            
            // Handle recipe and workout records with media in ingredients/exercises
            if (['recipe', 'workout'].includes(recordType) && specificData) {
                mediaHtml += renderRecipeWorkoutNonAudioMedia(specificData, recordType);
            }
            
            return mediaHtml ? `<div class="media-content">${mediaHtml}</div>` : '';
        }

        function renderPostVideoAndText(postData) {
            let html = '';
            
            // Article text (dref resolved) - but not if it's already shown in the text toggle
            if (postData.articleText?.data?.text?.webUrl && !postData.articleText) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }

        function renderRecipeWorkoutNonAudioMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media (excluding audio/images)
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has video or text media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        function renderDirectMedia(data, type) {
            if (!data || !data.webUrl) return '';
            
            const webUrl = data.webUrl;
            const contentType = data.contentType || '';
            
            switch (type) {
                case 'image':
                    return `<div class="media-item">
                        <img src="${webUrl}" alt="Image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <audio controls style="width: 100%; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <video controls style="width: 100%; max-height: 300px; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <div class="text-preview" style="margin: 10px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }
        
        function renderPostMedia(postData) {
            let html = '';
            
            // Main article web URL (external link) - this should open in new tab
            if (postData.webUrl) {
                html += `<div class="media-item">
                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Read Original Article
                    </a>
                </div>`;
            }
            
            // Article text (dref resolved)
            if (postData.articleText?.data?.text?.webUrl) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Featured image (dref resolved)
            if (postData.featuredImage?.data?.image?.webUrl) {
                html += renderDirectMedia(postData.featuredImage.data.image, 'image');
            }
            
            // Audio items array
            if (postData.audioItems && Array.isArray(postData.audioItems)) {
                postData.audioItems.forEach((audioItem, index) => {
                    if (audioItem?.data?.audio?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Audio ${index + 1}:</label>
                            ${renderDirectMedia(audioItem.data.audio, 'audio')}
                        </div>`;
                    }
                });
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            // Image items array
            if (postData.imageItems && Array.isArray(postData.imageItems)) {
                postData.imageItems.forEach((imageItem, index) => {
                    if (imageItem?.data?.image?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Image ${index + 1}:</label>
                            ${renderDirectMedia(imageItem.data.image, 'image')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }
        
        function renderRecipeWorkoutMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['image', 'audio', 'video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        // Load text content dynamically
        async function loadTextContent(url, button) {
            const contentDiv = button.nextElementSibling;
            
            if (contentDiv.style.display === 'none') {
                try {
                    button.textContent = 'Loading...';
                    button.disabled = true;
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    
                    contentDiv.innerHTML = `
                        <div style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 14px;">
                            ${escapeHtml(text)}
                        </div>
                        <button onclick="this.parentElement.style.display='none'; this.parentElement.previousElementSibling.textContent='📄 View Text Content'; this.parentElement.previousElementSibling.disabled=false;" 
                                style="margin-top: 10px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Hide
                        </button>
                    `;
                    contentDiv.style.display = 'block';
                    button.textContent = '📄 Text Loaded';
                } catch (error) {
                    contentDiv.innerHTML = `<div style="color: #dc3545;">Error loading text content: ${error.message}</div>`;
                    contentDiv.style.display = 'block';
                    button.textContent = '❌ Failed to Load';
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Truncate text to specified length with ellipsis
         */
        function truncateText(text, maxLength) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength).trim() + '...';
        }

        /**
         * Filter records by tag (called when clicking tag chips)
         */
        function filterByTag(tag) {
            document.getElementById('voice-search-input').value = tag;
            applyVoiceFilters();
        }

        // ====== ENHANCED TEMPLATE SYSTEM TEST FUNCTIONS ======
        
        /**
         * Test function to verify dynamic template system is working
         */
        function testTemplateSystem() {
            console.log('[Test] Testing Enhanced Dynamic Template System');
            console.log('[Test] Templates loaded:', Object.keys(allTemplates).length / 2);
            console.log('[Test] Field mappings available:', Object.keys(templateFieldMap).length / 2);
            console.log('[Test] Debug mode:', showDebugInfo);
            console.log('[Test] Sample template field mapping:', templateFieldMap['post'] || 'No post template found');
            
            if (currentRecords.length > 0) {
                const sampleRecord = currentRecords[0];
                const templatesUsed = analyzeRecordTemplates(sampleRecord);
                console.log('[Test] Sample record uses templates:', templatesUsed);
            }
            
            console.log('[Test] Enhanced template system is active!');
        }

        // Make test function available globally for console testing
        window.testTemplateSystem = testTemplateSystem;

        // ========================================================================
        // SMART PUBLISHING FEATURES
        // ========================================================================

        /**
         * Handle name field changes to show/hide smart buttons
         */
        function onNameFieldChange(recordType, nameValue) {
            const trimmedValue = nameValue.trim();
            const buttonsContainer = document.getElementById(`${recordType}-smart-buttons`);
            
            if (buttonsContainer) {
                if (trimmedValue.length > 2) {
                    buttonsContainer.style.display = 'flex';
                } else {
                    buttonsContainer.style.display = 'none';
                }
            }
        }

        /**
         * Copy data from the latest matching record
         */
        async function copyFromLatestRecord(recordType) {
            let button = null;
            let originalText = '';
            
            try {
                const nameField = getNameFieldForRecordType(recordType);
                const nameValue = nameField ? nameField.value.trim() : '';
                
                if (!nameValue) {
                    alert('Please enter a name first to search for matching records');
                    return;
                }

                // Find the button that was clicked
                button = document.querySelector(`#${recordType}-smart-buttons .btn-secondary`);
                if (button) {
                    originalText = button.textContent;
                    button.textContent = '🔄 Searching...';
                    button.disabled = true;
                }

                // Build API parameters
                const params = new URLSearchParams({
                    recordType: recordType,
                    search: nameValue,
                    noDuplicates: 'true',
                    limit: '1',
                    sortBy: 'date:desc',
                    resolveDepth: '2'
                });

                // Add authentication header if available
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }

                console.log(`[Smart Copy] Searching for latest ${recordType} matching: "${nameValue}"`);

                // Also fetch schema data for proper enum mapping
                const schemaResponse = await fetch(`/api/publish/schema?recordType=${recordType}`);
                const schemaData = await schemaResponse.json();
                
                // Get basic schema for language field
                const basicSchemaResponse = await fetch(`/api/publish/schema?recordType=basic`);
                const basicSchemaData = await basicSchemaResponse.json();
                
                if (schemaResponse.ok && basicSchemaResponse.ok && basicSchemaData.template_fields_info) {
                    schemaData.basic_template_fields_info = basicSchemaData.template_fields_info;
                    window.currentSchemaData = schemaData;
                }

                const response = await fetch(`/api/records?${params}`, { headers });
                const data = await response.json();

                if (data.records && data.records.length > 0) {
                    const latestRecord = data.records[0];
                    console.log(`[Smart Copy] Found matching record:`, latestRecord);
                    
                    // Copy the data to the form
                    await populateFormFromRecord(recordType, latestRecord);
                    
                    // Show success message
                    try {
                        showMessage('publish-success', `✅ Copied data from latest "${latestRecord.data?.basic?.name || 'record'}"`, 'success');
                    } catch (msgError) {
                        console.warn('[Smart Copy] Message display error:', msgError);
                    }
                } else {
                    try {
                        showMessage('publish-status', `No matching ${recordType} records found for "${nameValue}"`, 'error');
                    } catch (msgError) {
                        console.warn('[Smart Copy] Error message display error:', msgError);
                    }
                }

            } catch (error) {
                console.error('[Smart Copy] Error:', error);
                try {
                    showMessage('publish-status', 'Error searching for records: ' + error.message, 'error');
                } catch (msgError) {
                    console.warn('[Smart Copy] Error displaying error message:', msgError);
                }
            } finally {
                // Reset button state
                if (button) {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            }
        }

        /**
         * Fill in form fields using AI
         */
        async function fillInWithAI(recordType) {
            let button = null;
            let originalText = '';
            
            try {
                const nameField = getNameFieldForRecordType(recordType);
                const nameValue = nameField ? nameField.value.trim() : '';
                
                if (!nameValue) {
                    alert('Please enter a name first to provide context for AI');
                    return;
                }

                // Find the AI button that was clicked
                button = document.querySelector(`#${recordType}-smart-buttons .btn-small:not(.btn-secondary)`);
                if (button) {
                    originalText = button.textContent;
                    button.textContent = '🤖 AI Working...';
                    button.disabled = true;
                }

                console.log(`[Smart AI] Filling in ${recordType} fields for: "${nameValue}"`);

                // Step 1: Get the schema for this record type
                const schemaResponse = await fetch(`/api/publish/schema?recordType=${recordType}`);
                const schemaData = await schemaResponse.json();

                if (!schemaResponse.ok) {
                    throw new Error(schemaData.error || 'Failed to get schema');
                }

                // Step 1.5: Also get basic template schema for language and other basic fields
                const basicSchemaResponse = await fetch(`/api/publish/schema?recordType=basic`);
                const basicSchemaData = await basicSchemaResponse.json();
                
                // Merge basic schema fields into main schema for comprehensive enum mapping
                if (basicSchemaResponse.ok && basicSchemaData.template_fields_info) {
                    schemaData.basic_template_fields_info = basicSchemaData.template_fields_info;
                }

                // Store schema data globally for use in setFieldValue
                window.currentSchemaData = schemaData;

                // Step 2: Collect current form data
                const currentFormData = collectCurrentFormData(recordType);
                
                // Step 3: Build AI prompt
                const aiPrompt = buildAIPrompt(recordType, nameValue, currentFormData, schemaData);

                // Step 4: Call OpenAI via existing endpoint
                const aiResponse = await callOpenAIForFieldFilling(aiPrompt);

                // Step 5: Parse AI response and fill form
                await populateFormFromAIResponse(recordType, aiResponse, schemaData);

                try {
                    showMessage('publish-success', `✅ AI has filled in the ${recordType} fields based on "${nameValue}"`, 'success');
                } catch (msgError) {
                    console.warn('[Smart AI] Success message display error:', msgError);
                }

            } catch (error) {
                console.error('[Smart AI] Error:', error);
                try {
                    showMessage('publish-status', 'AI fill-in failed: ' + error.message, 'error');
                } catch (msgError) {
                    console.warn('[Smart AI] Error message display error:', msgError);
                }
            } finally {
                // Reset button state
                if (button) {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            }
        }

        /**
         * Get the name field element for a given record type
         */
        function getNameFieldForRecordType(recordType) {
            const fieldMap = {
                'post': 'post-title',
                'recipe': 'recipe-title', 
                'exercise': 'exercise-name',
                'workout': 'workout-title',
                'fitnessEquipment': 'equipment-name',
                'video': 'video-title',
                'audio': 'audio-title',
                'music': 'audio-title',
                'image': 'image-title',
                'text': 'text-title',
                'organization': 'org-name',
                'media': 'media-name'
            };
            
            const fieldId = fieldMap[recordType];
            return fieldId ? document.getElementById(fieldId) : null;
        }

        /**
         * Populate form from a record object
         */
        async function populateFormFromRecord(recordType, record) {
            console.log(`[Smart Copy] Populating ${recordType} form from record:`, record);
            
            const basicData = record.data?.basic || {};
            const specificData = record.data?.[recordType] || {};

            switch (recordType) {
                case 'recipe':
                    await populateRecipeForm(basicData, specificData);
                    break;
                case 'exercise':
                    await populateExerciseForm(basicData, specificData);
                    break;
                case 'workout':
                    await populateWorkoutForm(basicData, specificData);
                    break;
                case 'post':
                    await populatePostForm(basicData, specificData);
                    break;
                case 'fitnessEquipment':
                    await populateFitnessEquipmentForm(basicData, specificData);
                    break;
                case 'video':
                    await populateVideoForm(basicData, specificData);
                    break;
                case 'audio':
                    await populateAudioForm(basicData, specificData);
                    break;
                case 'music':
                    await populateAudioForm(basicData, record.data?.audio, record.data?.music);
                    break;
                case 'image':
                    await populateImageForm(basicData, specificData);
                    break;
                case 'text':
                    await populateTextForm(basicData, specificData);
                    break;
                case 'organization':
                    await populateOrganizationForm(basicData, specificData);
                    break;
                case 'media':
                    await populateMediaForm(basicData, specificData);
                    break;
                default:
                    console.warn(`[Smart Copy] No populate function for record type: ${recordType}`);
            }
        }

        /**
         * Collect current form data for AI context
         */
        function collectCurrentFormData(recordType) {
            const formData = {};
            
            // Get all form inputs for this record type
            const form = document.querySelector('.publish-form');
            if (!form) return formData;

            // Collect all input values
            const inputs = form.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                if (input.value && input.value.trim()) {
                    formData[input.id] = input.value.trim();
                }
            });

            return formData;
        }

        /**
         * Build AI prompt for field filling
         */
        function buildAIPrompt(recordType, nameValue, currentFormData, schemaData) {
            // Get available dropdown options for better AI suggestions
            const dropdownOptions = getDropdownOptionsForRecordType(recordType);
            
            // Extract enum field information for better AI guidance
            const enumFieldsInfo = extractEnumFieldsFromSchema(schemaData);
            
            const prompt = `You are an expert assistant helping to fill out a ${recordType} record form. 

Given this information:
- Record Type: ${recordType}
- Name/Title: "${nameValue}"
- Current form data: ${JSON.stringify(currentFormData, null, 2)}
- Schema information: ${JSON.stringify(schemaData.field_descriptions, null, 2)}
- Example data: ${JSON.stringify(schemaData.example, null, 2)}
- Available dropdown options: ${JSON.stringify(dropdownOptions, null, 2)}
- Enum field mappings: ${JSON.stringify(enumFieldsInfo, null, 2)}

Please provide a JSON response with suggested values for ALL the empty fields in the form. Base your suggestions on the name "${nameValue}" and any existing form data.

CRITICAL ENUM/DROPDOWN RULES:
- For enum fields, you MUST use the exact enum CODES from the "Enum field mappings" section
- For example, if language enum has code "en" for "English", use "en", not "English"
- For dropdown/select fields, use the exact values from "Available dropdown options"
- For language field, use language codes like "en", "es", "fr" (from basic template enum)
- For difficulty fields, use lowercase values like "beginner", "intermediate", "advanced"
- For category fields, check if they use codes or display names in the enum mappings

OTHER FIELD RULES:
- For DID references, use placeholder values like "did:arweave:placeholder123..."
- For arrays, provide realistic arrays with 2-3 items
- For numeric fields, provide realistic numbers
- For text fields, provide helpful content

Return ONLY a valid JSON object with the field values, no additional text or explanation.`;

            return prompt;
        }

        /**
         * Extract enum field information from schema for AI guidance
         */
        function extractEnumFieldsFromSchema(schemaData) {
            const enumFields = {};
            
            // Extract from main template fields
            if (schemaData.template_fields_info) {
                Object.keys(schemaData.template_fields_info).forEach(fieldName => {
                    const fieldDef = schemaData.template_fields_info[fieldName];
                    if (fieldDef.type === 'enum' && fieldDef.enumValues) {
                        enumFields[fieldName] = {
                            type: 'enum',
                            codes: fieldDef.enumValues.map(ev => ev.code),
                            options: fieldDef.enumValues.map(ev => `${ev.code} = "${ev.name}"`),
                            note: `Use enum codes like: ${fieldDef.enumValues.slice(0, 3).map(ev => ev.code).join(', ')}`
                        };
                    }
                });
            }
            
            // Extract from basic template fields (for language, etc.)
            if (schemaData.basic_template_fields_info) {
                Object.keys(schemaData.basic_template_fields_info).forEach(fieldName => {
                    const fieldDef = schemaData.basic_template_fields_info[fieldName];
                    if (fieldDef.type === 'enum' && fieldDef.enumValues) {
                        enumFields[`basic_${fieldName}`] = {
                            type: 'enum',
                            codes: fieldDef.enumValues.map(ev => ev.code),
                            options: fieldDef.enumValues.slice(0, 10).map(ev => `${ev.code} = "${ev.name}"`), // Limit to first 10 for readability
                            note: `Use enum codes like: ${fieldDef.enumValues.slice(0, 5).map(ev => ev.code).join(', ')}`
                        };
                    }
                });
            }
            
            return enumFields;
        }

        /**
         * Get dropdown options for a record type to help AI make better choices
         */
        function getDropdownOptionsForRecordType(recordType) {
            const options = {};
            
            // Get all select elements in the current form
            const form = document.querySelector('.publish-form');
            if (form) {
                const selects = form.querySelectorAll('select');
                selects.forEach(select => {
                    if (select.id && select.options.length > 1) {
                        const selectOptions = Array.from(select.options)
                            .filter(opt => opt.value) // Exclude empty options
                            .map(opt => opt.value);
                        
                        if (selectOptions.length > 0) {
                            options[select.id] = selectOptions;
                        }
                    }
                });
            }
            
            // Also get template enum values from the dynamic template system
            const templateEnumOptions = getTemplateEnumOptions(recordType);
            Object.assign(options, templateEnumOptions);
            
            return options;
        }

        /**
         * Get enum options from template field definitions
         */
        function getTemplateEnumOptions(recordType) {
            const enumOptions = {};
            
            // Get template field mapping for this record type
            const fieldsMap = templateFieldMap[recordType];
            if (fieldsMap) {
                Object.keys(fieldsMap).forEach(fieldName => {
                    const fieldDef = fieldsMap[fieldName];
                    if (fieldDef.type === 'enum' && fieldDef.enumValues) {
                        // Convert enum values to code -> name mapping
                        const enumCodes = fieldDef.enumValues.map(enumValue => {
                            if (typeof enumValue === 'object' && enumValue.code) {
                                return enumValue.code;
                            }
                            return enumValue;
                        });
                        
                        enumOptions[`template_${fieldName}_enum`] = enumCodes;
                        console.log(`[Template Schema] Found enum for ${fieldName}:`, enumCodes);
                    }
                });
            }
            
            return enumOptions;
        }

        // ========================================================================
        // DROPDOWN VALUE MAPPING FUNCTIONS
        // ========================================================================

        /**
         * Map equipment category values to dropdown options
         */
        function mapEquipmentCategory(value) {
            const mappings = {
                'weight': 'weights',
                'weights': 'weights',
                'cardio': 'cardio',
                'bodyweight': 'bodyweight',
                'flexibility': 'flexibility',
                'functional': 'functional',
                'accessories': 'accessories',
                'free weights': 'weights',
                'strength': 'weights',
                'strength training': 'weights'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue; // Return lowercase version as fallback
        }

        /**
         * Map language names to language codes
         */
        function mapLanguageCode(value) {
            const mappings = {
                'english': 'en',
                'spanish': 'es',
                'french': 'fr',
                'german': 'de',
                'italian': 'it',
                'portuguese': 'pt',
                'chinese': 'zh',
                'japanese': 'ja',
                'korean': 'ko',
                'arabic': 'ar',
                'hindi': 'hi',
                'russian': 'ru',
                'en': 'en',
                'es': 'es',
                'fr': 'fr',
                'de': 'de',
                'it': 'it',
                'pt': 'pt',
                'zh': 'zh',
                'ja': 'ja',
                'ko': 'ko',
                'ar': 'ar',
                'hi': 'hi',
                'ru': 'ru'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || 'en'; // Default to English
        }

        /**
         * Map difficulty level values to dropdown options
         */
        function mapDifficultyLevel(value) {
            const mappings = {
                'easy': 'beginner',
                'beginner': 'beginner',
                'medium': 'intermediate', 
                'intermediate': 'intermediate',
                'hard': 'advanced',
                'advanced': 'advanced'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue; // Return lowercase version as fallback
        }

        /**
         * Map space required values to dropdown options
         */
        function mapSpaceRequired(value) {
            const mappings = {
                'minimal': 'minimal',
                'minimal space': 'minimal',
                'small': 'small',
                'small space': 'small',
                'medium': 'medium',
                'medium space': 'medium',
                'large': 'large',
                'large space': 'large'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Map portability values to dropdown options
         */
        function mapPortability(value) {
            const mappings = {
                'portable': 'portable',
                'semi-portable': 'semi_portable',
                'semi portable': 'semi_portable',
                'stationary': 'stationary',
                'fixed': 'stationary'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Map price range values to dropdown options
         */
        function mapPriceRange(value) {
            const mappings = {
                'budget': 'budget',
                'cheap': 'budget',
                'low': 'budget',
                'mid-range': 'mid_range',
                'mid range': 'mid_range',
                'medium': 'mid_range',
                'premium': 'premium',
                'expensive': 'premium',
                'professional': 'professional',
                'high-end': 'professional'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Map maintenance level values to dropdown options
         */
        function mapMaintenanceLevel(value) {
            const mappings = {
                'none': 'none',
                'no maintenance': 'none',
                'low': 'low',
                'low maintenance': 'low',
                'medium': 'medium',
                'medium maintenance': 'medium',
                'high': 'high',
                'high maintenance': 'high'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Map exercise category values to dropdown options
         */
        function mapExerciseCategory(value) {
            const mappings = {
                'strength': 'Strength',
                'cardio': 'Cardio',
                'flexibility': 'Flexibility',
                'balance': 'Balance',
                'functional': 'Functional',
                'rehabilitation': 'Rehabilitation',
                'strength training': 'Strength',
                'cardiovascular': 'Cardio'
            };
            
            const lowerValue = String(value).toLowerCase();
            // For exercise category, we need capitalized values, so use original mapping logic
            return mappings[lowerValue] || value;
        }

        /**
         * Map exercise type values to dropdown options
         */
        function mapExerciseType(value) {
            const mappings = {
                'main': 'Main',
                'warmup': 'Warmup',
                'warm-up': 'Warmup',
                'cooldown': 'Cooldown',
                'cool-down': 'Cooldown',
                'primary': 'Main',
                'warm up': 'Warmup',
                'cool down': 'Cooldown'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Map measurement type values to dropdown options
         */
        function mapMeasurementType(value) {
            const mappings = {
                'reps': 'Reps',
                'repetitions': 'Reps',
                'time': 'Time',
                'seconds': 'Time',
                'duration': 'Time',
                'distance': 'Distance'
            };
            
            const lowerValue = String(value).toLowerCase();
            return mappings[lowerValue] || lowerValue;
        }

        /**
         * Call OpenAI for field filling
         */
        async function callOpenAIForFieldFilling(prompt) {
            // Use the existing OpenAI integration pattern from voice.js
            const conversation = [
                {
                    role: "system",
                    content: "You are a helpful assistant that fills out forms based on context. Return only valid JSON responses."
                },
                {
                    role: "user", 
                    content: prompt
                }
            ];

            try {
                // Try to use the existing voice chat endpoint for OpenAI
                const response = await fetch('/api/voice/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(authToken && { 'Authorization': `Bearer ${authToken}` })
                    },
                    body: JSON.stringify({
                        text: prompt,
                        model: 'grok-beta',
                        processing_mode: 'llm-grok-4',
                        return_audio: false,
                        conversation_history: []
                    })
                });

                const data = await response.json();
                
                if (data.response_text) {
                    return data.response_text;
                } else {
                    throw new Error('No response from AI');
                }
            } catch (error) {
                console.error('[Smart AI] OpenAI call failed:', error);
                throw error;
            }
        }

        /**
         * Parse AI response and populate form
         */
        async function populateFormFromAIResponse(recordType, aiResponse, schemaData) {
            try {
                // Try to extract JSON from AI response
                let jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('AI did not return valid JSON');
                }

                const aiData = JSON.parse(jsonMatch[0]);
                console.log(`[Smart AI] Parsed AI data:`, aiData);

                // Map AI response to form fields
                await populateFormFromAIData(recordType, aiData);

            } catch (error) {
                console.error('[Smart AI] Error parsing AI response:', error);
                throw new Error('Failed to parse AI response');
            }
        }

        /**
         * Populate form from AI-generated data
         */
        async function populateFormFromAIData(recordType, aiData) {
            // Extract basic and specific data
            const basicData = aiData.basic || {};
            const specificData = aiData[recordType] || {};

            // Use the same populate functions as copy from record
            switch (recordType) {
                case 'recipe':
                    await populateRecipeForm(basicData, specificData);
                    break;
                case 'exercise':
                    await populateExerciseForm(basicData, specificData);
                    break;
                case 'workout':
                    await populateWorkoutForm(basicData, specificData);
                    break;
                case 'post':
                    await populatePostForm(basicData, specificData);
                    break;
                case 'fitnessEquipment':
                    await populateFitnessEquipmentForm(basicData, specificData);
                    break;
                case 'video':
                    await populateVideoForm(basicData, specificData);
                    break;
                case 'audio':
                    await populateAudioForm(basicData, specificData);
                    break;
                case 'music':
                    await populateAudioForm(basicData, aiData.audio, aiData.music);
                    break;
                case 'image':
                    await populateImageForm(basicData, specificData);
                    break;
                case 'text':
                    await populateTextForm(basicData, specificData);
                    break;
                case 'organization':
                    await populateOrganizationForm(basicData, specificData);
                    break;
                case 'media':
                    await populateMediaForm(basicData, specificData);
                    break;
                default:
                    console.warn(`[Smart AI] No populate function for record type: ${recordType}`);
            }
        }

        // ========================================================================
        // FORM POPULATION FUNCTIONS
        // ========================================================================

        /**
         * Populate recipe form with data
         */
        async function populateRecipeForm(basicData, recipeData) {
            console.log('[Smart Copy] Populating recipe form:', { basicData, recipeData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('recipe-description', basicData.description);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('recipe-tags', basicData.tagItems.join(', '));
            }

            // Recipe-specific fields
            if (recipeData.prep_time_mins) {
                setFieldValue('recipe-prep-time', recipeData.prep_time_mins);
            }
            if (recipeData.cook_time_mins) {
                setFieldValue('recipe-cook-time', recipeData.cook_time_mins);
            }
            if (recipeData.servings) {
                setFieldValue('recipe-servings', recipeData.servings);
            }
            if (recipeData.cuisine) {
                setFieldValue('recipe-cuisine', recipeData.cuisine);
            }
            if (recipeData.course) {
                setFieldValue('recipe-course', recipeData.course);
            }
            if (recipeData.instructions) {
                setFieldValue('recipe-instructions', recipeData.instructions);
            }
            if (recipeData.notes) {
                setFieldValue('recipe-notes', recipeData.notes);
            }

            // Handle ingredients if they exist
            if (recipeData.ingredient && Array.isArray(recipeData.ingredient)) {
                await populateIngredientsFromData(recipeData);
            }
        }

        /**
         * Populate exercise form with data
         */
        async function populateExerciseForm(basicData, exerciseData) {
            console.log('[Smart Copy] Populating exercise form:', { basicData, exerciseData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('exercise-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('exercise-language', basicData.language);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('exercise-tags', basicData.tagItems.join(', '));
            }
            if (basicData.avatar) {
                setFieldValue('exercise-avatar', basicData.avatar);
            }

            // Exercise-specific fields
            if (exerciseData.instructions && Array.isArray(exerciseData.instructions)) {
                setFieldValue('exercise-instructions', exerciseData.instructions.join('\n'));
            }
            if (exerciseData.muscleGroups && Array.isArray(exerciseData.muscleGroups)) {
                setFieldValue('exercise-muscle-groups', exerciseData.muscleGroups.join(', '));
            }
            if (exerciseData.difficulty) {
                setFieldValue('exercise-difficulty', exerciseData.difficulty);
            }
            if (exerciseData.category) {
                setFieldValue('exercise-category', exerciseData.category);
            }
            if (exerciseData.equipmentRequired && Array.isArray(exerciseData.equipmentRequired)) {
                populateEquipmentField('equipment-required-container', exerciseData.equipmentRequired);
            }
            if (exerciseData.alternativeEquipment && Array.isArray(exerciseData.alternativeEquipment)) {
                populateEquipmentField('alternative-equipment-container', exerciseData.alternativeEquipment);
            }
            if (exerciseData.exercise_type) {
                setFieldValue('exercise-type', exerciseData.exercise_type);
            }
            if (exerciseData.measurement_type) {
                setFieldValue('exercise-measurement-type', exerciseData.measurement_type);
            }
            if (exerciseData.est_duration_minutes) {
                setFieldValue('exercise-duration', exerciseData.est_duration_minutes);
            }
            if (exerciseData.recommended_sets) {
                setFieldValue('exercise-recommended-sets', exerciseData.recommended_sets);
            }
            if (exerciseData.recommended_reps) {
                setFieldValue('exercise-recommended-reps', exerciseData.recommended_reps);
            }
            if (exerciseData.target_duration_seconds) {
                setFieldValue('exercise-target-duration', exerciseData.target_duration_seconds);
            }
            if (exerciseData.isBodyweight) {
                setCheckboxValue('exercise-bodyweight', exerciseData.isBodyweight);
            }
        }

        // Helper function to populate equipment fields
        function populateEquipmentField(containerId, equipmentList) {
            const container = document.getElementById(containerId);
            if (!container || !equipmentList || equipmentList.length === 0) return;
            
            // Clear existing rows except the first one
            const existingRows = container.querySelectorAll('.equipment-row');
            for (let i = 1; i < existingRows.length; i++) {
                existingRows[i].remove();
            }
            
            // Populate the first row
            const firstSelect = container.querySelector('.equipment-select');
            if (firstSelect && equipmentList[0]) {
                firstSelect.value = equipmentList[0];
            }
            
            // Add additional rows for remaining equipment
            for (let i = 1; i < equipmentList.length; i++) {
                addEquipmentRow(containerId);
                const newSelect = container.lastElementChild.querySelector('.equipment-select');
                if (newSelect && equipmentList[i]) {
                    newSelect.value = equipmentList[i];
                }
            }
        }

        /**
         * Populate workout form with data
         */
        async function populateWorkoutForm(basicData, workoutData) {
            console.log('[Smart Copy] Populating workout form:', { basicData, workoutData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('workout-description', basicData.description);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('workout-goals', basicData.tagItems.join(', '));
            }

            // Workout-specific fields
            if (workoutData.duration_mins) {
                setFieldValue('workout-duration', workoutData.duration_mins);
            }
            if (workoutData.difficulty) {
                setFieldValue('workout-difficulty', workoutData.difficulty);
            }
            if (workoutData.category) {
                setFieldValue('workout-category', workoutData.category);
            }
            if (workoutData.equipment_required && Array.isArray(workoutData.equipment_required)) {
                setFieldValue('workout-equipment', workoutData.equipment_required.join(', '));
            }
            if (workoutData.target_muscle_groups && Array.isArray(workoutData.target_muscle_groups)) {
                setFieldValue('workout-muscles', workoutData.target_muscle_groups.join(', '));
            }
            if (workoutData.notes) {
                setFieldValue('workout-notes', workoutData.notes);
            }
            if (workoutData.non_standard) {
                setCheckboxValue('workout-non-standard', workoutData.non_standard);
            }

            // Handle exercises if they exist
            if (workoutData.exercise && Array.isArray(workoutData.exercise)) {
                await populateExercisesFromData(workoutData);
            }
        }

        /**
         * Populate post form with data
         */
        async function populatePostForm(basicData, postData) {
            console.log('[Smart Copy] Populating post form:', { basicData, postData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('post-description', basicData.description);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('post-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('post-nsfw', basicData.nsfw);
            }

            // Post-specific fields
            if (postData.articleText) {
                setFieldValue('post-content', postData.articleText);
            }
            if (postData.bylineWriter) {
                setFieldValue('post-author', postData.bylineWriter);
            }
            if (postData.bylineWritersTitle) {
                setFieldValue('post-author-title', postData.bylineWritersTitle);
            }
            if (postData.bylineWritersLocation) {
                setFieldValue('post-author-location', postData.bylineWritersLocation);
            }
            if (postData.webUrl) {
                setFieldValue('post-web-url', postData.webUrl);
            }
            if (postData.featuredImage) {
                setFieldValue('post-featured-image', postData.featuredImage);
            }
            if (postData.replyTo) {
                setFieldValue('post-reply-to', postData.replyTo);
            }
        }

        /**
         * Populate fitness equipment form with data
         */
        async function populateFitnessEquipmentForm(basicData, equipmentData) {
            console.log('[Smart Copy] Populating fitness equipment form:', { basicData, equipmentData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('equipment-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('equipment-language', basicData.language);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('equipment-tags', basicData.tagItems.join(', '));
            }
            if (basicData.avatar) {
                setFieldValue('equipment-avatar', basicData.avatar);
            }

            // Equipment-specific fields with smart mapping
            if (equipmentData.category) {
                setFieldValue('equipment-category', equipmentData.category);
            }
            if (equipmentData.subcategory) {
                setFieldValue('equipment-subcategory', equipmentData.subcategory);
            }
            if (equipmentData.muscle_groups && Array.isArray(equipmentData.muscle_groups)) {
                setFieldValue('equipment-muscle-groups', equipmentData.muscle_groups.join(', '));
            }
            if (equipmentData.exercise_types && Array.isArray(equipmentData.exercise_types)) {
                setFieldValue('equipment-exercise-types', equipmentData.exercise_types.join(', '));
            }
            if (equipmentData.difficulty_level || equipmentData.difficulty) {
                setFieldValue('equipment-difficulty', equipmentData.difficulty_level || equipmentData.difficulty);
            }
            if (equipmentData.space_required) {
                setFieldValue('equipment-space-required', equipmentData.space_required);
            }
            if (equipmentData.portability) {
                setFieldValue('equipment-portability', equipmentData.portability);
            }
            if (equipmentData.price_range) {
                setFieldValue('equipment-price-range', equipmentData.price_range);
            }
            if (equipmentData.maintenance_level || equipmentData.maintenance) {
                setFieldValue('equipment-maintenance', equipmentData.maintenance_level || equipmentData.maintenance);
            }
            if (equipmentData.alternatives && Array.isArray(equipmentData.alternatives)) {
                setFieldValue('equipment-alternatives', equipmentData.alternatives.join(', '));
            }
            if (equipmentData.safety_considerations) {
                setFieldValue('equipment-safety', equipmentData.safety_considerations);
            }
            if (equipmentData.beginner_friendly) {
                setCheckboxValue('equipment-beginner-friendly', equipmentData.beginner_friendly);
            }
            if (equipmentData.home_gym_suitable) {
                setCheckboxValue('equipment-home-gym', equipmentData.home_gym_suitable);
            }
            if (equipmentData.commercial_grade) {
                setCheckboxValue('equipment-commercial', equipmentData.commercial_grade);
            }
        }

        /**
         * Helper function to set field value safely
         */
        function setFieldValue(fieldId, value) {
            const field = document.getElementById(fieldId);
            if (field && value !== null && value !== undefined) {
                const stringValue = String(value);
                
                if (field.tagName.toLowerCase() === 'select') {
                    // For select elements, try to find a matching option
                    const options = Array.from(field.options);
                    
                    // First try exact match
                    let matchingOption = options.find(opt => opt.value === stringValue);
                    
                    // If no exact match, try case-insensitive match
                    if (!matchingOption) {
                        matchingOption = options.find(opt => 
                            opt.value.toLowerCase() === stringValue.toLowerCase()
                        );
                    }
                    
                    // If still no match, try partial match on option text
                    if (!matchingOption) {
                        matchingOption = options.find(opt => 
                            opt.textContent.toLowerCase().includes(stringValue.toLowerCase())
                        );
                    }
                    
                    // If still no match, try to find by the display text
                    if (!matchingOption) {
                        matchingOption = options.find(opt => 
                            stringValue.toLowerCase().includes(opt.textContent.toLowerCase())
                        );
                    }
                    
                    // If still no match, try template-based enum mapping
                    if (!matchingOption) {
                        const templateMappedValue = mapValueUsingTemplateSchema(fieldId, stringValue, window.currentSchemaData);
                        if (templateMappedValue !== stringValue) {
                            matchingOption = options.find(opt => opt.value === templateMappedValue);
                        }
                    }
                    
                    if (matchingOption) {
                        field.value = matchingOption.value;
                        console.log(`[Smart Copy] ✅ Set select ${fieldId} = "${matchingOption.value}" (matched "${stringValue}")`);
                    } else {
                        console.warn(`[Smart Copy] ❌ No matching option found for ${fieldId} = "${stringValue}". Available options:`, options.map(opt => `"${opt.value}"`));
                        // Try to set it anyway in case the browser can handle it
                        field.value = stringValue;
                    }
                } else {
                    // For regular input/textarea elements
                    field.value = stringValue;
                    console.log(`[Smart Copy] Set ${fieldId} = "${stringValue}"`);
                }
            }
        }

        /**
         * Map value using template schema for enum fields
         */
        function mapValueUsingTemplateSchema(fieldId, value, schemaData = null) {
            // Extract record type and field name from field ID
            const recordType = getCurrentRecordType();
            if (!recordType) return value;
            
            // Get field name from field ID (e.g., "equipment-category" -> "category")
            let fieldName = fieldId.replace(`${recordType}-`, '').replace('equipment-', '');
            
            // Special handling for basic template fields (language is in basic template)
            let isBasicField = false;
            if (fieldId.includes('-language')) {
                fieldName = 'language';
                isBasicField = true;
            }
            
            // Use schema data if provided, otherwise try template field mapping
            let fieldDef = null;
            if (schemaData) {
                if (isBasicField && schemaData.basic_template_fields_info && schemaData.basic_template_fields_info[fieldName]) {
                    fieldDef = schemaData.basic_template_fields_info[fieldName];
                } else if (schemaData.template_fields_info && schemaData.template_fields_info[fieldName]) {
                    fieldDef = schemaData.template_fields_info[fieldName];
                }
            } else {
                // Fallback to template field mapping
                const templateName = isBasicField ? 'basic' : recordType;
                const fieldsMap = templateFieldMap[templateName];
                if (fieldsMap && fieldsMap[fieldName]) {
                    fieldDef = fieldsMap[fieldName];
                }
            }
            
            if (fieldDef && fieldDef.type === 'enum' && fieldDef.enumValues) {
                // Try to find matching enum value
                const enumValue = fieldDef.enumValues.find(enumVal => {
                    if (typeof enumVal === 'object' && enumVal.name && enumVal.code) {
                        // Check if value matches the display name (case-insensitive)
                        return enumVal.name.toLowerCase() === value.toLowerCase();
                    }
                    return false;
                });
                
                if (enumValue) {
                    console.log(`[Template Schema] Mapped "${value}" to enum code "${enumValue.code}" for field ${fieldName}`);
                    return enumValue.code;
                }
                
                // Also try reverse mapping - if value is already a code, find the name
                const enumByCode = fieldDef.enumValues.find(enumVal => {
                    if (typeof enumVal === 'object' && enumVal.code) {
                        return enumVal.code.toLowerCase() === value.toLowerCase();
                    }
                    return false;
                });
                
                if (enumByCode) {
                    console.log(`[Template Schema] Value "${value}" is already a valid enum code for field ${fieldName}`);
                    return enumByCode.code;
                }
            }
            
            return value;
        }

        /**
         * Get current record type from the publish interface
         */
        function getCurrentRecordType() {
            const recordTypeSelect = document.getElementById('publish-record-type');
            return recordTypeSelect ? recordTypeSelect.value : null;
        }

        /**
         * Debug function to test enum mapping for a field
         */
        function debugEnumMapping(fieldId, testValue) {
            console.log(`[Debug] Testing enum mapping for ${fieldId} with value "${testValue}"`);
            const mappedValue = mapValueUsingTemplateSchema(fieldId, testValue, window.currentSchemaData);
            console.log(`[Debug] Mapped value: "${mappedValue}"`);
            
            const field = document.getElementById(fieldId);
            if (field && field.tagName.toLowerCase() === 'select') {
                const options = Array.from(field.options).map(opt => `"${opt.value}"`);
                console.log(`[Debug] Available options for ${fieldId}:`, options);
            }
            
            return mappedValue;
        }

        // Make debug function available globally
        window.debugEnumMapping = debugEnumMapping;

        /**
         * Helper function to set checkbox value safely
         */
        function setCheckboxValue(fieldId, value) {
            const field = document.getElementById(fieldId);
            if (field && typeof value === 'boolean') {
                field.checked = value;
                console.log(`[Smart Copy] Set ${fieldId} = ${value}`);
            }
        }

        /**
         * Populate ingredients from recipe data
         */
        async function populateIngredientsFromData(recipeData) {
            const container = document.getElementById('ingredients-container');
            if (!container) return;

            // Clear existing ingredients except the first row
            const existingRows = container.querySelectorAll('.ingredient-row');
            for (let i = 1; i < existingRows.length; i++) {
                existingRows[i].remove();
            }

            const ingredients = recipeData.ingredient || [];
            const amounts = recipeData.ingredient_amount || [];
            const units = recipeData.ingredient_unit || [];

            for (let i = 0; i < ingredients.length; i++) {
                // Use existing row or create new one
                let row;
                if (i === 0) {
                    row = existingRows[0];
                } else {
                    addIngredient();
                    row = container.lastElementChild;
                }

                // Populate the row
                const amountInput = row.querySelector('.ingredient-amount');
                const unitInput = row.querySelector('.ingredient-unit');
                const nameInput = row.querySelector('.ingredient-name');

                if (amountInput && amounts[i]) {
                    amountInput.value = amounts[i];
                }
                if (unitInput && units[i]) {
                    unitInput.value = units[i];
                }
                if (nameInput && ingredients[i]) {
                    // Handle both string names and DID references
                    const ingredientName = typeof ingredients[i] === 'string' 
                        ? ingredients[i].replace(/^did:arweave:/, '').substring(0, 20) + '...'
                        : ingredients[i];
                    nameInput.value = ingredientName;
                }
            }
        }

        /**
         * Populate exercises from workout data
         */
        async function populateExercisesFromData(workoutData) {
            const container = document.getElementById('exercises-container');
            if (!container) return;

            // Clear existing exercises except the first row
            const existingRows = container.querySelectorAll('.exercise-row');
            for (let i = 1; i < existingRows.length; i++) {
                existingRows[i].remove();
            }

            const exercises = workoutData.exercise || [];
            const sets = workoutData.exercise_sets || [];
            const reps = workoutData.exercise_reps || [];
            const rest = workoutData.exercise_rest_seconds || [];

            for (let i = 0; i < exercises.length; i++) {
                // Use existing row or create new one
                let row;
                if (i === 0) {
                    row = existingRows[0];
                } else {
                    addExercise();
                    row = container.lastElementChild;
                }

                // Populate the row
                const nameInput = row.querySelector('.exercise-name');
                const setsInput = row.querySelector('.exercise-sets');
                const repsInput = row.querySelector('.exercise-reps');
                const restInput = row.querySelector('.exercise-rest');

                if (nameInput && exercises[i]) {
                    // Handle both string names and DID references
                    const exerciseName = typeof exercises[i] === 'string'
                        ? exercises[i].replace(/^did:arweave:/, '').substring(0, 30)
                        : exercises[i];
                    nameInput.value = exerciseName;
                }
                if (setsInput && sets[i]) {
                    setsInput.value = sets[i];
                }
                if (repsInput && reps[i]) {
                    repsInput.value = reps[i];
                }
                if (restInput && rest[i]) {
                    restInput.value = rest[i];
                }
            }
        }

        /**
         * Populate video form with data
         */
        async function populateVideoForm(basicData, videoData) {
            console.log('[Smart Copy] Populating video form:', { basicData, videoData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('video-description', basicData.description);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('video-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('video-nsfw', basicData.nsfw);
            }

            // Video-specific fields
            if (videoData.webUrl) {
                setFieldValue('video-url', videoData.webUrl);
            }
            if (videoData.duration) {
                setFieldValue('video-duration', Math.ceil(videoData.duration / 60)); // Convert seconds to minutes
            }
            if (videoData.uploader) {
                setFieldValue('video-channel', videoData.uploader);
            }
            if (videoData.thumbnail || videoData.thumbnailUrl) {
                setFieldValue('video-thumbnail', videoData.thumbnail || videoData.thumbnailUrl);
            }
            if (videoData.category) {
                setFieldValue('video-category', videoData.category);
            }
        }

        /**
         * Populate audio form with data
         */
        async function populateAudioForm(basicData, audioData, musicData = null) {
            console.log('[Smart Copy] Populating audio form:', { basicData, audioData, musicData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('audio-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('audio-language', basicData.language);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('audio-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('audio-nsfw', basicData.nsfw);
            }

            // Audio-specific fields
            if (audioData.webUrl) {
                setFieldValue('audio-url', audioData.webUrl);
            }
            if (audioData.duration) {
                setFieldValue('audio-duration', audioData.duration); // Keep as seconds
            }
            if (audioData.creator) {
                setFieldValue('audio-creator', audioData.creator);
            }

            // If music data is present, populate music fields and set audio type
            if (musicData) {
                setFieldValue('audio-type', 'music');
                updateAudioTypeInterface(); // Show music fields
                
                if (musicData.genre) {
                    setFieldValue('music-genre', musicData.genre);
                }
                if (musicData.subGenre) {
                    setFieldValue('music-sub-genre', musicData.subGenre);
                }
                if (musicData.bpm) {
                    setFieldValue('music-bpm', musicData.bpm);
                }
                if (musicData.key) {
                    setFieldValue('music-key', musicData.key);
                }
                if (musicData.sampleRateHz) {
                    setFieldValue('music-sample-rate', musicData.sampleRateHz);
                }
                if (musicData.bitDepth) {
                    setFieldValue('music-bit-depth', musicData.bitDepth);
                }
                if (musicData.album) {
                    setFieldValue('music-album', musicData.album);
                }
                if (musicData.trackNumber) {
                    setFieldValue('music-track-number', musicData.trackNumber);
                }
                if (musicData.isrc) {
                    setFieldValue('music-isrc', musicData.isrc);
                }
                if (musicData.lyrics) {
                    setFieldValue('music-lyrics', musicData.lyrics);
                }
                if (musicData.composerItems && Array.isArray(musicData.composerItems)) {
                    setFieldValue('music-composers', musicData.composerItems.join(', '));
                }
                if (musicData.performerItems && Array.isArray(musicData.performerItems)) {
                    setFieldValue('music-performers', musicData.performerItems.join(', '));
                }
            } else {
                // Regular audio record, hide music fields
                setFieldValue('audio-type', 'podcast');
                updateAudioTypeInterface();
            }
        }

        /**
         * Populate image form with data
         */
        async function populateImageForm(basicData, imageData) {
            console.log('[Smart Copy] Populating image form:', { basicData, imageData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('image-description', basicData.description);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('image-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('image-nsfw', basicData.nsfw);
            }

            // Image-specific fields
            if (imageData.webUrl) {
                setFieldValue('image-url', imageData.webUrl);
            }
            if (imageData.altText) {
                setFieldValue('image-alt-text', imageData.altText);
            }
            if (imageData.photographer) {
                setFieldValue('image-photographer', imageData.photographer);
            }
            if (imageData.location) {
                setFieldValue('image-location', imageData.location);
            }
            if (imageData.category) {
                setFieldValue('image-category', imageData.category);
            }
        }

        /**
         * Populate text form with data
         */
        async function populateTextForm(basicData, textData) {
            console.log('[Smart Copy] Populating text form:', { basicData, textData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('text-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('text-language', basicData.language);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('text-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('text-nsfw', basicData.nsfw);
            }

            // Text-specific fields
            if (textData.content) {
                setFieldValue('text-content', textData.content);
            }
            if (textData.type) {
                setFieldValue('text-type', textData.type);
            }
            if (textData.author) {
                setFieldValue('text-author', textData.author);
            }
        }

        /**
         * Populate organization form with data
         */
        async function populateOrganizationForm(basicData, orgData) {
            console.log('[Smart Copy] Populating organization form:', { basicData, orgData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('org-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('org-language', basicData.language);
            }
            if (basicData.webUrl) {
                setFieldValue('org-web-url', basicData.webUrl);
            }

            // Organization-specific fields
            if (orgData.org_handle) {
                setFieldValue('org-handle', orgData.org_handle);
            }
            if (orgData.membership_policy) {
                setFieldValue('org-membership-policy', orgData.membership_policy);
            }
        }

        /**
         * Populate media form with data
         */
        async function populateMediaForm(basicData, mediaData) {
            console.log('[Smart Copy] Populating media form:', { basicData, mediaData });
            
            // Basic fields
            if (basicData.description) {
                setFieldValue('media-description', basicData.description);
            }
            if (basicData.language) {
                setFieldValue('media-language', basicData.language);
            }
            if (basicData.tagItems && Array.isArray(basicData.tagItems)) {
                setFieldValue('media-tags', basicData.tagItems.join(', '));
            }
            if (basicData.nsfw) {
                setCheckboxValue('media-nsfw', basicData.nsfw);
            }

            // Media-specific fields - these are mostly handled by file upload
            // but we can set access level if available
            if (mediaData.access_level) {
                setFieldValue('media-access-level', mediaData.access_level);
            }
        }

        // Header Search and Filters Drawer Functions
        function handleHeaderSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                // Update the hidden search input
                document.getElementById('voice-search-input').value = searchTerm;
                // Switch to browse interface and apply filters
                showSearchInterface();
                applyVoiceFilters();
            }
        }

        function toggleFiltersDrawer() {
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            const filtersSection = document.querySelector('.filters-section');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                document.getElementById('search-interface').appendChild(filtersSection);
            } else {
                drawer.classList.add('open');
                toggle.classList.add('active');
                // Move filters to drawer
                document.querySelector('.filters-drawer-content').appendChild(filtersSection);
            }
        }

        function showHeaderSearch() {
            document.getElementById('header-search').classList.remove('hidden');
        }

        function hideHeaderSearch() {
            document.getElementById('header-search').classList.add('hidden');
            // Close filters drawer when hiding search
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                const filtersSection = document.querySelector('.filters-section');
                document.getElementById('search-interface').appendChild(filtersSection);
            }
        }

        // ========================================================================
        // MODERN MEDIA-FOCUSED RECORD CARDS (YouTube/SoundCloud/Flickr Style)
        // ========================================================================
        
        /**
         * Create a podcast show card that groups multiple episodes
         */
        function createPodcastShowCard(showName, episodes, baseIndex) {
            const card = document.createElement('div');
            card.className = 'record-card podcast-show-card';
            card.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
            card.style.border = '2px solid #667eea';
            
            // Sort episodes by date (newest first)
            episodes.sort((a, b) => (b.data?.basic?.date || 0) - (a.data?.basic?.date || 0));
            
            const showArtwork = showName === 'The Light of Inquiry' ? 'TheLightOfInquiry-v2.png' : 'icons/noun-microphone-7907572.svg';
            const episodeCount = episodes.length;
            const latestEpisode = episodes[0];
            
            card.innerHTML = `
                <div class="podcast-show-header" style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #667eea;">
                    <img src="${showArtwork}" alt="${showName}" style="width: 80px; height: 80px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);" onerror="this.src='icons/noun-microphone-7907572.svg'">
                    <div style="flex: 1;">
                        <h2 style="margin: 0 0 5px 0; color: #667eea; font-size: 1.4rem; font-weight: 700;">🎙️ ${showName}</h2>
                        <div style="color: #6c757d; font-size: 14px; margin-bottom: 5px;">${episodeCount} Episode${episodeCount === 1 ? '' : 's'}</div>
                        <div style="color: #495057; font-size: 13px;">Latest: ${formatDate(latestEpisode.data?.basic?.date)}</div>
                    </div>
                    <button onclick="toggleShowEpisodes('${showName.replace(/'/g, "\\'")}')" class="show-toggle-btn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer;">
                        Show Episodes
                    </button>
                </div>
                
                <div id="episodes-${showName.replace(/[^a-zA-Z0-9]/g, '_')}" class="episodes-container" style="display: none;">
                    ${episodes.map((episode, index) => createEpisodeCard(episode, baseIndex + index, showName)).join('')}
                </div>
            `;
            
            return card;
        }

        /**
         * Create an individual episode card within a show
         */
        function createEpisodeCard(episode, episodeIndex, showName) {
            const basicData = episode.data?.basic || {};
            const podcastData = episode.data?.podcast || {};
            const audioData = episode.data?.audio || {};
            
            const episodeTitle = basicData.name || 'Untitled Episode';
            const episodeDescription = basicData.description || '';
            const episodeDate = formatDate(basicData.date);
            const episodeTime = formatTime(basicData.date);
            const citations = basicData.citations || [];
            const citationCount = Array.isArray(citations) ? citations.length : 0;
            
            return `
                <div class="episode-card" style="margin: 15px 0; padding: 15px; border: 1px solid #e9ecef; border-radius: 8px; background: white;">
                    <div class="episode-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 5px 0; color: #333; font-size: 1.1rem;">${episodeTitle}</h4>
                            <div style="color: #6c757d; font-size: 12px; margin-bottom: 8px;">
                                📅 ${episodeDate} • 🕐 ${episodeTime}
                            </div>
                        </div>
                    </div>
                    
                    ${episodeDescription ? `<p style="color: #666; font-size: 14px; line-height: 1.4; margin-bottom: 12px;">${truncateText(episodeDescription, 200)}</p>` : ''}
                    
                    <div class="episode-controls" style="display: flex; gap: 10px; align-items: center; margin-bottom: 12px;">
                        ${audioData.webUrl ? `
                            <button class="play-btn primary" onclick="playAudioInMaster('${audioData.webUrl}', '${episodeTitle}', 'podcast', ${episodeIndex})" id="audioBtn-${episodeIndex}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 10px 20px;">
                                <span class="play-icon">🎙️</span>
                                <span class="play-text">Play Episode</span>
                            </button>
                        ` : ''}
                        ${podcastData.duration ? `<span style="color: #667eea; font-size: 12px;">Duration: ${podcastData.duration}</span>` : ''}
                    </div>
                    
                    ${citationCount > 0 ? `
                        <div class="episode-sources" style="border-top: 1px solid #e9ecef; padding-top: 10px;">
                            <button class="article-btn" onclick="toggleEpisodeSources(${episodeIndex})" id="episodeSourcesBtn-${episodeIndex}" style="background: #e3f2fd; border-color: #2196f3; color: #1976d2; font-size: 12px; padding: 6px 12px;">
                                📚 ${citationCount} Source${citationCount === 1 ? '' : 's'}
                            </button>
                            <div id="episodeSources-${episodeIndex}" class="episode-sources-content hidden" style="margin-top: 10px;">
                                <div id="episodeSourcesContent-${episodeIndex}">Loading sources...</div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        /**
         * Toggle show episodes visibility
         */
        function toggleShowEpisodes(showName) {
            const containerId = 'episodes-' + showName.replace(/[^a-zA-Z0-9]/g, '_');
            const container = document.getElementById(containerId);
            const button = event.target;
            
            if (container.style.display === 'none') {
                container.style.display = 'block';
                button.textContent = 'Hide Episodes';
            } else {
                container.style.display = 'none';
                button.textContent = 'Show Episodes';
            }
        }

        /**
         * Toggle episode sources
         */
        function toggleEpisodeSources(episodeIndex) {
            const sourcesDiv = document.getElementById(`episodeSources-${episodeIndex}`);
            const button = document.getElementById(`episodeSourcesBtn-${episodeIndex}`);
            const contentDiv = document.getElementById(`episodeSourcesContent-${episodeIndex}`);
            
            if (sourcesDiv.classList.contains('hidden')) {
                sourcesDiv.classList.remove('hidden');
                button.textContent = button.textContent.replace(/\d+ Source/, 'Hide Source');
                
                if (contentDiv.textContent === 'Loading sources...') {
                    loadEpisodeSources(episodeIndex);
                }
            } else {
                sourcesDiv.classList.add('hidden');
                button.textContent = button.textContent.replace('Hide Source', currentRecords[episodeIndex]?.data?.basic?.citations?.length + ' Source');
            }
        }

        /**
         * Load episode sources
         */
        function loadEpisodeSources(episodeIndex) {
            const record = currentRecords[episodeIndex];
            if (!record?.data?.basic?.citations) return;
            
            const contentDiv = document.getElementById(`episodeSourcesContent-${episodeIndex}`);
            const citations = record.data.basic.citations;
            let sourcesHtml = '';
            
            citations.forEach((citation, index) => {
                if (typeof citation === 'string') {
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 8px; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; background: #f8f9fa; font-size: 11px;">
                            <div style="color: #6c757d; font-family: monospace;">DID: ${citation}</div>
                        </div>
                    `;
                } else if (citation?.data?.basic) {
                    const citationData = citation.data.basic;
                    const postData = citation.data.post || {};
                    
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 8px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: white; font-size: 12px;">
                            <div style="font-weight: 600; margin-bottom: 4px; color: #333;">
                                ${citationData.name || 'Untitled Source'}
                            </div>
                            ${citationData.description ? `
                                <div style="color: #666; margin-bottom: 6px; line-height: 1.3;">
                                    ${truncateText(citationData.description, 100)}
                                </div>
                            ` : ''}
                            ${postData.webUrl ? `
                                <div style="margin-top: 6px;">
                                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="color: #1976d2; text-decoration: none; font-size: 11px;">
                                        🔗 Read Original
                                    </a>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
            });
            
            if (sourcesHtml) {
                contentDiv.innerHTML = sourcesHtml;
            } else {
                contentDiv.innerHTML = '<div style="color: #666; font-style: italic; font-size: 12px;">No sources available</div>';
            }
        }

        /**
         * Format time from unix timestamp
         */
        function formatTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        /**
         * Create a modern, media-focused record card with collapsible technical details
         */
        function createRecordCard(record, recordIndex, isListView = false) {
            const card = document.createElement('div');
            card.className = isListView ? 'record-card list-view' : 'record-card';
            
            // Store record data for clickable elements (removed whole-card click handler)
            const didTx = record.oip?.did || record.oip?.didTx;
            
            const recordType = record.oip?.recordType || 'unknown';
            const basicData = record.data?.basic || {};
            const templatesUsed = analyzeRecordTemplates(record);
            
            // Extract media and content for modern display
            const mediaContent = extractMediaContent(record);
            const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            if (isListView) {
                // List view layout - horizontal layout with thumbnail on left
                card.innerHTML = `
                    ${renderMediaPreview(mediaContent, recordIndex, record)}
                    
                    <div class="record-content-area">
                        <div class="record-header">
                            <div class="record-type">${recordType}</div>
                            <div class="record-date">${dateDisplay}</div>
                        </div>
                        
                        ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                        
                        <div class="list-meta-row">
                            <div class="list-controls">
                                ${renderMediaControls(mediaContent, record, recordIndex)}
                                ${renderArticleTextButton(mediaContent, recordIndex)}
                                ${renderWebUrlButton(mediaContent)}
                            </div>
                            <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                🔧
                            </button>
                        </div>
                        
                        ${createTagsDisplay(basicData.tagItems)}
                        ${renderPodcastCitations(mediaContent, recordIndex)}
                    </div>
                    
                    <div id="structure-${recordIndex}" class="record-structure hidden">
                        <div class="structure-header">
                            <h4>🔧 Technical Record Structure</h4>
                            <div class="template-info">
                                <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                <strong>Record Type:</strong> ${recordType}<br>
                                <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                            </div>
                        </div>
                        ${renderAllTemplateData(record, templatesUsed)}
                    </div>
                `;
            } else {
                // Grid view layout - vertical layout (original)
                card.innerHTML = `
                    <div class="record-header">
                        <div class="record-type">${recordType}</div>
                        <div class="record-date">${dateDisplay}</div>
                    </div>
                    
                    ${renderMediaPreview(mediaContent, recordIndex, record)}
                    
                    <div class="record-content">
                        ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                        
                        ${renderMediaControls(mediaContent, record, recordIndex)}
                        ${renderArticleTextButton(mediaContent, recordIndex)}
                        ${renderWebUrlButton(mediaContent)}
                        ${renderPodcastCitations(mediaContent, recordIndex)}
                    </div>
                    
                    ${createTagsDisplay(basicData.tagItems)}
                    
                    <div class="record-footer">
                        <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                            <span class="structure-icon">🔧</span> Show Record Structure
                        </button>
                        <div class="record-did">DID: ${truncateText(record.oip?.did || record.oip?.didTx || 'Unknown', 20)}</div>
                    </div>
                    
                    <div id="structure-${recordIndex}" class="record-structure hidden">
                        <div class="structure-header">
                            <h4>🔧 Technical Record Structure</h4>
                            <div class="template-info">
                                <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                <strong>Record Type:</strong> ${recordType}<br>
                                <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                            </div>
                        </div>
                        ${renderAllTemplateData(record, templatesUsed)}
                    </div>
                `;
            }
            
            return card;
        }

        /**
         * Extract all media content from a record for modern display
         */
        function extractMediaContent(record) {
            const content = {
                featuredImage: null,
                audioItems: [],
                videoItems: [],
                articleText: null,
                webUrl: null,
                podcastData: null // Add podcast-specific data
            };
            
            const recordType = record.oip?.recordType || 'unknown';
            const recordName = record.data?.basic?.name || 'Unnamed';
            
            // Handle podcast records specifically
            if (recordType === 'podcast') {
                content.podcastData = {
                    show: record.data?.podcast?.show || 'Unknown Show',
                    duration: record.data?.podcast?.duration,
                    episodeAudio: record.data?.audio?.webUrl || null,
                    episodeTitle: record.data?.basic?.name || 'Untitled Episode',
                    episodeDescription: record.data?.basic?.description || '',
                    citations: record.data?.basic?.citations || [],
                    date: record.data?.basic?.dateReadable || formatDate(record.data?.basic?.date) || 'Unknown Date'
                };
                
                // Add the main podcast audio as an audio item
                if (record.data?.audio?.webUrl) {
                    content.audioItems.push({
                        url: record.data.audio.webUrl,
                        title: content.podcastData.episodeTitle,
                        contentType: record.data.audio.contentType || 'audio/mp3'
                    });
                }
                
                // Set show artwork as featured image for "The Light of Inquiry"
                if (content.podcastData.show === 'The Light of Inquiry') {
                    content.featuredImage = {
                        url: 'TheLightOfInquiry-v2.png',
                        title: 'The Light of Inquiry',
                        contentType: 'image/png'
                    };
                }
            }
            
            // Extract from all data sections
            if (record.data) {
                Object.keys(record.data).forEach(sectionName => {
                    if (sectionName === 'basic') return;
                    
                    const section = record.data[sectionName];
                    extractMediaFromSection(section, content, sectionName, record);
                });
            }
            
            // Fallback: If no featured image found, search more aggressively
            if (!content.featuredImage && record.data) {
                console.log(`[Media Detection] No image found in primary extraction for ${recordType}: "${recordName}". Trying fallback search...`);
                const fallbackResult = findFirstImageInRecord(record);
                
                if (fallbackResult) {
                    if (fallbackResult.type === 'unresolved_dref') {
                        console.log(`[Media Detection] ⚠️ Found unresolved image dref for "${recordName}". Increase resolve depth to see images.`);
                        content.unresolvedImageDref = fallbackResult.dref;
                    } else {
                        content.featuredImage = fallbackResult;
                        console.log(`[Media Detection] ✅ Fallback found image for "${recordName}": ${content.featuredImage.url}`);
                    }
                } else {
                    console.log(`[Media Detection] ❌ No image found for "${recordName}" even after fallback search`);
                }
            } else if (content.featuredImage) {
                console.log(`[Media Detection] ✅ Primary extraction found image for "${recordName}": ${content.featuredImage.url}`);
            }
            
            return content;
        }

        /**
         * Aggressively search for any image URL in a record (fallback method)
         */
        function findFirstImageInRecord(record) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const basicData = record.data?.basic || {};
            
            // Priority order for field names (most likely to be main images first)
            const priorityFields = ['image', 'photo', 'picture', 'thumbnail', 'featured', 'cover', 'avatar', 'img', 'imageurl', 'photourl'];
            
            // First pass: Look for priority fields
            for (const priorityField of priorityFields) {
                const result = searchForImageInSection(record.data, priorityField);
                if (result) {
                    console.log(`[Media Detection] Found priority image in field containing "${priorityField}": ${result}`);
                    return {
                        url: result,
                        title: basicData.name || 'Image',
                        contentType: 'image/jpeg'
                    };
                }
            }
            
            // Second pass: Search all fields recursively
            const anyImageUrl = searchForImageUrl(record.data);
            if (anyImageUrl) {
                console.log(`[Media Detection] Found image URL in fallback search: ${anyImageUrl}`);
                return {
                    url: anyImageUrl,
                    title: basicData.name || 'Image',
                    contentType: 'image/jpeg'
                };
            }
            
            // Third pass: Look for unresolved image drefs
            const unresolvedImageDref = searchForUnresolvedImageDref(record.data);
            if (unresolvedImageDref) {
                console.log(`[Media Detection] Found unresolved image dref: ${unresolvedImageDref}`);
                return {
                    type: 'unresolved_dref',
                    dref: unresolvedImageDref
                };
            }
            
            return null;
            
            // Helper function to search for images in fields with priority names
            function searchForImageInSection(obj, priorityField, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl && path.toLowerCase().includes(priorityField.toLowerCase())) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageInSection(value, priorityField, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageInSection(obj[i], priorityField, `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function for general image URL search
            function searchForImageUrl(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageUrl(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageUrl(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function to search for unresolved image drefs
            function searchForUnresolvedImageDref(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('did:arweave:')) {
                    // Check if the field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => path.toLowerCase().includes(name.toLowerCase()));
                    
                    if (isImageField) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForUnresolvedImageDref(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForUnresolvedImageDref(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
        }

        /**
         * Extract media from a specific data section
         */
        function extractMediaFromSection(section, content, sectionName, record = null) {
            if (!section || typeof section !== 'object') return;
            
            // Get basic data for image titles
            const basicData = record?.data?.basic || {};
            
            // Handle direct media records (image, video, audio record types)
            if (sectionName === 'image' && section.webUrl && !content.featuredImage) {
                content.featuredImage = {
                    url: section.webUrl,
                    title: basicData?.name || 'Image',
                    contentType: section.contentType || 'image/jpeg'
                };
                console.log(`[Media Detection] ✅ Found direct image record: ${section.webUrl}`);
                return; // Early return since we found what we need
            } else if (sectionName === 'video' && section.webUrl) {
                content.videoItems.push({
                    url: section.webUrl,
                    title: basicData?.name || 'Video',
                    contentType: section.contentType || 'video/mp4'
                });
                console.log(`[Media Detection] ✅ Found direct video record: ${section.webUrl}`);
                return; // Early return since we found what we need
            } else if (sectionName === 'audio' && section.webUrl) {
                content.audioItems.push({
                    url: section.webUrl,
                    title: basicData?.name || 'Audio',
                    contentType: section.contentType || 'audio/mpeg'
                });
                console.log(`[Media Detection] ✅ Found direct audio record: ${section.webUrl}`);
                return; // Early return since we found what we need
            }
            
            Object.keys(section).forEach(fieldName => {
                const value = section[fieldName];
                
                // Handle resolved drefs
                if (value && typeof value === 'object' && value.data && value.oip) {
                    const embedType = value.oip.recordType;
                    const embedData = value.data[embedType];
                    
                    if (embedType === 'image' && embedData?.webUrl) {
                        if (!content.featuredImage) {
                            content.featuredImage = {
                                url: embedData.webUrl,
                                title: value.data.basic?.name || 'Image',
                                contentType: embedData.contentType
                            };
                            console.log(`[Media Detection] ✅ Found resolved image dref at ${sectionName}.${fieldName}: ${embedData.webUrl}`);
                        }
                    } else if (embedType === 'audio' && embedData?.webUrl) {
                        content.audioItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Audio',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'video' && embedData?.webUrl) {
                        content.videoItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Video',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'text' && embedData?.webUrl && fieldName === 'articleText') {
                        content.articleText = {
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Article Text',
                            contentType: embedData.contentType
                        };
                    }
                }
                
                // Handle arrays of resolved drefs
                else if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                    value.forEach(item => {
                        const embedType = item.oip.recordType;
                        const embedData = item.data[embedType];
                        
                        if (embedType === 'audio' && embedData?.webUrl) {
                            content.audioItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Audio',
                                contentType: embedData.contentType
                            });
                        } else if (embedType === 'video' && embedData?.webUrl) {
                            content.videoItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Video',
                                contentType: embedData.contentType
                            });
                        }
                    });
                }
                
                // Handle direct URLs
                else if (fieldName === 'webUrl' && typeof value === 'string') {
                    content.webUrl = value;
                }
                
                // Enhanced image URL detection for recipes and other records
                else if (typeof value === 'string' && value.startsWith('http')) {
                    // Check if it's an image URL by extension
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    // Check if field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => fieldName.toLowerCase().includes(name));
                    
                                         // For recipes, be even more permissive - any URL ending in image extension
                     const isRecipeContext = sectionName === 'recipe' || sectionName === 'food';
                     
                     // Additional recipe-specific field names
                     const recipeImageFields = ['photo', 'picture', 'img', 'imageurl', 'photourl', 'pictureurl'];
                     const isRecipeImageField = recipeImageFields.some(name => fieldName.toLowerCase().includes(name));
                    
                                                              if ((isImageUrl && (isImageField || isRecipeImageField || isRecipeContext)) || 
                         ((isImageField || isRecipeImageField) && isImageUrl)) {
                        if (!content.featuredImage) content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    }
                }
                
                // Handle webUrl fields that point to images (common in recipes)
                else if (fieldName === 'webUrl' && typeof value === 'string' && value.startsWith('http')) {
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    if (isImageUrl && !content.featuredImage) {
                        content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    } else {
                        content.webUrl = value;
                    }
                }
            });
        }

        /**
         * Render media preview (featured image or video thumbnail)
         */
        function renderMediaPreview(mediaContent, recordIndex, record = null) {
            const didTx = record?.oip?.didTx;
            const recordViewClick = didTx ? `onclick="showRecordView('${didTx}', currentRecords[${recordIndex}]); event.stopPropagation();"` : '';
            const clickableStyle = didTx ? 'cursor: pointer;' : '';
            // Handle podcast records with specialized interface
            if (mediaContent.podcastData) {
                const podcast = mediaContent.podcastData;
                const showArtwork = mediaContent.featuredImage?.url || 'icons/noun-microphone-7907572.svg';
                
                return `
                    <div class="media-preview podcast-preview" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); ${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="podcast-artwork" style="position: relative; height: 100%; display: flex; align-items: center; justify-content: center;">
                            <img src="${showArtwork}" 
                                 alt="${podcast.show}"
                                 class="preview-image"
                                 style="max-height: 80%; max-width: 80%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div class="podcast-icon" style="display: none; font-size: 48px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">🎙️</div>
                            
                            <div class="play-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4); opacity: 0; transition: opacity 0.2s;">
                                <div class="play-button" style="width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.9); display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">▶️</div>
                            </div>
                        </div>
                        <div class="media-badge" style="background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);">🎙️ Podcast</div>
                    </div>
                `;
            }
            // Priority: Video thumbnail > Featured Image > First Video > Placeholder
            else if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                return `
                    <div class="media-preview video-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <video class="preview-video" poster="" onclick="event.stopPropagation(); playVideoFullscreen('${video.url}', '${video.title}')">
                            <source src="${video.url}" type="${video.contentType || 'video/mp4'}">
                        </video>
                        <div class="play-overlay" onclick="event.stopPropagation(); playVideoFullscreen('${video.url}', '${video.title}')">
                            <div class="play-button">▶️</div>
                        </div>
                        <div class="media-badge">📹 Video</div>
                    </div>
                `;
            } else if (mediaContent.featuredImage) {
                return `
                    <div class="media-preview image-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <img src="${mediaContent.featuredImage.url}" 
                             alt="${mediaContent.featuredImage.title}"
                             class="preview-image"
                             onerror="this.parentElement.innerHTML='<div class=\\"preview-placeholder\\">🖼️ Image</div>'">
                        <div class="media-badge">📷 Image</div>
                    </div>
                `;
            } else if (mediaContent.audioItems.length > 0) {
                return `
                    <div class="media-preview audio-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="audio-artwork">
                            <div class="audio-icon">🎵</div>
                            <div class="audio-visualizer">
                                <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
                            </div>
                        </div>
                        <div class="media-badge">🎵 Audio</div>
                    </div>
                `;
            } else if (mediaContent.unresolvedImageDref) {
                return `
                    <div class="media-preview placeholder-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="preview-placeholder resolve-hint">
                            🖼️ Image<br>
                            <small style="font-size: 0.7rem; opacity: 0.8;">Increase Resolve Depth to see image</small>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="media-preview placeholder-preview" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">
                        <div class="preview-placeholder">📄 Text</div>
                    </div>
                `;
            }
        }

        /**
         * Render record title and description with podcast-specific formatting
         */
        function renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex = null, record = null) {
            const didTx = record?.oip?.didTx;
            const recordViewClick = didTx ? `onclick="showRecordView('${didTx}', currentRecords[${recordIndex}]); event.stopPropagation();"` : '';
            const clickableStyle = didTx ? 'cursor: pointer;' : '';
            if (mediaContent.podcastData) {
                const podcast = mediaContent.podcastData;
                return `
                    <div class="podcast-info">
                        <div class="podcast-show" style="color: #667eea; font-weight: 600; font-size: 14px; margin-bottom: 5px;">
                            🎙️ ${podcast.show}
                        </div>
                        <h3 class="record-title" style="margin-bottom: 8px; ${clickableStyle}" ${recordViewClick} title="Click to view full record">${podcast.episodeTitle}</h3>
                        <div class="podcast-date" style="color: #6c757d; font-size: 12px; margin-bottom: 10px;">
                            📅 ${podcast.date}
                        </div>
                        ${podcast.episodeDescription ? `<p class="record-description" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${truncateText(podcast.episodeDescription, 200)}</p>` : ''}
                    </div>
                `;
            } else {
                return `
                    <h3 class="record-title" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${basicData.name || 'Unnamed Record'}</h3>
                    ${basicData.description ? `<p class="record-description" style="${clickableStyle}" ${recordViewClick} title="Click to view full record">${truncateText(basicData.description, 150)}</p>` : ''}
                `;
            }
        }

        /**
         * Render media controls (play buttons, etc.)
         */
        function renderMediaControls(mediaContent, record, recordIndex) {
            let controls = '';
            
            // Podcast controls (specialized for podcast episodes)
            if (mediaContent.podcastData && mediaContent.audioItems.length > 0) {
                const podcast = mediaContent.podcastData;
                const audio = mediaContent.audioItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn primary" onclick="playAudioInMaster('${audio.url}', '${podcast.episodeTitle}', 'podcast', ${recordIndex})" id="audioBtn-${recordIndex}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 12px 24px;">
                            <span class="play-icon">🎙️</span>
                            <span class="play-text">Play Episode</span>
                        </button>
                        ${podcast.duration ? `<span class="media-count" style="color: #667eea;">Duration: ${podcast.duration}</span>` : ''}
                    </div>
                `;
            }
            // Audio controls (for non-podcast audio)
            else if (mediaContent.audioItems.length > 0) {
                const audio = mediaContent.audioItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn primary" onclick="playAudioInMaster('${audio.url}', '${audio.title}', '${record.oip?.recordType || 'audio'}', ${recordIndex})" id="audioBtn-${recordIndex}">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Audio</span>
                        </button>
                        ${mediaContent.audioItems.length > 1 ? `<span class="media-count">+${mediaContent.audioItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            // Video controls  
            if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn secondary" onclick="playVideoFullscreen('${video.url}', '${video.title}')">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Video</span>
                        </button>
                        ${mediaContent.videoItems.length > 1 ? `<span class="media-count">+${mediaContent.videoItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            return controls;
        }

        /**
         * Render podcast citations and sources
         */
        function renderPodcastCitations(mediaContent, recordIndex) {
            if (!mediaContent.podcastData || !mediaContent.podcastData.citations || mediaContent.podcastData.citations.length === 0) {
                return '';
            }
            
            const citations = mediaContent.podcastData.citations;
            const citationCount = Array.isArray(citations) ? citations.length : (typeof citations === 'object' ? Object.keys(citations).length : 0);
            
            if (citationCount === 0) return '';
            
            return `
                <div class="podcast-citations" style="margin-top: 15px;">
                    <button class="article-btn" onclick="togglePodcastSources(${recordIndex})" id="sourcesBtn-${recordIndex}" style="background: #e3f2fd; border-color: #2196f3; color: #1976d2;">
                        📚 Show ${citationCount} Source${citationCount === 1 ? '' : 's'}
                    </button>
                    <div id="podcastSources-${recordIndex}" class="podcast-sources hidden" style="margin-top: 15px; border: 1px solid #e9ecef; border-radius: 8px; background: #f8f9fa; padding: 15px;">
                        <div style="font-weight: bold; margin-bottom: 10px; color: #495057;">📚 Episode Sources & Citations</div>
                        <div id="sourcesContent-${recordIndex}">Loading sources...</div>
                    </div>
                </div>
            `;
        }

        /**
         * Toggle podcast sources display
         */
        function togglePodcastSources(recordIndex) {
            const sourcesDiv = document.getElementById(`podcastSources-${recordIndex}`);
            const button = document.getElementById(`sourcesBtn-${recordIndex}`);
            const contentDiv = document.getElementById(`sourcesContent-${recordIndex}`);
            
            if (sourcesDiv.classList.contains('hidden')) {
                sourcesDiv.classList.remove('hidden');
                button.textContent = button.textContent.replace('Show', 'Hide');
                
                // Load sources if not already loaded
                if (contentDiv.textContent === 'Loading sources...') {
                    loadPodcastSources(recordIndex);
                }
            } else {
                sourcesDiv.classList.add('hidden');
                button.textContent = button.textContent.replace('Hide', 'Show');
            }
        }

        /**
         * Load and display podcast sources
         */
        function loadPodcastSources(recordIndex) {
            const record = currentRecords[recordIndex];
            if (!record?.data?.basic?.citations) return;
            
            const contentDiv = document.getElementById(`sourcesContent-${recordIndex}`);
            const citations = record.data.basic.citations;
            let sourcesHtml = '';
            
            citations.forEach((citation, index) => {
                if (typeof citation === 'string') {
                    // Simple DID reference
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 10px; padding: 10px; border: 1px solid #dee2e6; border-radius: 6px; background: white;">
                            <div style="font-size: 12px; color: #6c757d; font-family: monospace;">DID: ${citation}</div>
                        </div>
                    `;
                } else if (citation?.data?.basic) {
                    // Resolved citation with post data
                    const citationData = citation.data.basic;
                    const postData = citation.data.post || {};
                    
                    sourcesHtml += `
                        <div class="source-item" style="margin-bottom: 10px; padding: 12px; border: 1px solid #dee2e6; border-radius: 6px; background: white;">
                            <div style="font-weight: 600; margin-bottom: 5px; color: #333;">
                                ${citationData.name || 'Untitled Source'}
                            </div>
                            ${citationData.description ? `
                                <div style="font-size: 13px; color: #666; margin-bottom: 8px; line-height: 1.4;">
                                    ${truncateText(citationData.description, 120)}
                                </div>
                            ` : ''}
                            ${postData.webUrl ? `
                                <div style="margin-top: 8px;">
                                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="color: #1976d2; text-decoration: none; font-size: 12px;">
                                        🔗 Read Original Article
                                    </a>
                                </div>
                            ` : ''}
                            <div style="font-size: 11px; color: #999; margin-top: 5px;">
                                DID: ${citation.oip?.did || citation.oip?.didTx || 'Unknown'}
                            </div>
                        </div>
                    `;
                }
            });
            
            if (sourcesHtml) {
                contentDiv.innerHTML = sourcesHtml;
            } else {
                contentDiv.innerHTML = '<div style="color: #666; font-style: italic;">No sources available</div>';
            }
        }

        /**
         * Render article text button for posts
         */
        function renderArticleTextButton(mediaContent, recordIndex) {
            if (mediaContent.articleText) {
                return `
                    <div class="article-controls">
                        <button class="article-btn" onclick="loadArticleText('${mediaContent.articleText.url}', ${recordIndex})">
                            📄 Full Article Text
                        </button>
                        <div id="articleText-${recordIndex}" class="article-content hidden">
                            <div class="article-loading">Loading article...</div>
                        </div>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Render web URL button (skip for podcast records)
         */
        function renderWebUrlButton(mediaContent) {
            if (mediaContent.webUrl && !mediaContent.podcastData) {
                return `
                    <div class="web-controls">
                        <a href="${mediaContent.webUrl}" target="_blank" rel="noopener noreferrer" class="web-btn">
                            🌐 View Original
                        </a>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Toggle record structure visibility
         */
        function toggleRecordStructure(recordIndex) {
            const structure = document.getElementById(`structure-${recordIndex}`);
            const button = structure.previousElementSibling.querySelector('.show-structure-btn');
            
            if (structure.classList.contains('hidden')) {
                structure.classList.remove('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Hide Record Structure';
            } else {
                structure.classList.add('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Show Record Structure';
            }
        }

        /**
         * Load article text content
         */
        async function loadArticleText(url, recordIndex) {
            const container = document.getElementById(`articleText-${recordIndex}`);
            const button = container.previousElementSibling;
            
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                button.textContent = '📄 Full Article Text';
                return;
            }
            
            try {
                button.textContent = '📄 Loading...';
                button.disabled = true;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                
                container.innerHTML = `
                    <div class="article-header">
                        <h4>📄 Full Article Text</h4>
                        <button onclick="toggleRecordStructure(${recordIndex}); document.getElementById('articleText-${recordIndex}').classList.add('hidden'); document.querySelector('[onclick*=\\"loadArticleText\\"]').textContent='📄 Full Article Text'; document.querySelector('[onclick*=\\"loadArticleText\\"]').disabled=false;" class="close-btn">✕</button>
                    </div>
                    <div class="article-text">${escapeHtml(text)}</div>
                `;
                container.classList.remove('hidden');
                button.textContent = '📄 Hide Article Text';
                
            } catch (error) {
                container.innerHTML = `<div class="article-error">Error loading article: ${error.message}</div>`;
                container.classList.remove('hidden');
                button.textContent = '❌ Failed to Load';
            } finally {
                button.disabled = false;
            }
        }

        /**
         * Play video in fullscreen modal
         */
        function playVideoFullscreen(url, title) {
            // Create simple video modal
            const modal = document.createElement('div');
            modal.className = 'video-modal';
            modal.innerHTML = `
                <div class="video-modal-content">
                    <div class="video-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.video-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <video controls autoplay style="width: 100%; max-height: 70vh;">
                        <source src="${url}">
                        Your browser doesn't support video playback.
                    </video>
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Open image in modal
         */
        function openImageModal(url, title) {
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="image-modal-content">
                    <div class="image-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.image-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <img src="${url}" alt="${escapeHtml(title)}" style="max-width: 100%; max-height: 80vh;">
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Render basic information section
         */
        function renderBasicInfo(basicData) {
            let html = '';
            
            if (basicData.description) {
                html += `<div class="record-content">${truncateText(basicData.description, 200)}</div>`;
            }
            
            return html;
        }

        /**
         * Dynamically render all template data sections
         */
        function renderAllTemplateData(record, templatesUsed) {
            let html = '';
            
            if (!record.data) return html;
            
            Object.keys(record.data).forEach(templateName => {
                if (templateName === 'basic') return; // Skip basic - handled separately
                
                const templateData = record.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `data.${templateName}`);
            });
            
            return html ? `<div class="media-content">${html}</div>` : '';
        }

        /**
         * Render data for a specific template section
         */
        function renderTemplateSectionData(templateName, data, path = '') {
            if (!data || typeof data !== 'object') return '';
            
            let html = '';
            const fieldsMap = templateFieldMap[templateName];
            
            if (showDebugInfo && fieldsMap) {
                html += `<div class="field-debug">Template: ${templateName}, Fields: ${Object.keys(fieldsMap).length}</div>`;
            }
            
            Object.keys(data).forEach(fieldName => {
                const value = data[fieldName];
                const fieldDef = getFieldDefinition(templateName, fieldName);
                const fieldPath = path ? `${path}.${fieldName}` : fieldName;
                
                html += renderFieldByType(templateName, fieldName, value, fieldDef, fieldPath);
            });
            
            return html;
        }

        /**
         * Render a field based on its type definition
         */
        function renderFieldByType(templateName, fieldName, value, fieldDef, path) {
            if (!value) return '';
            
            let html = '';
            const mediaType = getMediaType(templateName, fieldName, value);
            
            // Debug info
            if (showDebugInfo) {
                const typeInfo = fieldDef ? `${fieldDef.type} (${fieldDef.index})` : 'unknown type';
                html += `<div class="field-debug">Field: ${fieldName} <span class="field-type-indicator">${typeInfo}</span></div>`;
            }
            
            // Handle resolved drefs (embedded records)
            if (value && typeof value === 'object' && value.data && value.oip) {
                return renderResolvedDref(fieldName, value, path);
            }
            
            // Handle arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                return renderResolvedDrefArray(fieldName, value, path);
            }
            
            // Handle direct media URLs based on detected type
            if (mediaType) {
                return renderMediaField(fieldName, value, mediaType);
            }
            
            // Handle simple web URLs
            if (fieldName === 'webUrl' && typeof value === 'string') {
                html += `<div class="media-item">
                    <a href="${value}" target="_blank" rel="noopener noreferrer" 
                       style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Visit ${fieldName}
                    </a>
                </div>`;
            }
            
            // Handle unresolved drefs
            if (isDrefField(fieldDef, value)) {
                html += renderUnresolvedDref(fieldName, value);
            }
            
            return html;
        }

        /**
         * Render resolved dref (embedded record)
         */
        function renderResolvedDref(fieldName, resolvedRecord, path) {
            const embedTemplates = Object.keys(resolvedRecord.data).filter(k => k !== 'basic');
            const recordType = resolvedRecord.oip?.recordType || embedTemplates[0] || 'unknown';
            
            let html = `<div class="dref-resolved">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                    📎 ${fieldName} (${recordType}):
                </label>`;
            
            // Render basic info from embedded record
            if (resolvedRecord.data.basic) {
                const basicData = resolvedRecord.data.basic;
                if (basicData.name) {
                    html += `<div style="font-weight: 500; margin-bottom: 5px;">${basicData.name}</div>`;
                }
                if (basicData.description) {
                    html += `<div style="font-size: 13px; color: #666; margin-bottom: 8px;">${truncateText(basicData.description, 100)}</div>`;
                }
            }
            
            // Render each template section in the embedded record
            embedTemplates.forEach(templateName => {
                const templateData = resolvedRecord.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `${path}.data.${templateName}`);
            });
            
            if (showDebugInfo) {
                html += `<div class="field-debug">Resolved: ${resolvedRecord.oip?.did || resolvedRecord.oip?.didTx}</div>`;
            }
            
            html += '</div>';
            return html;
        }

        /**
         * Render array of resolved drefs
         */
        function renderResolvedDrefArray(fieldName, resolvedArray, path) {
            let html = `<div style="margin: 10px 0;">
                <label style="font-weight: bold; display: block; margin-bottom: 5px;">
                    📎 ${fieldName} (${resolvedArray.length} items):
                </label>`;
            
            resolvedArray.forEach((resolvedRecord, index) => {
                html += renderResolvedDref(`${fieldName}[${index}]`, resolvedRecord, `${path}[${index}]`);
            });
            
            html += '</div>';
            return html;
        }

        /**
         * Render media field based on detected type
         */
        function renderMediaField(fieldName, value, mediaType) {
            const webUrl = value.webUrl || value;
            if (!webUrl) return '';
            
            switch (mediaType) {
                case 'image':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <img src="${webUrl}" alt="${fieldName}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 5px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <audio controls style="width: 100%; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'audio/mpeg'}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <video controls style="width: 100%; max-height: 300px; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'video/mp4'}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <div class="text-preview" style="margin: 5px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }

        /**
         * Render unresolved dref
         */
        function renderUnresolvedDref(fieldName, value) {
            const didValue = Array.isArray(value) ? value[0] : value;
            if (!didValue || !didValue.startsWith('did:arweave:')) return '';
            
            return `<div class="media-item">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName} (unresolved):</label>
                <div class="unresolved-dref">
                    📋 ${didValue}
                    <br><em>Increase resolve depth to see content</em>
                </div>
            </div>`;
        }

        function getRecordType(record) {
            // First, check the authoritative source: oip.recordType
            if (record.oip && record.oip.recordType) {
                return record.oip.recordType;
            }
            
            // Fallback: Try to get from data structure
            if (record.data) {
                const keys = Object.keys(record.data);
                for (const key of keys) {
                    if (key !== 'basic' && typeof record.data[key] === 'object') {
                        return key;
                    }
                }
            }
            
            return 'unknown';
        }

        function getContentPreview(data) {
            if (!data) return '';
            
            // Try common content fields
            if (data.content) return truncateText(data.content, 150);
            if (data.articleText) return truncateText(data.articleText, 150);
            if (data.description) return truncateText(data.description, 150);
            
            return '';
        }

        function createTagsDisplay(tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) return '';
            
            const tagsHtml = tags.slice(0, 5).map(tag => 
                `<span class="tag-chip" onclick="filterByTag('${escapeHtml(tag)}')" title="Filter by ${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
            ).join('');
            
            return `<div class="tags-container">${tagsHtml}</div>`;
        }



        // ========================================================================
        // ENHANCED DYNAMIC TEMPLATE SYSTEM
        // ========================================================================
        // 
        // This system dynamically renders OIP records based on their actual 
        // template definitions from the /api/templates endpoint, eliminating 
        // the need for hardcoded field names and types.
        //
        // Key Features:
        // - Loads all templates and builds field type mappings at startup
        // - Analyzes records to identify all templates used (including nested DREFs)
        // - Renders fields based on their actual template type definitions
        // - Handles resolved and unresolved DREF fields automatically
        // - Supports unlimited nesting depth with resolveDepth parameter
        // - Includes debug mode to show template analysis information
        // - Works with any new templates/fields without code changes
        //
        // Usage: Enable "Debug Templates" checkbox to see template analysis
        // Test: Run testTemplateSystem() in browser console to verify functionality
        // ========================================================================
        
        /**
         * Load all templates and build enhanced field mapping
         */
        async function loadTemplates() {
            try {
                console.log('[Templates] Loading all templates with enhanced mapping...');
                const response = await fetch('/api/templates?limit=1000');
                const data = await response.json();
                
                if (data.templates) {
                    // Clear existing mappings
                    templates = {};
                    allTemplates = {};
                    templateFieldMap = {};
                    
                    data.templates.forEach(template => {
                        const templateName = template.data.template || template.data.recordType || 'unknown';
                        const templateTxId = template.oip.did || template.oip.didTx;
                        const recordType = template.data.recordType || template.data.template || 'unknown';
                        
                        // Store in legacy format for compatibility
                        if (!templates[recordType]) {
                            templates[recordType] = [];
                        }
                        templates[recordType].push(template);
                        
                        // Store in enhanced format by name and TxId
                        allTemplates[templateName] = template;
                        allTemplates[templateTxId] = template;
                        
                        // Build field mapping for this template
                        if (template.data.fieldsInTemplate) {
                            templateFieldMap[templateName] = template.data.fieldsInTemplate;
                            templateFieldMap[templateTxId] = template.data.fieldsInTemplate;
                            
                            if (showDebugInfo) {
                                console.log(`[Templates] Mapped fields for ${templateName}:`, template.data.fieldsInTemplate);
                            }
                        }
                    });
                    
                    // Note: Default templates are defined in config/templates.config.js on the server

                    // defaultTemplates = {
                    //     basic: "did:arweave:-9DirnjVO1FlbEW1lN8jITBESrTsQKEM_BoZ1ey_0mk",
                    //     creatorRegistration: "did:arweave:BKVvTSXmmJni-L82irZfPFXWWJLBcdvbxS34jP1FTG8",
                    //     associatedUrlOnWeb: "did:arweave:_RJtiNMr1Ls9NG3G9-6rvbI5Sn0ccSnRTnrQCZi3ABE",
                    //     text: "did:arweave:of_eh0kGy65uYD0xsTh7Qe6JVTfJ2oFoA7xp4H7t7YI",
                    //     image: "did:arweave:AkZnE1VckJJlRamgNJuIGE7KrYwDcCciWOMrMh68V4o",
                    //     audio: "did:arweave:9MrI8kJvBJ-u7uvgngMZ-gMo5RREDwey8G7mJEUOpdo",
                    //     video: "did:arweave:G73WplyxpNDOgDSFO6CP3O6hZXq8kNJXxkCqx3sgd1s",
                    //     post: "did:arweave:op6y-d_6bqivJ2a2oWQnbylD4X_LH6eQyR6rCGqtVZ8",
                    //     recipe: "did:arweave:46Ui_ifw5LnrRmf_o2zWwikNxgXsXk3sswPtbcJCzlc",
                    //     workout: "did:arweave:T_16JOpyRKt0dmuZikHPpDcIhwh4DR1ZspHU4BKa-qE"
                    // };
                    
                    console.log(`[Templates] Loaded ${Object.keys(allTemplates).length / 2} templates`);
                    console.log(`[Templates] Field mappings for:`, Object.keys(templateFieldMap));
                }
            } catch (error) {
                console.error('[Templates] Error loading templates:', error);
            }
        }

        /**
         * Analyze a record to find all templates used (including nested drefs)
         */
        function analyzeRecordTemplates(record) {
            const templatesFound = new Set();
            
            function analyzeDataSection(data, path = '') {
                if (!data || typeof data !== 'object') return;
                
                Object.keys(data).forEach(key => {
                    if (key === 'basic' || key === 'oip') return; // Skip these
                    
                    const value = data[key];
                    const currentPath = path ? `${path}.${key}` : key;
                    
                    // This is a template section (e.g., 'post', 'image', etc.)
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        // Check if this looks like a template data section
                        if (value.webUrl || value.contentType || Object.keys(value).some(k => !k.startsWith('_'))) {
                            templatesFound.add(key);
                            if (showDebugInfo) {
                                console.log(`[Templates] Found template section: ${key} at ${currentPath}`);
                            }
                        }
                        
                        // Recursively analyze nested objects
                        analyzeDataSection(value, currentPath);
                    } else if (Array.isArray(value)) {
                        // Analyze array items (might be dref resolved objects)
                        value.forEach((item, index) => {
                            if (item && typeof item === 'object' && item.data) {
                                if (showDebugInfo) {
                                    console.log(`[Templates] Found resolved dref in array at ${currentPath}[${index}]`);
                                }
                                analyzeDataSection(item.data, `${currentPath}[${index}].data`);
                            }
                        });
                    } else if (typeof value === 'object' && value !== null && value.data) {
                        // This is a resolved dref
                        if (showDebugInfo) {
                            console.log(`[Templates] Found resolved dref at ${currentPath}`);
                        }
                        analyzeDataSection(value.data, `${currentPath}.data`);
                    }
                });
            }
            
            // Analyze the main data section
            if (record.data) {
                analyzeDataSection(record.data);
            }
            
            // Always include the main record type
            if (record.oip && record.oip.recordType) {
                templatesFound.add(record.oip.recordType);
            }
            
            return Array.from(templatesFound);
        }

        /**
         * Get field definition for a specific field in a template
         */
        function getFieldDefinition(templateName, fieldName) {
            const fieldsMap = templateFieldMap[templateName];
            if (!fieldsMap) return null;
            
            return fieldsMap[fieldName] || null;
        }

        /**
         * Determine if a field is a DREF based on its type and content
         */
        function isDrefField(fieldDef, value) {
            if (!fieldDef) return false;
            
            // Check type definition
            if (fieldDef.type === 'dref' || fieldDef.type === 'repeated dref') {
                return true;
            }
            
            // Check value pattern (did:arweave:...)
            if (typeof value === 'string' && value.startsWith('did:arweave:')) {
                return true;
            }
            
            // Check if it's an array of DIDs
            if (Array.isArray(value) && value.length > 0 && 
                typeof value[0] === 'string' && value[0].startsWith('did:arweave:')) {
                return true;
            }
            
            return false;
        }

        /**
         * Determine media type from field definition and content
         */
        function getMediaType(templateName, fieldName, value) {
            const fieldDef = getFieldDefinition(templateName, fieldName);
            
            // If it's a resolved dref, look at the embedded data
            if (value && typeof value === 'object' && value.data) {
                const embedTemplates = Object.keys(value.data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0]; // Return the template type (image, audio, video, text, etc.)
                }
            }
            
            // Check for arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data) {
                const embedTemplates = Object.keys(value[0].data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0];
                }
            }
            
            // Check field name patterns
            if (fieldName.toLowerCase().includes('image')) return 'image';
            if (fieldName.toLowerCase().includes('audio')) return 'audio';
            if (fieldName.toLowerCase().includes('video')) return 'video';
            if (fieldName.toLowerCase().includes('text')) return 'text';
            
            // Check content patterns
            if (value && typeof value === 'object') {
                if (value.webUrl) {
                    if (value.contentType) {
                        if (value.contentType.startsWith('image/')) return 'image';
                        if (value.contentType.startsWith('audio/')) return 'audio';
                        if (value.contentType.startsWith('video/')) return 'video';
                        if (value.contentType.startsWith('text/')) return 'text';
                    }
                }
            }
            
            return null;
        }

        async function loadRecordTypes() {
            try {
                const base = (typeof window !== 'undefined' && window.API_BASE_URL) ? window.API_BASE_URL : '';
                const response = await fetch(`${base}/api/templates?limit=25&page=1`);
                const data = await response.json();
                
                if (data.templates) {
                    const typeSet = new Set();
                    data.templates.forEach(template => {
                        if (template.data?.template) {
                            typeSet.add(template.data.template);
                        }
                    });
                    
                    recordTypes = Array.from(typeSet).sort();
                    populateRecordTypeFilter();
                }
            } catch (error) {
                console.error('Error loading record types:', error);
            }
        }

        function populateRecordTypeFilter() {
            // Populate voice record type filter (Browse + AI Chat tab)
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                
                recordTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    voiceSelect.appendChild(option);
                });
            }
        }

        // Utility functions
        function truncateText(text, length) {
            if (!text) return '';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function dateToUnixTime(dateString) {
            if (!dateString) return '';
            return Math.floor(new Date(dateString).getTime() / 1000).toString();
        }



        function setupInfiniteScroll() {
            window.addEventListener('scroll', () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
                    loadMoreRecords();
                }
            });
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = type === 'error' ? 'error-message' : 'success-message';
            element.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => element.classList.add('hidden'), 3000);
            }
        }

        function hideElement(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        // Publishing navigation functions
        function hideAllPublishingSections() {
            const creatorSection = document.getElementById('creator-section');
            const templateSection = document.getElementById('template-section');
            const recordSection = document.getElementById('record-section');
            
            if (creatorSection) creatorSection.classList.add('hidden');
            if (templateSection) templateSection.classList.add('hidden');
            if (recordSection) recordSection.classList.add('hidden');
        }

        function showCreatorRegistration() {
            hideAllPublishingSections();
            document.getElementById('creator-section').classList.remove('hidden');
        }

        function showTemplateCreation() {
            hideAllPublishingSections();
            document.getElementById('template-section').classList.remove('hidden');
        }

        function showRecordPublishing() {
            hideAllPublishingSections();
            document.getElementById('record-section').classList.remove('hidden');
        }

        // Creator registration
        async function registerCreator() {
            const name = document.getElementById('creator-name').value;
            const description = document.getElementById('creator-description').value;
            const email = document.getElementById('creator-email').value;
            const website = document.getElementById('creator-website').value;

            if (!name) {
                showMessage('creator-status', 'Please enter a creator name', 'error');
                return;
            }

            const creatorData = {
                basic: {
                    name: name,
                    description: description,
                    language: 'en',
                    date: Math.floor(Date.now() / 1000),
                    nsfw: false
                },
                creatorRegistration: {
                    email: email || currentUser,
                    website: website,
                    verified: false
                }
            };

            try {
                const response = await fetch('/api/creators/newCreator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(creatorData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('creator-success', `Creator registered successfully! Transaction ID: ${data.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('creator-name').value = '';
                    document.getElementById('creator-description').value = '';
                    document.getElementById('creator-email').value = '';
                    document.getElementById('creator-website').value = '';
                } else {
                    showMessage('creator-status', data.error || 'Failed to register creator', 'error');
                }
            } catch (error) {
                showMessage('creator-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Template creation functions
        function addTemplateField() {
            const fieldsContainer = document.getElementById('template-fields');
            const fieldRow = document.createElement('div');
            fieldRow.className = 'field-row';
            fieldRow.innerHTML = `
                <div>
                    <label>Field Name:</label>
                    <input type="text" class="field-name" placeholder="e.g., title, content">
                </div>
                <div>
                    <label>Field Type:</label>
                    <select class="field-type">
                        <option value="string">String</option>
                        <option value="number">Number</option>
                        <option value="boolean">Boolean</option>
                        <option value="enum">Enum</option>
                        <option value="array">Array</option>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="removeField(this)">Remove</button>
                </div>
            `;
            fieldsContainer.appendChild(fieldRow);
        }

        function removeField(button) {
            button.closest('.field-row').remove();
        }

        async function createTemplate() {
            const templateName = document.getElementById('template-name').value;
            const recordType = document.getElementById('template-recordtype').value;

            if (!templateName || !recordType) {
                showMessage('template-status', 'Please fill in template name and record type', 'error');
                return;
            }

            const fieldRows = document.querySelectorAll('#template-fields .field-row');
            const templateFields = {};

            fieldRows.forEach(row => {
                const fieldName = row.querySelector('.field-name').value;
                const fieldType = row.querySelector('.field-type').value;
                
                if (fieldName && fieldType) {
                    templateFields[fieldName] = fieldType;
                }
            });

            if (Object.keys(templateFields).length === 0) {
                showMessage('template-status', 'Please add at least one field', 'error');
                return;
            }

            const templateData = {
                template: templateName,
                recordType: recordType,
                fields: JSON.stringify(templateFields)
            };

            try {
                const response = await fetch('/api/templates/newTemplate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(templateData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('template-success', `Template created successfully! Transaction ID: ${data.newTemplate.transactionId}`, 'success');
                    // Clear form and reload templates
                    document.getElementById('template-name').value = '';
                    document.getElementById('template-recordtype').value = '';
                    await loadTemplates();
                } else {
                    showMessage('template-status', data.error || 'Failed to create template', 'error');
                }
            } catch (error) {
                showMessage('template-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Enhanced Record Publishing Functions
        function loadPublishInterface() {
            const recordType = document.getElementById('publish-record-type').value;
            const interfaceContainer = document.getElementById('publish-interface');
            
            if (!recordType) {
                interfaceContainer.innerHTML = '<div class="loading">Select a record type to see publishing interface</div>';
                return;
            }

            // Create tailored interface based on record type
            switch (recordType) {
                case 'post':
                    interfaceContainer.innerHTML = createPostInterface();
                    // Initialize storage type handler after interface is created
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                    }, 100);
                    break;
                case 'video':
                    interfaceContainer.innerHTML = createVideoInterface();
                    break;
                case 'audio':
                    interfaceContainer.innerHTML = createAudioInterface();
                    break;
                case 'music':
                    interfaceContainer.innerHTML = createAudioInterface();
                    // Set audio type to music after interface is loaded
                    setTimeout(() => {
                        document.getElementById('audio-type').value = 'music';
                        updateAudioTypeInterface();
                    }, 100);
                    break;
                case 'image':
                    interfaceContainer.innerHTML = createImageInterface();
                    break;
                case 'recipe':
                    interfaceContainer.innerHTML = createRecipeInterface();
                    break;
                case 'workout':
                    interfaceContainer.innerHTML = createWorkoutInterface();
                    break;
                case 'exercise':
                    interfaceContainer.innerHTML = createExerciseInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize exercise access level
                        updateExerciseAccessLevel();
                        // Load equipment data
                        loadEquipment();
                    }, 100);
                    break;
                case 'fitnessEquipment':
                    interfaceContainer.innerHTML = createFitnessEquipmentInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize equipment access level
                        updateEquipmentAccessLevel();
                    }, 100);
                    break;
                case 'media':
                    interfaceContainer.innerHTML = createMediaInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize organization field visibility
                        updateMediaAccessLevel();
                    }, 100);
                    break;
                case 'multiResolutionGif':
                    interfaceContainer.innerHTML = createMultiResolutionGifInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                        // Initialize GIF input method and access level
                        updateGifInputMethod();
                        updateGifAccessLevel();
                    }, 100);
                    break;
                case 'text':
                    interfaceContainer.innerHTML = createTextInterface();
                    break;
                case 'organization':
                    interfaceContainer.innerHTML = createOrganizationInterface();
                    setTimeout(() => {
                        initializeStorageTypeHandler();
                    }, 100);
                    break;
                case 'exerciseBundle':
                    interfaceContainer.innerHTML = createExerciseBundleInterface();
                    setTimeout(() => {
                        initializeExerciseBundleInterface();
                    }, 100);
                    break;
                default:
                    interfaceContainer.innerHTML = '<div class="loading">Unknown record type</div>';
            }
        }

        function createPostInterface() {
            return `
                <div class="publish-form">
                    <h3>📝 Post / Article Publishing</h3>
                    
                    <!-- Post Source Selection -->
                    <div class="form-group">
                        <label for="post-source">Post Source:</label>
                        <select id="post-source" onchange="updatePostSource()">
                            <option value="manual">Create New Post</option>
                            <option value="archive-x">Archive X/Twitter Post</option>
                            <option value="archive-web">Archive Web Article</option>
                        </select>
                    </div>

                    <!-- Manual Post Creation Interface -->
                    <div id="manual-post-interface">
                        <!-- Post Type Selection -->
                        <div class="form-group">
                            <label for="post-type">Post Type:</label>
                            <select id="post-type" onchange="updatePostInterface()">
                                <option value="microblog">Microblog Post (Twitter-style)</option>
                                <option value="article">News Article</option>
                                <option value="blog">Blog Post</option>
                            </select>
                        </div>

                        <!-- Basic Information -->
                        <div class="form-group">
                            <label for="post-title">Title:</label>
                            <div style="display: flex; gap: 10px; align-items: flex-end;">
                                <input type="text" id="post-title" required placeholder="Enter post title..." style="flex: 1;" oninput="onNameFieldChange('post', this.value)">
                                <div id="post-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                    <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('post')" title="Copy data from the most recent matching record">
                                        📋 Copy From Latest
                                    </button>
                                    <button type="button" class="btn-small" onclick="fillInWithAI('post')" title="Use AI to fill in remaining fields">
                                        🤖 Fill In With AI
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="post-description">Description:</label>
                            <textarea id="post-description" placeholder="Brief description of the post..." rows="2"></textarea>
                        </div>

                        <!-- Article Content -->
                        <div class="form-group">
                            <label for="post-content">Content:</label>
                            <textarea id="post-content" required placeholder="Write your post content here..." rows="8"></textarea>
                            <small>Supports markdown formatting</small>
                        </div>

                        <!-- Author Information (for articles) -->
                        <div id="author-section">
                            <div class="form-group">
                                <label for="post-author">Author:</label>
                                <input type="text" id="post-author" placeholder="Author name">
                            </div>
                            <div class="form-group">
                                <label for="post-author-title">Author Title:</label>
                                <input type="text" id="post-author-title" placeholder="e.g., Senior Reporter">
                            </div>
                            <div class="form-group">
                                <label for="post-author-location">Author Location:</label>
                                <input type="text" id="post-author-location" placeholder="e.g., New York">
                            </div>
                        </div>

                        <!-- Media Attachments -->
                        <div class="media-section">
                            <h4>📎 Media Attachments</h4>
                            
                            <div class="form-group">
                                <label for="post-featured-image">Featured Image URL:</label>
                                <input type="url" id="post-featured-image" placeholder="https://example.com/image.jpg">
                            </div>

                            <div class="form-group">
                                <label for="post-web-url">Source URL:</label>
                                <input type="url" id="post-web-url" placeholder="Original article URL (if reposting)">
                            </div>

                            <div class="form-group">
                                <label for="post-reply-to">Reply To (DID):</label>
                                <input type="text" id="post-reply-to" placeholder="did:arweave:... (if replying to another post)">
                            </div>
                        </div>

                        <!-- Tags -->
                        <div class="form-group">
                            <label for="post-tags">Tags:</label>
                            <input type="text" id="post-tags" placeholder="tag1, tag2, tag3">
                            <small>Comma-separated tags</small>
                        </div>

                        <!-- NSFW Toggle -->
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="post-nsfw"> NSFW Content
                            </label>
                        </div>

                        <!-- GUN-specific options -->
                        <div id="gun-options" class="form-group" style="display: none; background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                            <h4 style="margin: 0 0 10px 0; color: #3730a3;">🔒 GUN Private Storage Options</h4>
                            
                            <div class="form-group">
                                <label for="gun-local-id">Local ID (optional):</label>
                                <input type="text" id="gun-local-id" placeholder="draft-001, my-recipe, etc.">
                                <small>Provide a custom identifier for this record. If empty, a content hash will be used.</small>
                            </div>

                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="gun-private"> Private Record (Encrypted)
                                </label>
                                <small>Check to encrypt this record. Only you will be able to read it.</small>
                            </div>
                        </div>
                    </div>

                    <!-- X Post Archival Interface -->
                    <div id="x-post-interface" class="hidden">
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                            <strong>💡 Tip:</strong> For reliable X post archiving, configure X API access. 
                            <a href="docs/X_API_SETUP.md" target="_blank" style="color: #1da1f2;">See setup guide</a>
                        </div>
                        
                        <div class="form-group">
                            <label for="x-post-url">X/Twitter Post URL:</label>
                            <input type="url" id="x-post-url" placeholder="https://x.com/username/status/1234567890" required>
                            <button type="button" onclick="scrapeXPost()" style="margin-top: 10px; width: 100%;">
                                🔍 Fetch Post Data
                            </button>
                        </div>

                        <div id="x-post-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #1da1f2;">
                            <h4>📱 Post Preview</h4>
                            <div id="x-post-content"></div>
                            <div id="x-post-meta" style="margin-top: 10px; font-size: 0.9rem; color: #666;"></div>
                        </div>

                        <div id="x-post-status" class="hidden" style="margin-top: 15px; padding: 10px; border-radius: 6px;"></div>
                    </div>

                    <!-- Web Article Archival Interface -->
                    <div id="web-article-interface" class="hidden">
                        <div class="form-group">
                            <label for="web-article-url">Article URL:</label>
                            <input type="url" id="web-article-url" placeholder="https://example.com/article-title" required>
                            <button type="button" onclick="scrapeWebArticle()" style="margin-top: 10px; width: 100%;">
                                📰 Archive Article
                            </button>
                        </div>

                        <div id="web-article-progress" class="hidden" style="margin-top: 20px;">
                            <div class="publish-progress">
                                <h4 id="web-article-progress-title">📰 Archiving Web Article...</h4>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="web-article-progress-bar" style="width: 0%;"></div>
                                </div>
                                <div id="web-article-status" style="margin-top: 10px; font-size: 0.9rem;">Initializing...</div>
                            </div>
                        </div>

                        <div id="web-article-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
                            <h4>📰 Article Preview</h4>
                            <div id="web-article-content"></div>
                            <div id="web-article-meta" style="margin-top: 10px; font-size: 0.9rem; color: #666;"></div>
                        </div>

                        <div id="web-article-result" class="hidden" style="margin-top: 15px; padding: 10px; border-radius: 6px;"></div>
                    </div>

                    <button onclick="publishPost()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="post-publish-text">📤 Publish Post</span>
                    </button>
                </div>
            `;
        }

        function createVideoInterface() {
            return `
                <div class="publish-form">
                    <h3>🎥 Video Publishing</h3>
                    
                    <!-- Video Source -->
                    <div class="form-group">
                        <label for="video-source">Video Source:</label>
                        <select id="video-source" onchange="updateVideoInterface()">
                            <option value="manual">Manual Entry</option>
                            <option value="youtube-archive">Archive YouTube Video</option>
                            <option value="direct">Direct Video URL</option>
                            <option value="upload">Upload Video File</option>
                        </select>
                    </div>

                    <div id="video-input-section">
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    </div>

                    <!-- Video Information -->
                    <div class="form-group">
                        <label for="video-title">Title:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="video-title" required placeholder="Video title" style="flex: 1;" oninput="onNameFieldChange('video', this.value)">
                            <div id="video-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('video')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('video')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="video-description">Description:</label>
                        <textarea id="video-description" placeholder="Video description..." rows="4"></textarea>
                    </div>

                    <!-- Video Metadata -->
                    <div class="form-group">
                        <label for="video-duration">Duration (minutes):</label>
                        <input type="number" id="video-duration" placeholder="e.g., 15">
                    </div>

                    <div class="form-group">
                        <label for="video-channel">Channel/Creator:</label>
                        <input type="text" id="video-channel" placeholder="Channel or creator name">
                    </div>

                    <div class="form-group">
                        <label for="video-thumbnail">Thumbnail URL:</label>
                        <input type="url" id="video-thumbnail" placeholder="https://example.com/thumbnail.jpg">
                    </div>

                    <!-- Tags and Categories -->
                    <div class="form-group">
                        <label for="video-category">Category:</label>
                        <select id="video-category">
                            <option value="">Select category</option>
                            <option value="education">Education</option>
                            <option value="entertainment">Entertainment</option>
                            <option value="music">Music</option>
                            <option value="news">News</option>
                            <option value="sports">Sports</option>
                            <option value="technology">Technology</option>
                            <option value="gaming">Gaming</option>
                            <option value="howto">How-to & Style</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="video-tags">Tags:</label>
                        <input type="text" id="video-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="video-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="video-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="video-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishVideo()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="video-publish-text">🎥 Publish Video</span>
                    </button>
                </div>
            `;
        }

        function createAudioInterface() {
            return `
                <div class="publish-form">
                    <h3>🎵 Audio / Podcast Publishing</h3>
                    
                    <!-- Audio Type Selection -->
                    <div class="form-group">
                        <label for="audio-type">Audio Type:</label>
                        <select id="audio-type" onchange="updateAudioTypeInterface()">
                            <option value="music">Music</option>
                            <option value="podcast" disabled style="color: #999;">Podcast (Not yet supported)</option>
                        </select>
                        <small>Select the type of audio content you're publishing</small>
                    </div>
                    
                    <!-- Audio Source -->
                    <div class="form-group">
                        <label for="audio-source">Audio Source:</label>
                        <select id="audio-source" onchange="updateAudioInterface()">
                            <option value="url">Audio URL</option>
                            <option value="upload">Upload Audio File</option>
                        </select>
                    </div>

                    <div id="audio-input-section">
                        <div class="form-group">
                            <label for="audio-url">Audio URL:</label>
                            <input type="url" id="audio-url" placeholder="https://example.com/audio.mp3">
                        </div>
                    </div>

                    <!-- Audio Information -->
                    <div class="form-group">
                        <label for="audio-title">Title:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="audio-title" required placeholder="Audio title" style="flex: 1;" oninput="onNameFieldChange('audio', this.value)">
                            <div id="audio-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('audio')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('audio')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="audio-description">Description:</label>
                        <textarea id="audio-description" placeholder="Audio description..." rows="4"></textarea>
                    </div>

                    <!-- Language Selection -->
                    <div class="form-group">
                        <label for="audio-language">Language:</label>
                        <select id="audio-language">
                            <option value="en">English</option>
                            <option value="es">Spanish; Castilian</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Audio Metadata -->
                    <div class="form-group">
                        <label for="audio-duration">Duration (seconds):</label>
                        <input type="number" id="audio-duration" placeholder="e.g., 225 (3:45)">
                        <small>Duration in seconds (will be auto-detected for uploaded files)</small>
                    </div>

                    <div class="form-group">
                        <label for="audio-creator">Creator/Artist:</label>
                        <input type="text" id="audio-creator" placeholder="Artist or creator name">
                    </div>

                    <!-- Music-specific fields (shown when audio type is music) -->
                    <div id="music-fields" style="display: block;">
                        <div class="form-group">
                            <label for="music-genre">Genre:</label>
                            <select id="music-genre">
                                <option value="">Select genre</option>
                                <option value="Classical">Classical</option>
                                <option value="Rock">Rock</option>
                                <option value="Pop">Pop</option>
                                <option value="Hip-Hop">Hip-Hop</option>
                                <option value="Jazz">Jazz</option>
                                <option value="Blues">Blues</option>
                                <option value="Country">Country</option>
                                <option value="Electronic">Electronic</option>
                                <option value="Folk">Folk</option>
                                <option value="R&B">R&B</option>
                                <option value="Reggae">Reggae</option>
                                <option value="Metal">Metal</option>
                                <option value="Punk">Punk</option>
                                <option value="Alternative">Alternative</option>
                                <option value="Indie">Indie</option>
                                <option value="World">World</option>
                                <option value="Other">Other</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="music-sub-genre">Sub-Genre:</label>
                            <input type="text" id="music-sub-genre" placeholder="e.g., Progressive Rock, Romantic">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div class="form-group">
                                <label for="music-bpm">BPM (Beats Per Minute):</label>
                                <input type="number" id="music-bpm" placeholder="e.g., 120" min="40" max="200">
                            </div>
                            <div class="form-group">
                                <label for="music-key">Musical Key:</label>
                                <input type="text" id="music-key" placeholder="e.g., C Major, A Minor">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div class="form-group">
                                <label for="music-sample-rate">Sample Rate (Hz):</label>
                                <select id="music-sample-rate">
                                    <option value="44100" selected>44,100 Hz (CD Quality)</option>
                                    <option value="48000">48,000 Hz (Professional)</option>
                                    <option value="96000">96,000 Hz (High-Res)</option>
                                    <option value="192000">192,000 Hz (Ultra High-Res)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="music-bit-depth">Bit Depth:</label>
                                <select id="music-bit-depth">
                                    <option value="16" selected>16-bit (CD Quality)</option>
                                    <option value="24">24-bit (Professional)</option>
                                    <option value="32">32-bit (Ultra High-Res)</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="music-album">Album:</label>
                            <input type="text" id="music-album" placeholder="Album or collection name">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div class="form-group">
                                <label for="music-track-number">Track Number:</label>
                                <input type="number" id="music-track-number" placeholder="e.g., 1" min="1">
                            </div>
                            <div class="form-group">
                                <label for="music-isrc">ISRC Code:</label>
                                <input type="text" id="music-isrc" placeholder="e.g., US-ABC-12-34567">
                                <small>International Standard Recording Code</small>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="music-composers">Composers (comma-separated):</label>
                            <input type="text" id="music-composers" placeholder="Ludwig van Beethoven, Wolfgang Amadeus Mozart">
                            <small>Names of composers or songwriters</small>
                        </div>

                        <div class="form-group">
                            <label for="music-performers">Performers (comma-separated):</label>
                            <input type="text" id="music-performers" placeholder="Vienna Philharmonic, John Doe">
                            <small>Names of performers, bands, or orchestras</small>
                        </div>

                        <div class="form-group">
                            <label for="music-lyrics">Lyrics DID Reference:</label>
                            <input type="text" id="music-lyrics" placeholder="did:arweave:... (optional)">
                            <small>Reference to a text record containing the lyrics</small>
                        </div>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="audio-tags">Tags:</label>
                        <input type="text" id="audio-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="audio-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <!-- File Upload Progress -->
                    <div id="audio-upload-progress" class="upload-progress hidden" style="margin: 15px 0;">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text">Ready to upload...</div>
                    </div>

                    <!-- Audio Preview -->
                    <div id="audio-preview" class="media-preview hidden" style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                        <h4>Audio Preview:</h4>
                        <div id="audio-preview-content"></div>
                        <div id="audio-info" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                    </div>

                    <button onclick="publishAudio()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="audio-publish-text">🎵 Publish Audio</span>
                    </button>
                </div>
            `;
        }

        function createImageInterface() {
            return `
                <div class="publish-form">
                    <h3>📷 Image Publishing</h3>
                    
                    <!-- Image Source -->
                    <div class="form-group">
                        <label for="image-source">Image Source:</label>
                        <select id="image-source" onchange="updateImageInterface()">
                            <option value="url">Image URL</option>
                            <option value="upload">Upload Image File</option>
                        </select>
                    </div>

                    <div id="image-input-section">
                        <div class="form-group">
                            <label for="image-url">Image URL:</label>
                            <input type="url" id="image-url" placeholder="https://example.com/image.jpg">
                            <button type="button" onclick="previewImage()" style="margin-top: 5px;">Preview</button>
                        </div>
                    </div>

                    <!-- Image Preview -->
                    <div id="image-preview" class="hidden" style="margin: 15px 0;">
                        <img id="preview-img" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
                    </div>

                    <!-- Image Information -->
                    <div class="form-group">
                        <label for="image-title">Title:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="image-title" required placeholder="Image title" style="flex: 1;" oninput="onNameFieldChange('image', this.value)">
                            <div id="image-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('image')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('image')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="image-description">Description:</label>
                        <textarea id="image-description" placeholder="Image description..." rows="3"></textarea>
                    </div>

                    <!-- Image Metadata -->
                    <div class="form-group">
                        <label for="image-alt-text">Alt Text:</label>
                        <input type="text" id="image-alt-text" placeholder="Accessibility description">
                    </div>

                    <div class="form-group">
                        <label for="image-photographer">Photographer/Creator:</label>
                        <input type="text" id="image-photographer" placeholder="Creator name">
                    </div>

                    <div class="form-group">
                        <label for="image-location">Location:</label>
                        <input type="text" id="image-location" placeholder="Where the image was taken">
                    </div>

                    <!-- Categories and Tags -->
                    <div class="form-group">
                        <label for="image-category">Category:</label>
                        <select id="image-category">
                            <option value="">Select category</option>
                            <option value="photography">Photography</option>
                            <option value="art">Art</option>
                            <option value="nature">Nature</option>
                            <option value="architecture">Architecture</option>
                            <option value="portrait">Portrait</option>
                            <option value="landscape">Landscape</option>
                            <option value="abstract">Abstract</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="image-tags">Tags:</label>
                        <input type="text" id="image-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="image-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="image-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="image-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishImage()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📷 Publish Image
                    </button>
                </div>
            `;
        }

        function createRecipeInterface() {
            return `
                <div class="publish-form">
                    <h3>🍳 Recipe Publishing</h3>
                    
                    <!-- Recipe Basic Info -->
                    <div class="form-group">
                        <label for="recipe-title">Recipe Name:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="recipe-title" required placeholder="e.g., Mediterranean Grilled Chicken" style="flex: 1;" oninput="onNameFieldChange('recipe', this.value)">
                            <div id="recipe-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('recipe')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('recipe')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="recipe-description">Description:</label>
                        <textarea id="recipe-description" placeholder="Brief description of the recipe..." rows="3"></textarea>
                    </div>

                    <!-- Recipe Image -->
                    <div class="form-group">
                        <label for="recipe-image">Recipe Image URL:</label>
                        <input type="url" id="recipe-image" placeholder="https://example.com/recipe-image.jpg">
                    </div>

                    <!-- Recipe Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-prep-time">Prep Time (minutes):</label>
                            <input type="number" id="recipe-prep-time" placeholder="e.g., 15">
                        </div>
                        <div class="form-group">
                            <label for="recipe-cook-time">Cook Time (minutes):</label>
                            <input type="number" id="recipe-cook-time" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="recipe-servings">Servings:</label>
                            <input type="number" id="recipe-servings" placeholder="e.g., 4">
                        </div>
                        <div class="form-group">
                            <label for="recipe-difficulty">Difficulty:</label>
                            <select id="recipe-difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                    </div>

                    <!-- Cuisine and Course -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-cuisine">Cuisine:</label>
                            <input type="text" id="recipe-cuisine" placeholder="e.g., Mediterranean, Italian">
                        </div>
                        <div class="form-group">
                            <label for="recipe-course">Course:</label>
                            <select id="recipe-course">
                                <option value="">Select course</option>
                                <option value="appetizer">Appetizer</option>
                                <option value="main">Main Course</option>
                                <option value="side">Side Dish</option>
                                <option value="dessert">Dessert</option>
                                <option value="drink">Drink</option>
                                <option value="snack">Snack</option>
                            </select>
                        </div>
                    </div>

                    <!-- Ingredients -->
                    <div class="form-group">
                        <label>Ingredients:</label>
                        <div id="ingredients-container">
                            <div class="ingredient-row" style="display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Amount" class="ingredient-amount">
                                <input type="text" placeholder="Unit" class="ingredient-unit">
                                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                                <button type="button" onclick="removeIngredient(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addIngredient()" style="margin-top: 10px;">+ Add Ingredient</button>
                    </div>

                    <!-- Instructions -->
                    <div class="form-group">
                        <label for="recipe-instructions">Instructions:</label>
                        <textarea id="recipe-instructions" required placeholder="1. First step...
2. Second step...
3. Third step..." rows="8"></textarea>
                        <small>Write each step on a new line</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="recipe-notes">Notes:</label>
                        <textarea id="recipe-notes" placeholder="Additional notes, tips, or variations..." rows="3"></textarea>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="recipe-tags">Tags:</label>
                        <input type="text" id="recipe-tags" placeholder="vegetarian, quick, healthy">
                    </div>

                    <button onclick="publishRecipe()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🍳 Publish Recipe
                    </button>
                </div>
            `;
        }

        function createWorkoutInterface() {
            return `
                <div class="publish-form">
                    <h3>💪 Workout Publishing</h3>
                    
                    <!-- Workout Basic Info -->
                    <div class="form-group">
                        <label for="workout-title">Workout Name:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="workout-title" required placeholder="e.g., Full Body HIIT Workout" style="flex: 1;" oninput="onNameFieldChange('workout', this.value)">
                            <div id="workout-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('workout')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('workout')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="workout-description">Description:</label>
                        <textarea id="workout-description" placeholder="Brief description of the workout..." rows="3"></textarea>
                    </div>

                    <!-- Workout Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-duration">Duration (minutes):</label>
                            <input type="number" id="workout-duration" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="workout-difficulty">Difficulty:</label>
                            <select id="workout-difficulty">
                                <option value="beginner">Beginner</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="advanced">Advanced</option>
                            </select>
                        </div>
                    </div>

                    <!-- Workout Type and Equipment -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-category">Category:</label>
                            <select id="workout-category">
                                <option value="">Select category</option>
                                <option value="strength">Strength Training</option>
                                <option value="cardio">Cardio</option>
                                <option value="hiit">HIIT</option>
                                <option value="yoga">Yoga</option>
                                <option value="pilates">Pilates</option>
                                <option value="flexibility">Flexibility</option>
                                <option value="sports">Sports</option>
                                <option value="mixed">Mixed</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="workout-equipment">Equipment Required:</label>
                            <input type="text" id="workout-equipment" placeholder="dumbbells, resistance bands">
                        </div>
                    </div>

                    <!-- Target Muscle Groups -->
                    <div class="form-group">
                        <label for="workout-muscles">Target Muscle Groups:</label>
                        <input type="text" id="workout-muscles" placeholder="chest, shoulders, legs">
                    </div>

                    <!-- Exercises -->
                    <div class="form-group">
                        <label>Exercises:</label>
                        <div id="exercises-container">
                            <div class="exercise-row" style="display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Exercise name" class="exercise-name">
                                <input type="text" placeholder="Sets" class="exercise-sets">
                                <input type="text" placeholder="Reps" class="exercise-reps">
                                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                                <button type="button" onclick="removeExercise(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addExercise()" style="margin-top: 10px;">+ Add Exercise</button>
                    </div>

                    <!-- Workout Type Toggle -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="workout-non-standard"> Non-standard workout (custom exercises)
                        </label>
                        <small>Check this if your exercises are not in our database</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="workout-notes">Notes:</label>
                        <textarea id="workout-notes" placeholder="Additional notes, tips, or modifications..." rows="3"></textarea>
                    </div>

                    <!-- Goal Tags -->
                    <div class="form-group">
                        <label for="workout-goals">Goal Tags:</label>
                        <input type="text" id="workout-goals" placeholder="weight loss, muscle gain, endurance">
                    </div>

                    <button onclick="publishWorkout()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        💪 Publish Workout
                    </button>
                </div>
            `;
        }

        function createTextInterface() {
            return `
                <div class="publish-form">
                    <h3>📄 Text Document Publishing</h3>
                    
                    <!-- Text Document Info -->
                    <div class="form-group">
                        <label for="text-title">Document Title:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="text-title" required placeholder="Document title" style="flex: 1;" oninput="onNameFieldChange('text', this.value)">
                            <div id="text-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('text')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('text')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="text-description">Description:</label>
                        <textarea id="text-description" placeholder="Brief description..." rows="2"></textarea>
                    </div>

                    <!-- Content -->
                    <div class="form-group">
                        <label for="text-content">Content:</label>
                        <textarea id="text-content" required placeholder="Enter your text content here..." rows="15"></textarea>
                        <small>Supports plain text and markdown</small>
                    </div>

                    <!-- Document Type -->
                    <div class="form-group">
                        <label for="text-type">Document Type:</label>
                        <select id="text-type">
                            <option value="document">Document</option>
                            <option value="article">Article</option>
                            <option value="essay">Essay</option>
                            <option value="story">Story</option>
                            <option value="poem">Poem</option>
                            <option value="tutorial">Tutorial</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Author Information -->
                    <div class="form-group">
                        <label for="text-author">Author:</label>
                        <input type="text" id="text-author" placeholder="Author name">
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="text-language">Language:</label>
                        <select id="text-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="text-tags">Tags:</label>
                        <input type="text" id="text-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="text-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishText()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📄 Publish Text
                    </button>
                </div>
            `;
        }

        function createOrganizationInterface() {
            return `
                <div class="publish-form">
                    <h3>🏢 Organization Registration</h3>
                    
                    <div class="info-box" style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>🔐 Organization Ownership</h4>
                        <p>Organizations are created using your HD wallet identity:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>🔑 <strong>Your public key</strong> will be set as the organization public key</li>
                            <li>👑 <strong>You will be the admin</strong> with full management rights</li>
                            <li>🏢 <strong>Organization handle</strong> must be unique across the network</li>
                            <li>📋 <strong>Membership policy</strong> controls how users can join</li>
                        </ul>
                    </div>

                    <!-- Organization Basic Info -->
                    <div class="form-group">
                        <label for="org-name">Organization Name:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <div style="flex: 1;">
                                <input type="text" id="org-name" required placeholder="e.g., ALEXANDRIA Research Foundation" style="width: 100%;" oninput="onNameFieldChange('organization', this.value)">
                                <small>The full, human-readable name of your organization</small>
                            </div>
                            <div id="organization-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('organization')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('organization')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="org-description">Description:</label>
                        <textarea id="org-description" required placeholder="Brief description of your organization's mission and activities..." rows="4"></textarea>
                        <small>Describe what your organization does and its goals</small>
                    </div>

                    <!-- Organization Handle -->
                    <div class="form-group">
                        <label for="org-handle">Organization Handle:</label>
                        <input type="text" id="org-handle" required placeholder="e.g., alexandria-research" pattern="[a-z0-9-]+" style="font-family: monospace;">
                        <small>Unique identifier (lowercase letters, numbers, and hyphens only). This cannot be changed later.</small>
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="org-language">Primary Language:</label>
                        <select id="org-language">
                            <option value="en">English</option>
                            <option value="es">Spanish; Castilian</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="pt">Portuguese</option>
                            <option value="ru">Russian</option>
                            <option value="it">Italian</option>
                            <option value="ko">Korean</option>
                            <option value="tr">Turkish</option>
                            <option value="pl">Polish</option>
                            <option value="nl">Dutch; Flemish</option>
                            <option value="sv">Swedish</option>
                            <option value="da">Danish</option>
                            <option value="no">Norwegian</option>
                            <option value="fi">Finnish</option>
                            <option value="el">Greek, Modern (1453-)</option>
                            <option value="he">Hebrew</option>
                            <option value="th">Thai</option>
                            <option value="vi">Vietnamese</option>
                            <option value="cs">Czech</option>
                            <option value="hu">Hungarian</option>
                            <option value="ro">Romanian; Moldavian; Moldovan</option>
                            <option value="bg">Bulgarian</option>
                            <option value="hr">Croatian</option>
                            <option value="sk">Slovak</option>
                            <option value="sl">Slovenian</option>
                            <option value="et">Estonian</option>
                            <option value="lv">Latvian</option>
                            <option value="lt">Lithuanian</option>
                            <option value="uk">Ukrainian</option>
                            <option value="be">Belarusian</option>
                            <option value="mk">Macedonian</option>
                            <option value="sq">Albanian</option>
                            <option value="sr">Serbian</option>
                            <option value="bs">Bosnian</option>
                            <option value="mt">Maltese</option>
                            <option value="ga">Irish</option>
                            <option value="cy">Welsh</option>
                            <option value="is">Icelandic</option>
                            <option value="fo">Faroese</option>
                            <option value="eu">Basque</option>
                            <option value="ca">Catalan; Valencian</option>
                            <option value="gl">Galician</option>
                            <option value="oc">Occitan (post 1500)</option>
                            <option value="br">Breton</option>
                            <option value="gd">Gaelic; Scomttish Gaelic</option>
                            <option value="gv">Manx</option>
                            <option value="kw">Cornish</option>
                            <option value="cy">Welsh</option>
                            <option value="af">Afrikaans</option>
                            <option value="zu">Zulu</option>
                            <option value="xh">Xhosa</option>
                            <option value="sw">Swahili</option>
                            <option value="am">Amharic</option>
                            <option value="ti">Tigrinya</option>
                            <option value="so">Somali</option>
                            <option value="om">Oromo</option>
                            <option value="ha">Hausa</option>
                            <option value="yo">Yoruba</option>
                            <option value="ig">Igbo</option>
                            <option value="aa">Afar</option>
                            <option value="ab">Abkhazian</option>
                            <option value="ae">Avestan</option>
                            <option value="ak">Akan</option>
                            <option value="an">Aragonese</option>
                            <option value="as">Assamese</option>
                            <option value="av">Avaric</option>
                            <option value="ay">Aymara</option>
                            <option value="az">Azerbaijani</option>
                            <option value="ba">Bashkir</option>
                            <option value="bh">Bihari languages</option>
                            <option value="bi">Bislama</option>
                            <option value="bm">Bambara</option>
                            <option value="bn">Bengali</option>
                            <option value="bo">Tibetan</option>
                            <option value="ce">Chechen</option>
                            <option value="ch">Chamorro</option>
                            <option value="co">Corsican</option>
                            <option value="cr">Cree</option>
                            <option value="cu">Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic</option>
                            <option value="cv">Chuvash</option>
                            <option value="dv">Divehi; Dhivehi; Maldivian</option>
                            <option value="dz">Dzongkha</option>
                            <option value="ee">Ewe</option>
                            <option value="eo">Esperanto</option>
                            <option value="et">Estonian</option>
                            <option value="fa">Persian</option>
                            <option value="ff">Fulah</option>
                            <option value="fj">Fijian</option>
                            <option value="fy">Western Frisian</option>
                            <option value="gn">Guarani</option>
                            <option value="gu">Gujarati</option>
                            <option value="ht">Haitian; Haitian Creole</option>
                            <option value="hy">Armenian</option>
                            <option value="hz">Herero</option>
                            <option value="ia">Interlingua (International Auxiliary Language Association)</option>
                            <option value="id">Indonesian</option>
                            <option value="ie">Interlingue; Occidental</option>
                            <option value="ii">Sichuan Yi; Nuosu</option>
                            <option value="ik">Inupiaq</option>
                            <option value="io">Ido</option>
                            <option value="iu">Inuktitut</option>
                            <option value="jv">Javanese</option>
                            <option value="ka">Georgian</option>
                            <option value="kg">Kongo</option>
                            <option value="ki">Kikuyu; Gikuyu</option>
                            <option value="kj">Kuanyama; Kwanyama</option>
                            <option value="kk">Kazakh</option>
                            <option value="kl">Kalaallisut; Greenlandic</option>
                            <option value="km">Central Khmer</option>
                            <option value="kn">Kannada</option>
                            <option value="kr">Kanuri</option>
                            <option value="ks">Kashmiri</option>
                            <option value="ku">Kurdish</option>
                            <option value="kv">Komi</option>
                            <option value="ky">Kirghiz; Kyrgyz</option>
                            <option value="la">Latin</option>
                            <option value="lb">Luxembourgish; Letzeburgesch</option>
                            <option value="lg">Ganda</option>
                            <option value="li">Limburgan; Limburger; Limburgish</option>
                            <option value="ln">Lingala</option>
                            <option value="lo">Lao</option>
                            <option value="lu">Luba-Katanga</option>
                            <option value="mg">Malagasy</option>
                            <option value="mh">Marshallese</option>
                            <option value="mi">Maori</option>
                            <option value="ml">Malayalam</option>
                            <option value="mn">Mongolian</option>
                            <option value="mr">Marathi</option>
                            <option value="ms">Malay</option>
                            <option value="my">Burmese</option>
                            <option value="na">Nauru</option>
                            <option value="nb">Bokmål, Norwegian; Norwegian Bokmål</option>
                            <option value="nd">Ndebele, North; North Ndebele</option>
                            <option value="ne">Nepali</option>
                            <option value="ng">Ndonga</option>
                            <option value="nn">Norwegian Nynorsk; Nynorsk, Norwegian</option>
                            <option value="nr">Ndebele, South; South Ndebele</option>
                            <option value="nv">Navajo; Navaho</option>
                            <option value="ny">Chichewa; Chewa; Nyanja</option>
                            <option value="oj">Ojibwa</option>
                            <option value="or">Oriya</option>
                            <option value="os">Ossetian; Ossetic</option>
                            <option value="pa">Panjabi; Punjabi</option>
                            <option value="pi">Pali</option>
                            <option value="ps">Pushto; Pashto</option>
                            <option value="qu">Quechua</option>
                            <option value="rm">Romansh</option>
                            <option value="rn">Rundi</option>
                            <option value="rw">Kinyarwanda</option>
                            <option value="sa">Sanskrit</option>
                            <option value="sc">Sardinian</option>
                            <option value="sd">Sindhi</option>
                            <option value="se">Northern Sami</option>
                            <option value="sg">Sango</option>
                            <option value="si">Sinhala; Sinhalese</option>
                            <option value="sm">Samoan</option>
                            <option value="sn">Shona</option>
                            <option value="ss">Swati</option>
                            <option value="st">Sotho, Southern</option>
                            <option value="su">Sundanese</option>
                            <option value="ta">Tamil</option>
                            <option value="te">Telugu</option>
                            <option value="tg">Tajik</option>
                            <option value="ti">Tigrinya</option>
                            <option value="tk">Turkmen</option>
                            <option value="tl">Tagalog</option>
                            <option value="tn">Tswana</option>
                            <option value="to">Tonga (Tonga Islands)</option>
                            <option value="ts">Tsonga</option>
                            <option value="tt">Tatar</option>
                            <option value="tw">Twi</option>
                            <option value="ty">Tahitian</option>
                            <option value="ug">Uighur; Uyghur</option>
                            <option value="ur">Urdu</option>
                            <option value="uz">Uzbek</option>
                            <option value="ve">Venda</option>
                            <option value="vo">Volapük</option>
                            <option value="wa">Walloon</option>
                            <option value="wo">Wolof</option>
                            <option value="yi">Yiddish</option>
                            <option value="za">Zhuang; Chuang</option>
                        </select>
                        <small>Primary language for organization communications</small>
                    </div>

                    <!-- Website URL -->
                    <div class="form-group">
                        <label for="org-web-url">Website URL:</label>
                        <input type="url" id="org-web-url" placeholder="https://example.com">
                        <small>Official website or main online presence</small>
                    </div>

                    <!-- Organization Handle -->
                    <div class="form-group">
                        <label for="org-handle">Organization Handle:</label>
                        <input type="text" id="org-handle" required placeholder="e.g., alexandria-research" pattern="[a-z0-9-]+" style="font-family: monospace;">
                        <small>Unique identifier (lowercase letters, numbers, and hyphens only). This cannot be changed later.</small>
                    </div>

                    <!-- Membership Policy -->
                    <div class="form-group">
                        <label for="org-membership-policy">Membership Policy:</label>
                        <select id="org-membership-policy" required>
                            <option value="">Select membership policy</option>
                            <option value="invite-only">Invite Only - Members must be invited by admins</option>
                            <option value="app-user-auto">Auto-Enroll App Users - All app users automatically join</option>
                            <option value="token-gated">Token-Gated Membership - Requires specific tokens/NFTs</option>
                            <option value="open-join">Open Join - Anyone can join freely</option>
                        </select>
                        <small>Controls how users can become members of your organization</small>
                    </div>

                    <!-- Ownership Information (Read-Only) -->
                    <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745;">
                        <h4 style="margin: 0 0 10px 0; color: #28a745;">🔐 Ownership Details</h4>
                        <div style="font-family: monospace; font-size: 12px; color: #666;">
                            <div><strong>Organization Public Key:</strong> <span id="org-public-key-display">Loading from JWT...</span></div>
                            <div><strong>Admin Public Key:</strong> <span id="org-admin-key-display">Loading from JWT...</span></div>
                        </div>
                        <small>These are automatically derived from your authenticated HD wallet</small>
                    </div>

                    <!-- GUN-specific options -->
                    <div id="gun-options" class="form-group" style="display: none; background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <h4 style="margin: 0 0 10px 0; color: #3730a3;">🔒 GUN Private Storage Options</h4>
                        
                        <div class="form-group">
                            <label for="gun-local-id">Local ID (optional):</label>
                            <input type="text" id="gun-local-id" placeholder="my-org-001, foundation-draft, etc.">
                            <small>Provide a custom identifier for this organization. If empty, the org handle will be used.</small>
                        </div>

                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="gun-private"> Private Organization (Encrypted)
                            </label>
                            <small>Check to encrypt this organization record. Only you will be able to read it.</small>
                        </div>
                    </div>

                    <button onclick="publishOrganization()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏢 Register Organization
                    </button>
                </div>
            `;
        }

        function createExerciseBundleInterface() {
            return `
                <div class="publish-form">
                    <h3>🎯 Exercise Bundle - Complete Workflow</h3>
                    
                    <div class="info-box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                        <h4 style="margin: 0 0 12px 0; color: white;">📚 Multi-Record Publishing</h4>
                        <p style="margin: 0 0 12px 0; opacity: 0.95;">Publish a complete exercise with all dependencies in one workflow:</p>
                        <ol style="margin: 10px 0 10px 20px; opacity: 0.95;">
                            <li><strong>Exercise</strong> - Define your exercise</li>
                            <li><strong>Demo GIFs</strong> - Upload multi-resolution demonstration</li>
                            <li><strong>Equipment</strong> - Add required equipment (icon + details)</li>
                        </ol>
                        <p style="margin: 15px 0 0 0; font-size: 14px; opacity: 0.9;">
                            ✨ <strong>Smart DID Passing:</strong> Everything is linked automatically!
                        </p>
                    </div>

                    <!-- Progress Tracker -->
                    <div id="bundle-progress" class="hidden" style="background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 10px 0;">📊 Publishing Progress</h4>
                        <div id="bundle-progress-message" style="margin-bottom: 10px; font-weight: 500;"></div>
                        <div class="progress-bar" style="width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                            <div id="bundle-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4caf50, #81c784); transition: width 0.3s ease;"></div>
                        </div>
                    </div>

                    <!-- Section 1: Exercise (Top Level) -->
                    <div id="bundle-section-exercise" class="bundle-section" style="border: 2px solid #e8f5e9; border-radius: 12px; padding: 20px; margin-bottom: 20px; background: white;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 18px;">1</div>
                            <h4 style="margin: 0; flex: 1;">🏃 Exercise</h4>
                            <button type="button" onclick="toggleSection('bundle-section-exercise-content')" class="btn-small">Toggle</button>
                        </div>
                        
                        <div id="bundle-section-exercise-content">
                            <div class="form-group">
                                <label for="bundle-exercise-name">Exercise Name:</label>
                                <div style="display: flex; gap: 10px; align-items: flex-end;">
                                    <div style="flex: 1;">
                                        <input type="text" id="bundle-exercise-name" placeholder="e.g., Roll Lat Foam Rolling" style="width: 100%;">
                                    </div>
                                    <button type="button" class="btn-small btn-secondary" onclick="copyBundleFromLatestExercise()">
                                        📋 Copy From Latest
                                    </button>
                                    <button type="button" class="btn-small" onclick="fillBundleExerciseWithAI()">
                                        🤖 Fill In With AI
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-description">Description:</label>
                                <textarea id="bundle-exercise-description" rows="3" placeholder="Brief description of the exercise..."></textarea>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-instructions">Instructions:</label>
                                <textarea id="bundle-exercise-instructions" rows="4" placeholder="Step-by-step exercise instructions..."></textarea>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-muscle-groups">Muscle Groups (comma-separated):</label>
                                <input type="text" id="bundle-exercise-muscle-groups" placeholder="chest, triceps, shoulders">
                                <small>Primary muscle groups targeted by this exercise</small>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-difficulty">Difficulty:</label>
                                <select id="bundle-exercise-difficulty">
                                    <option value="beginner">Beginner</option>
                                    <option value="intermediate">Intermediate</option>
                                    <option value="advanced">Advanced</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-category">Category:</label>
                                <select id="bundle-exercise-category">
                                    <option value="strength">Strength</option>
                                    <option value="cardio">Cardio</option>
                                    <option value="flexibility">Flexibility</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-type">Exercise Type:</label>
                                <select id="bundle-exercise-type">
                                    <option value="warmup">Warm-Up</option>
                                    <option value="main">Main</option>
                                    <option value="cooldown">Cool-Down</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-measurement">Measurement Type:</label>
                                <select id="bundle-exercise-measurement" onchange="updateBundleExerciseMeasurement()">
                                    <option value="reps">Reps</option>
                                    <option value="timed">Timed</option>
                                    <option value="hold">Hold</option>
                                    <option value="maxdur">Maximum Duration</option>
                                </select>
                            </div>

                            <div class="form-group" id="bundle-exercise-sets-group">
                                <label for="bundle-exercise-sets">Recommended Sets:</label>
                                <input type="number" id="bundle-exercise-sets" min="0">
                            </div>

                            <div class="form-group" id="bundle-exercise-reps-group">
                                <label for="bundle-exercise-reps">Recommended Reps:</label>
                                <input type="number" id="bundle-exercise-reps" min="0">
                            </div>

                            <div class="form-group hidden" id="bundle-exercise-duration-group">
                                <label for="bundle-exercise-duration">Target Duration (seconds):</label>
                                <input type="number" id="bundle-exercise-duration" min="0">
                            </div>

                            <div class="form-group hidden" id="bundle-exercise-est-duration-group">
                                <label for="bundle-exercise-est-duration">Estimated Duration (minutes):</label>
                                <input type="number" id="bundle-exercise-est-duration" min="0">
                            </div>

                            <div class="form-group">
                                <label>Exercise Properties:</label>
                                <div style="margin-top: 10px;">
                                    <label><input type="checkbox" id="bundle-exercise-bodyweight"> Bodyweight Exercise</label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="bundle-exercise-storage">Storage Type:</label>
                                <select id="bundle-exercise-storage">
                                    <option value="arweave">Arweave (Permanent)</option>
                                    <option value="gun">GUN + BitTorrent</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Section 2: Multi-Resolution GIF -->
                    <div id="bundle-section-gif" class="bundle-section" style="border: 2px solid #fff3e0; border-radius: 12px; padding: 20px; margin-bottom: 20px; background: white;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 18px;">2</div>
                            <h4 style="margin: 0; flex: 1;">🎬 Demo GIF Collection</h4>
                            <button type="button" onclick="toggleSection('bundle-section-gif-content')" class="btn-small">Toggle</button>
                        </div>
                        
                        <div id="bundle-section-gif-content">
                            <div class="form-group">
                                <label for="bundle-gif-mode">Mode:</label>
                                <select id="bundle-gif-mode" onchange="toggleBundleGifMode()">
                                    <option value="create">Create New GIF Collection</option>
                                    <option value="existing">Select Existing GIF Collection</option>
                                </select>
                            </div>

                            <!-- Select Existing GIF (hidden by default) -->
                            <div class="form-group hidden" id="bundle-gif-existing-group">
                                <label for="bundle-gif-existing-select">Select GIF Collection:</label>
                                <select id="bundle-gif-existing-select">
                                    <option value="">Loading GIFs...</option>
                                </select>
                            </div>

                            <!-- Create New GIF Fields (shown by default) -->
                            <div id="bundle-gif-create-section">
                                <div class="form-group">
                                    <label for="bundle-gif-name">Collection Name:</label>
                                    <input type="text" id="bundle-gif-name" placeholder="e.g., Exercise Name Demonstration">
                                </div>

                            <div class="form-group">
                                <label for="bundle-gif-description">Description:</label>
                                <textarea id="bundle-gif-description" rows="2" placeholder="Multi-resolution GIF demonstration set for..."></textarea>
                            </div>

                            <div class="form-group">
                                <label>GIF Files (Different Resolutions):</label>
                                <div id="bundle-gif-files-container">
                                    ${[180, 360, 720, 1080].map((res, idx) => `
                                        <div class="gif-file-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; align-items: end; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fafafa;">
                                            <div>
                                                <label>${res}p GIF File:</label>
                                                <input type="file" class="bundle-gif-file-input" data-resolution="${res}p" accept="image/gif" onchange="updateBundleGifFileInfo(this)">
                                            </div>
                                            <div>
                                                <label>Resolution:</label>
                                                <input type="text" class="bundle-gif-resolution-label" value="${res}p" readonly style="background: #eee;">
                                            </div>
                                            <div>
                                                <label>Width:</label>
                                                <input type="number" class="bundle-gif-width" value="${res}" readonly style="background: #eee;">
                                            </div>
                                            <div>
                                                <label>Height:</label>
                                                <input type="number" class="bundle-gif-height" value="${res}" readonly style="background: #eee;">
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="bundle-gif-framerate">Frame Rate (fps):</label>
                                <input type="number" id="bundle-gif-framerate" value="4" min="1" max="60">
                            </div>

                            <div class="form-group">
                                <label for="bundle-gif-duration">Duration (seconds):</label>
                                <input type="number" id="bundle-gif-duration" value="3" min="1">
                            </div>

                            <div class="form-group">
                                <label for="bundle-gif-storage">Storage Type:</label>
                                <select id="bundle-gif-storage" onchange="updateBundleGifStorageType()">
                                    <option value="gun">GUN + BitTorrent</option>
                                    <option value="arweave">Arweave (Permanent)</option>
                                </select>
                            </div>
                            
                            <div class="form-group hidden" id="bundle-gif-access-group">
                                <label for="bundle-gif-access">Access Level:</label>
                                <select id="bundle-gif-access" onchange="updateBundleGifAccess()">
                                    <option value="public">Public</option>
                                    <option value="organization" selected>Organization</option>
                                    <option value="private">Private</option>
                                </select>
                            </div>
                            
                            <div class="form-group hidden" id="bundle-gif-org-group">
                                <label for="bundle-gif-org">Organization:</label>
                                <select id="bundle-gif-org"></select>
                            </div>
                            </div>
                            <!-- End of bundle-gif-create-section -->
                        </div>
                    </div>

                    <!-- Section 3: Equipment Required -->
                    <div class="bundle-section" style="border: 2px solid #f3e5f5; border-radius: 12px; padding: 20px; margin-bottom: 20px; background: white;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 18px;">3</div>
                            <h4 style="margin: 0; flex: 1;">🏋️ Equipment Required</h4>
                        </div>
                        
                        <div id="bundle-equipment-container">
                            <!-- Equipment items will be added here -->
                        </div>
                        
                        <button type="button" onclick="addBundleEquipmentItem()" class="btn-small" style="margin-top: 10px;">
                            + Add Equipment
                        </button>
                    </div>

                    <!-- Publish All Button -->
                    <div style="position: sticky; bottom: 20px; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 -4px 12px rgba(0,0,0,0.1); margin-top: 30px;">
                        <button onclick="publishExerciseBundle()" class="btn-primary" id="bundle-publish-btn" style="width: 100%; padding: 16px; font-size: 16px; font-weight: 600;">
                            🚀 Publish Complete Exercise Bundle
                        </button>
                        <div style="text-align: center; margin-top: 10px; font-size: 14px; color: #666;">
                            <span id="bundle-publish-estimate">Includes exercise, demo GIFs, and equipment</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function createExerciseInterface() {
            return `
                <div class="publish-form">
                    <h3>🏋️ Exercise Publishing</h3>
                    
                    <!-- Exercise Basic Info -->
                    <div class="form-group">
                        <label for="exercise-name">Exercise Name:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="exercise-name" required placeholder="e.g., Barbell Bench Press" style="flex: 1;" oninput="onNameFieldChange('exercise', this.value)">
                            <div id="exercise-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('exercise')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('exercise')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="exercise-description">Description:</label>
                        <textarea id="exercise-description" placeholder="Brief description of the exercise..." rows="3"></textarea>
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="exercise-language">Language:</label>
                        <select id="exercise-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Exercise Avatar (DID reference) -->
                    <div class="form-group">
                        <label for="exercise-avatar">Avatar/Demo Media DID:</label>
                        <input type="text" id="exercise-avatar" placeholder="did:gun:media:... or did:arweave:...">
                        <small>Reference to a media record (GIF, video) demonstrating the exercise</small>
                    </div>

                    <!-- Instructions -->
                    <div class="form-group">
                        <label for="exercise-instructions">Instructions (one per line):</label>
                        <textarea id="exercise-instructions" placeholder="Lie flat on bench with feet on the floor&#10;Grip bar slightly wider than shoulder-width&#10;Lower bar to mid-chest with control&#10;Press bar back up to starting position" rows="8"></textarea>
                        <small>Step-by-step instructions for performing the exercise</small>
                    </div>

                    <!-- Muscle Groups -->
                    <div class="form-group">
                        <label for="exercise-muscle-groups">Muscle Groups (comma-separated):</label>
                        <input type="text" id="exercise-muscle-groups" placeholder="chest, triceps, shoulders">
                        <small>Primary muscle groups targeted by this exercise</small>
                    </div>

                    <!-- Difficulty Level -->
                    <div class="form-group">
                        <label for="exercise-difficulty">Difficulty:</label>
                        <select id="exercise-difficulty">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate" selected>Intermediate</option>
                            <option value="advanced">Advanced</option>
                        </select>
                    </div>

                    <!-- Exercise Category -->
                    <div class="form-group">
                        <label for="exercise-category">Category:</label>
                        <select id="exercise-category">
                            <option value="strength" selected>Strength</option>
                            <option value="cardio">Cardio</option>
                            <option value="flexibility">Flexibility</option>
                        </select>
                    </div>

                    <!-- Equipment Required -->
                    <div class="form-group">
                        <label>Equipment Required:</label>
                        <div id="equipment-required-container">
                            <div class="equipment-row" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: end;">
                                <select class="equipment-select" style="flex: 1;">
                                    <option value="">Loading equipment...</option>
                                </select>
                                <button type="button" onclick="addEquipmentRow('equipment-required-container')" class="btn-small" title="Add another equipment">+</button>
                            </div>
                        </div>
                        <small>Equipment needed to perform this exercise</small>
                    </div>

                    <!-- Alternative Equipment -->
                    <div class="form-group">
                        <label>Alternative Equipment:</label>
                        <div id="alternative-equipment-container">
                            <div class="equipment-row" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: end;">
                                <select class="equipment-select" style="flex: 1;">
                                    <option value="">Loading equipment...</option>
                                </select>
                                <button type="button" onclick="addEquipmentRow('alternative-equipment-container')" class="btn-small" title="Add another equipment">+</button>
                            </div>
                        </div>
                        <small>Alternative equipment that can be used for this exercise</small>
                    </div>

                    <!-- Exercise Type -->
                    <div class="form-group">
                        <label for="exercise-type">Exercise Type:</label>
                        <select id="exercise-type">
                            <option value="main" selected>Main</option>
                            <option value="warmup">Warm-Up</option>
                            <option value="cooldown">Cool-Down</option>
                        </select>
                    </div>

                    <!-- Exercise Settings -->
                    <div class="form-group">
                        <label for="exercise-measurement-type">Measurement Type:</label>
                        <select id="exercise-measurement-type" onchange="updateExerciseMeasurementFields()">
                            <option value="reps" selected>Reps</option>
                            <option value="timed">Time (seconds)</option>
                            <option value="hold">Hold</option>
                            <option value="maxdur">Maximum Duration</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="exercise-duration">Estimated Duration (minutes):</label>
                        <input type="number" id="exercise-duration" min="1" max="60" value="5">
                    </div>

                    <!-- Conditional fields based on measurement type -->
                    <div id="exercise-reps-fields" class="form-group" style="display: flex; gap: 15px;">
                        <div style="flex: 1;">
                            <label for="exercise-recommended-sets">Recommended Sets:</label>
                            <input type="number" id="exercise-recommended-sets" min="1" max="10" value="3">
                        </div>
                        <div style="flex: 1;">
                            <label for="exercise-recommended-reps">Recommended Reps:</label>
                            <input type="number" id="exercise-recommended-reps" min="1" max="100" value="8">
                        </div>
                    </div>

                    <div id="exercise-time-fields" class="form-group" style="display: none;">
                        <label for="exercise-target-duration">Target Duration (seconds):</label>
                        <input type="number" id="exercise-target-duration" min="1" max="3600" value="30">
                    </div>

                    <!-- Exercise Flags -->
                    <div class="form-group">
                        <label>Exercise Properties:</label>
                        <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 15px;">
                            <label><input type="checkbox" id="exercise-bodyweight"> Bodyweight Exercise</label>
                        </div>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="exercise-access-level">Access Level:</label>
                        <select id="exercise-access-level" onchange="updateExerciseAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this exercise record</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="exercise-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="exercise-organization">Select Organization:</label>
                        <select id="exercise-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this exercise belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="exercise-tags">Tags:</label>
                        <input type="text" id="exercise-tags" placeholder="gain muscle, get stronger, general fitness">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishExercise()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏋️ Publish Exercise
                    </button>
                </div>
            `;
        }

        function createFitnessEquipmentInterface() {
            return `
                <div class="publish-form">
                    <h3>🏋️‍♀️ Fitness Equipment Publishing</h3>
                    
                    <!-- Equipment Basic Info -->
                    <div class="form-group">
                        <label for="equipment-name">Equipment Name:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <input type="text" id="equipment-name" required placeholder="e.g., Dumbbells" style="flex: 1;" oninput="onNameFieldChange('fitnessEquipment', this.value)">
                            <div id="fitnessEquipment-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('fitnessEquipment')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('fitnessEquipment')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="equipment-description">Description:</label>
                        <textarea id="equipment-description" placeholder="Brief description of the equipment..." rows="3"></textarea>
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="equipment-language">Language:</label>
                        <select id="equipment-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Equipment Avatar (DID reference) -->
                    <div class="form-group">
                        <label for="equipment-avatar">Equipment Image DID:</label>
                        <input type="text" id="equipment-avatar" placeholder="did:gun:media:... or did:arweave:...">
                        <small>Reference to a media record showing the equipment</small>
                    </div>

                    <!-- Equipment Category -->
                    <div class="form-group">
                        <label for="equipment-category">Category:</label>
                        <select id="equipment-category">
                            <option value="weights">Weights</option>
                            <option value="cardio">Cardio</option>
                            <option value="bodyweight">Bodyweight</option>
                            <option value="flexibility">Flexibility</option>
                            <option value="functional">Functional</option>
                            <option value="accessories">Accessories</option>
                        </select>
                    </div>

                    <!-- Equipment Subcategory -->
                    <div class="form-group">
                        <label for="equipment-subcategory">Subcategory:</label>
                        <input type="text" id="equipment-subcategory" placeholder="e.g., Free Weights, Resistance Bands">
                    </div>

                    <!-- Muscle Groups -->
                    <div class="form-group">
                        <label for="equipment-muscle-groups">Muscle Groups (comma-separated):</label>
                        <input type="text" id="equipment-muscle-groups" placeholder="chest, back, shoulders, arms, legs">
                        <small>Muscle groups this equipment can target</small>
                    </div>

                    <!-- Exercise Types -->
                    <div class="form-group">
                        <label for="equipment-exercise-types">Exercise Types (comma-separated):</label>
                        <input type="text" id="equipment-exercise-types" placeholder="strength, functional, rehabilitation">
                        <small>Types of exercises this equipment supports</small>
                    </div>

                    <!-- Equipment Properties -->
                    <div class="form-group">
                        <label for="equipment-difficulty">Difficulty Level:</label>
                        <select id="equipment-difficulty">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate">Intermediate</option>
                            <option value="advanced">Advanced</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-space-required">Space Required:</label>
                        <select id="equipment-space-required">
                            <option value="minimal">Minimal Space</option>
                            <option value="small">Small Space</option>
                            <option value="medium">Medium Space</option>
                            <option value="large">Large Space</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-portability">Portability:</label>
                        <select id="equipment-portability">
                            <option value="portable">Portable</option>
                            <option value="semi_portable">Semi-Portable</option>
                            <option value="stationary">Stationary</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-price-range">Price Range:</label>
                        <select id="equipment-price-range">
                            <option value="budget">Budget ($0-50)</option>
                            <option value="mid_range">Mid-Range ($50-200)</option>
                            <option value="premium">Premium ($200-500)</option>
                            <option value="professional">Professional ($500+)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="equipment-maintenance">Maintenance Level:</label>
                        <select id="equipment-maintenance">
                            <option value="none">No Maintenance</option>
                            <option value="low">Low Maintenance</option>
                            <option value="medium">Medium Maintenance</option>
                            <option value="high">High Maintenance</option>
                        </select>
                    </div>

                    <!-- Alternatives -->
                    <div class="form-group">
                        <label for="equipment-alternatives">Alternatives (comma-separated):</label>
                        <input type="text" id="equipment-alternatives" placeholder="Resistance bands, Kettlebells, Cable machine">
                        <small>Alternative equipment that can provide similar benefits</small>
                    </div>

                    <!-- Safety -->
                    <div class="form-group">
                        <label for="equipment-safety">Safety Considerations:</label>
                        <textarea id="equipment-safety" placeholder="Safety tips and considerations for using this equipment..." rows="3"></textarea>
                    </div>

                    <!-- Equipment Flags -->
                    <div class="form-group">
                        <label>Equipment Properties:</label>
                        <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 15px;">
                            <label><input type="checkbox" id="equipment-beginner-friendly"> Beginner Friendly</label>
                            <label><input type="checkbox" id="equipment-home-gym"> Home Gym Suitable</label>
                            <label><input type="checkbox" id="equipment-commercial"> Commercial Grade</label>
                        </div>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="equipment-access-level">Access Level:</label>
                        <select id="equipment-access-level" onchange="updateEquipmentAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this equipment record</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="equipment-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="equipment-organization">Select Organization:</label>
                        <select id="equipment-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this equipment belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="equipment-tags">Tags:</label>
                        <input type="text" id="equipment-tags" placeholder="weights, dumbbells, beginner, home-gym">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishFitnessEquipment()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🏋️‍♀️ Publish Equipment
                    </button>
                </div>
            `;
        }

        function createMediaInterface() {
            return `
                <div class="publish-form">
                    <h3>📁 Media File Publishing</h3>
                    
                    <div class="info-box" style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>🌐 BitTorrent + OIP Media Distribution</h4>
                        <p>Upload media files that will be:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>📋 <strong>Formatted as proper OIP records</strong> (image/video/audio types)</li>
                            <li>🔒 <strong>Stored with HD wallet ownership</strong> and access control</li>
                            <li>🌍 <strong>Distributed via BitTorrent</strong> for peer-to-peer sharing</li>
                            <li>⚡ <strong>Streamable via HTTP</strong> with range request support</li>
                            <li>🔍 <strong>Indexed in Elasticsearch</strong> for search and discovery</li>
                        </ul>
                        <p><strong>Note:</strong> Record type (image/video/audio) is automatically determined by file type.</p>
                    </div>

                    <!-- File Upload -->
                    <div class="form-group">
                        <label for="media-file">Select Media File:</label>
                        <input type="file" id="media-file" accept="image/*,video/*,audio/*" required onchange="updateMediaFilePreview()">
                        <small>Supported: Images (JPG, PNG, GIF, WebP), Videos (MP4, WebM, AVI), Audio (MP3, WAV, OGG, FLAC)</small>
                    </div>

                    <!-- Detected File Type Display -->
                    <div id="detected-file-type" class="form-group hidden" style="background: #f0f4ff; padding: 10px; border-radius: 6px; border: 1px solid #c7d2fe;">
                        <label>Detected Record Type:</label>
                        <div id="detected-type-display" style="font-weight: bold; color: #3730a3;"></div>
                        <small id="detected-type-description"></small>
                    </div>

                    <!-- Media Basic Info -->
                    <div class="form-group">
                        <label for="media-name">Media Title:</label>
                        <div style="display: flex; gap: 10px; align-items: flex-end;">
                            <div style="flex: 1;">
                                <input type="text" id="media-name" placeholder="Descriptive title for the media file" style="width: 100%;" oninput="onNameFieldChange('media', this.value)">
                                <small>If empty, will use the original filename</small>
                            </div>
                            <div id="media-smart-buttons" class="smart-buttons" style="display: none; gap: 8px;">
                                <button type="button" class="btn-small btn-secondary" onclick="copyFromLatestRecord('media')" title="Copy data from the most recent matching record">
                                    📋 Copy From Latest
                                </button>
                                <button type="button" class="btn-small" onclick="fillInWithAI('media')" title="Use AI to fill in remaining fields">
                                    🤖 Fill In With AI
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="media-description">Description:</label>
                        <textarea id="media-description" placeholder="Brief description of the media content..." rows="2"></textarea>
                    </div>

                    <!-- Language Selection -->
                    <div class="form-group">
                        <label for="media-language">Language:</label>
                        <select id="media-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="zh">Chinese</option>
                            <option value="ja">Japanese</option>
                            <option value="ko">Korean</option>
                            <option value="ar">Arabic</option>
                            <option value="hi">Hindi</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="media-access-level">Access Level:</label>
                        <select id="media-access-level" onchange="updateMediaAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this media file</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="media-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="media-organization">Select Organization:</label>
                        <select id="media-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this media belongs to</small>
                    </div>

                    <!-- Multi-Network Storage Options -->
                    <div class="form-group" style="background: #e8f5e8; padding: 15px; border-radius: 8px; border: 1px solid #4caf50;">
                        <h4 style="margin: 0 0 15px 0; color: #2e7d32;">🌐 Multi-Network Storage</h4>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="media-enable-ipfs" checked> Store on IPFS
                            </label>
                            <small style="display: block; color: #555; margin-top: 2px;">Enable IPFS storage for decentralized distribution</small>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>
                                <input type="checkbox" id="media-enable-web" checked> Store on Web Server
                            </label>
                            <small style="display: block; color: #555; margin-top: 2px;">Enable direct HTTP access via web server</small>
                        </div>
                        <div>
                            <label>
                                <input type="checkbox" id="media-enable-arweave"> Store on Arweave
                            </label>
                            <small style="display: block; color: #555; margin-top: 2px;">Enable permanent storage on Arweave blockchain (costs AR tokens)</small>
                        </div>
                        <small style="display: block; margin-top: 10px; color: #666; font-style: italic;">
                            BitTorrent is always enabled. Multiple storage options provide redundancy and different access methods.
                        </small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="media-tags">Tags:</label>
                        <input type="text" id="media-tags" placeholder="tag1, tag2, tag3">
                        <small>Comma-separated tags for categorization</small>
                    </div>

                    <!-- NSFW Toggle -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="media-nsfw"> NSFW Content
                        </label>
                    </div>

                    <!-- Upload Progress -->
                    <div id="media-upload-progress" class="upload-progress hidden" style="margin: 15px 0;">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text">Ready to upload...</div>
                    </div>

                    <!-- Media Preview -->
                    <div id="media-preview" class="media-preview hidden" style="margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                        <h4>Media Preview:</h4>
                        <div id="media-preview-content"></div>
                        <div id="media-info" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                    </div>

                    <button onclick="publishMedia()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📁 Upload & Publish Media
                    </button>
                </div>
            `;
        }

        function createMultiResolutionGifInterface() {
            return `
                <div class="publish-form">
                    <h3>🎬 Multi-Resolution GIF Collection</h3>
                    
                    <div class="info-box" style="background: #fff3e0; border: 1px solid #ff9800; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4>📚 Exercise Demo Collections</h4>
                        <p>Create a collection of GIF files at different resolutions for exercise demonstrations. Perfect for:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>🎯 <strong>Exercise tutorials</strong> with multiple quality options</li>
                            <li>📱 <strong>Adaptive streaming</strong> based on device/connection</li>
                            <li>💾 <strong>Storage optimization</strong> with resolution choices</li>
                        </ul>
                        <p><strong>Note:</strong> You must first upload individual GIF files as media records, then reference them here.</p>
                    </div>

                    <!-- Collection Basic Info -->
                    <div class="form-group">
                        <label for="gif-collection-name">Collection Name:</label>
                        <input type="text" id="gif-collection-name" required placeholder="e.g., Barbell Bench Press GIF Collection">
                    </div>

                    <div class="form-group">
                        <label for="gif-collection-description">Description:</label>
                        <textarea id="gif-collection-description" placeholder="Multi-resolution GIF demonstration set for..." rows="2"></textarea>
                    </div>

                    <!-- Input Method Selection -->
                    <div class="form-group">
                        <label for="gif-input-method">Input Method:</label>
                        <select id="gif-input-method" onchange="updateGifInputMethod()">
                            <option value="upload">Upload GIF Files</option>
                            <option value="manual">Manual DID Entry</option>
                        </select>
                        <small>Choose whether to upload files or enter existing media DIDs</small>
                    </div>

                    <!-- File Upload Interface -->
                    <div id="gif-upload-interface" class="form-group">
                        <label>GIF Files (Different Resolutions):</label>
                        <div id="gif-files-container">
                            <div class="gif-file-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 40px; gap: 10px; margin-bottom: 10px; align-items: end; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fafafa;">
                                <div>
                                    <label>GIF File:</label>
                                    <input type="file" class="gif-file-input" accept="image/gif" onchange="updateGifFileInfo(this)">
                                </div>
                                <div>
                                    <label>Resolution Label:</label>
                                    <input type="text" class="gif-resolution-label" placeholder="180p">
                                </div>
                                <div>
                                    <label>Width (px):</label>
                                    <input type="number" class="gif-width" placeholder="320">
                                </div>
                                <div>
                                    <label>Height (px):</label>
                                    <input type="number" class="gif-height" placeholder="180">
                                </div>
                                <button type="button" onclick="addGifFileRow()" class="btn-small" title="Add another resolution">+</button>
                            </div>
                        </div>
                        <button type="button" onclick="addGifFileRow()" style="margin-top: 10px;">+ Add Another Resolution</button>
                        <small>Upload GIF files at different resolutions. Dimensions will be auto-detected.</small>
                    </div>

                    <!-- Manual DID Interface -->
                    <div id="gif-manual-interface" class="form-group hidden">
                        <label>GIF Media References:</label>
                        <div id="gif-refs-container">
                            <div class="gif-ref-row" style="display: flex; gap: 10px; margin-bottom: 10px; align-items: end;">
                                <div style="flex: 2;">
                                    <label>Media DID:</label>
                                    <input type="text" class="gif-media-did" placeholder="did:gun:media:...">
                                </div>
                                <div style="flex: 1;">
                                    <label>Resolution Label:</label>
                                    <input type="text" class="gif-resolution-label" placeholder="180p">
                                </div>
                                <div style="flex: 1;">
                                    <label>Width (px):</label>
                                    <input type="number" class="gif-width" placeholder="320">
                                </div>
                                <div style="flex: 1;">
                                    <label>Height (px):</label>
                                    <input type="number" class="gif-height" placeholder="180">
                                </div>
                                <button type="button" onclick="addGifReference()" class="btn-small">+</button>
                            </div>
                        </div>
                        <small>Add references to uploaded GIF media files at different resolutions</small>
                    </div>

                    <!-- Animation Settings -->
                    <div class="form-group" style="display: flex; gap: 15px;">
                        <div style="flex: 1;">
                            <label for="gif-frame-rate">Frame Rate (fps):</label>
                            <input type="number" id="gif-frame-rate" min="1" max="60" value="15">
                        </div>
                        <div style="flex: 1;">
                            <label for="gif-duration">Duration (seconds):</label>
                            <input type="number" id="gif-duration" step="0.1" min="0.1" value="8.5">
                        </div>
                        <div style="flex: 1;">
                            <label for="gif-loop-count">Loop Count:</label>
                            <input type="number" id="gif-loop-count" min="0" value="0">
                            <small>0 = infinite</small>
                        </div>
                    </div>

                    <!-- Primary Resolution -->
                    <div class="form-group">
                        <label for="gif-primary-index">Primary Resolution Index:</label>
                        <select id="gif-primary-index">
                            <option value="0">First (0)</option>
                            <option value="1" selected>Second (1)</option>
                            <option value="2">Third (2)</option>
                            <option value="3">Fourth (3)</option>
                        </select>
                        <small>Which resolution to use as the default/primary</small>
                    </div>

                    <!-- Network Distribution Options -->
                    <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                        <h4>🌐 Network Distribution Options</h4>
                        <p style="margin: 10px 0; color: #666; font-size: 14px;">Choose which networks to distribute your GIF files to. Each individual GIF will be uploaded to the selected networks.</p>
                        
                        <div style="display: flex; gap: 20px; margin-top: 15px;">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="gif-enable-ipfs" checked>
                                <span>🌐 IPFS</span>
                                <small style="color: #666;">(Decentralized storage)</small>
                            </label>
                            
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="gif-enable-web" checked>
                                <span>🌍 Web Server</span>
                                <small style="color: #666;">(Fast HTTP access)</small>
                            </label>
                            
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="gif-enable-arweave" disabled>
                                <span>⛓️ Arweave</span>
                                <small style="color: #999;">(Disabled for GIFs - costs AR tokens)</small>
                            </label>
                        </div>
                        
                        <div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 4px; font-size: 13px;">
                            <strong>💡 Note:</strong> BitTorrent distribution is always enabled for P2P sharing. 
                            IPFS and Web Server options provide additional access methods for better performance and availability.
                        </div>
                    </div>

                    <!-- Access Level -->
                    <div class="form-group">
                        <label for="gif-access-level">Access Level:</label>
                        <select id="gif-access-level" onchange="updateGifAccessLevel()">
                            <option value="private">Private (Only you)</option>
                            <option value="organization" selected>Organization (Your team/org)</option>
                            <option value="public">Public (Everyone)</option>
                        </select>
                        <small>Controls who can access this GIF collection</small>
                    </div>

                    <!-- Organization Selection (shown when Organization access level is selected) -->
                    <div id="gif-organization-selection" class="form-group" style="background: #f0f4ff; padding: 15px; border-radius: 8px; border: 1px solid #c7d2fe;">
                        <label for="gif-organization">Select Organization:</label>
                        <select id="gif-organization" required>
                            <option value="">Loading organizations...</option>
                        </select>
                        <small>Choose which organization this GIF collection belongs to</small>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="gif-tags">Tags:</label>
                        <input type="text" id="gif-tags" placeholder="exercise-demo, multi-resolution, barbell-bench-press">
                        <small>Tags for categorization and search</small>
                    </div>

                    <button onclick="publishMultiResolutionGif()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="gif-publish-text">🎬 Publish GIF Collection</span>
                    </button>
                </div>
            `;
        }

        // Master Audio Player functions
        let currentAudioUrl = null;
        let currentAudioTitle = null;
        let currentAudioType = null;
        let currentPlayingIndex = null;

        function playAudioInMaster(audioUrl, title, recordType, recordIndex) {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            const audioTitle = document.getElementById('audio-title');
            const audioMeta = document.getElementById('audio-meta');
            const playBtn = document.getElementById('master-play-btn');
            
            // Update all audio buttons
            document.querySelectorAll('.audio-play-btn').forEach(btn => {
                btn.classList.remove('playing');
                btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
            });
            
            // If same audio is playing, toggle it
            if (currentAudioUrl === audioUrl && !masterAudio.paused) {
                masterAudio.pause();
                return;
            }
            
            // Set new audio
            currentAudioUrl = audioUrl;
            currentAudioTitle = title;
            currentAudioType = recordType;
            currentPlayingIndex = recordIndex;
            
            masterAudio.src = audioUrl;
            
            // Enhanced display for podcast episodes
            if (recordType === 'podcast' && currentRecords[recordIndex]?.data?.podcast?.show) {
                const podcastShow = currentRecords[recordIndex].data.podcast.show;
                audioTitle.textContent = title;
                audioMeta.textContent = `🎙️ ${podcastShow} • Loading...`;
            } else {
                audioTitle.textContent = title;
                audioMeta.textContent = `${recordType} • Loading...`;
            }
            
            // Show master player
            masterPlayer.classList.add('visible');
            
            // Update button states
            const currentBtn = document.getElementById(`audioBtn-${recordIndex}`);
            if (currentBtn) {
                currentBtn.classList.add('playing');
                if (recordType === 'podcast') {
                    currentBtn.innerHTML = '<span>⏸️</span><span>Playing Episode...</span>';
                } else {
                    currentBtn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                }
            }
            
            // Play audio
            masterAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                if (recordType === 'podcast') {
                    audioMeta.textContent = `🎙️ ${currentRecords[recordIndex]?.data?.podcast?.show || 'Podcast'} • Error loading episode`;
                } else {
                    audioMeta.textContent = `${recordType} • Error loading audio`;
                }
            });
            
            playBtn.textContent = '⏸️';
        }

        function toggleAudioPlayback() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            
            if (masterAudio.paused) {
                masterAudio.play();
                playBtn.textContent = '⏸️';
                updateCurrentPlayingButton(true);
            } else {
                masterAudio.pause();
                playBtn.textContent = '▶️';
                updateCurrentPlayingButton(false);
            }
        }

        function stopAudio() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            masterAudio.pause();
            masterAudio.currentTime = 0;
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Stopped`;
            updateCurrentPlayingButton(false);
        }

        function closeMasterPlayer() {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            
            masterAudio.pause();
            masterPlayer.classList.remove('visible');
            updateCurrentPlayingButton(false);
            
            currentAudioUrl = null;
            currentAudioTitle = null;
            currentAudioType = null;
            currentPlayingIndex = null;
        }

        function updateCurrentPlayingButton(isPlaying) {
            if (currentPlayingIndex !== null) {
                const btn = document.getElementById(`audioBtn-${currentPlayingIndex}`);
                if (btn) {
                    if (isPlaying) {
                        btn.classList.add('playing');
                        if (currentAudioType === 'podcast') {
                            btn.innerHTML = '<span>⏸️</span><span>Playing Episode...</span>';
                        } else {
                            btn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                        }
                    } else {
                        btn.classList.remove('playing');
                        if (currentAudioType === 'podcast') {
                            btn.innerHTML = '<span>🎙️</span><span>Play Episode</span>';
                        } else {
                            btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
                        }
                    }
                }
            }
        }

        function updateAudioProgress() {
            const masterAudio = document.getElementById('master-audio');
            const progressBar = document.getElementById('audio-progress-bar');
            const timeDisplay = document.getElementById('audio-time');
            
            if (masterAudio.duration) {
                const progress = (masterAudio.currentTime / masterAudio.duration) * 100;
                progressBar.style.width = progress + '%';
                
                const currentTime = formatTime(masterAudio.currentTime);
                const totalTime = formatTime(masterAudio.duration);
                timeDisplay.textContent = `${currentTime} / ${totalTime}`;
            }
        }

        function seekAudio(event) {
            const masterAudio = document.getElementById('master-audio');
            const progressContainer = event.currentTarget;
            const rect = progressContainer.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            
            if (masterAudio.duration) {
                masterAudio.currentTime = percent * masterAudio.duration;
            }
        }

        function onAudioLoaded() {
            const audioMeta = document.getElementById('audio-meta');
            const masterAudio = document.getElementById('master-audio');
            
            if (masterAudio.duration) {
                const duration = formatTime(masterAudio.duration);
                
                if (currentAudioType === 'podcast' && currentPlayingIndex !== null && currentRecords[currentPlayingIndex]?.data?.podcast?.show) {
                    const podcastShow = currentRecords[currentPlayingIndex].data.podcast.show;
                    audioMeta.textContent = `🎙️ ${podcastShow} • Duration: ${duration}`;
                } else {
                    audioMeta.textContent = `${currentAudioType} • Duration: ${duration}`;
                }
            }
        }

        function onAudioEnded() {
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            playBtn.textContent = '▶️';
            
            if (currentAudioType === 'podcast' && currentPlayingIndex !== null && currentRecords[currentPlayingIndex]?.data?.podcast?.show) {
                const podcastShow = currentRecords[currentPlayingIndex].data.podcast.show;
                audioMeta.textContent = `🎙️ ${podcastShow} • Episode Finished`;
            } else {
                audioMeta.textContent = `${currentAudioType} • Finished`;
            }
            
            updateCurrentPlayingButton(false);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // AI Chat State Management
        let chatState = {
            isInitialized: false,
            isProcessing: false,
            conversation: [],
            selectedModel: 'llama3.2:3b',
            selectedLanguage: 'auto',
            lastQuery: '',
            appliedFilters: {},
            // Follow-up question tracking
            lastSearchResults: [],
            lastSearchSubject: '',
            lastSearchKeywords: [],
            // Voice recording state
            isRecording: false,
            isTranscribing: false,
            isListening: false,
            mediaStream: null,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            vadInterval: null,
            silenceTimeout: null,
            lastSpeechTime: 0
        };

        // Voice variables removed - now using unified enhanced system with currentFilters, currentRecords, etc.

        // AI Chat Feature Initialization
        async function initializeVoiceFeatures() {
            if (chatState.isInitialized) return Promise.resolve();
            
            console.log('[Chat] Initializing AI chat features...');
            updateAIStatus('Initializing...');
            
            try {
                // Initialize multi-tag filtering system
                clearAllTagFilters();
                
                // Initialize view mode
                document.getElementById('voice-view-as').value = currentViewMode;
                
                // Initialize voice system
                await loadVoiceSettings();
                
                updateAIStatus('Ready to answer questions!');
                
                chatState.isInitialized = true;
                
                // Load initial records for voice tab
                await loadVoiceRecords(true);
                
                console.log('[Chat] AI chat features initialized successfully with multi-tag system and view modes');
                
                return Promise.resolve();
                
            } catch (error) {
                console.error('[Chat] Initialization failed:', error);
                updateAIStatus('AI chat unavailable');
                return Promise.reject(error);
            }
        }


        // Voice Engine Configuration (based on working index.html)
        const voiceConfig = {
            enabled: true,
            selectedEngine: 'edge_tts',
            baseUrl: window.location.origin,
            // Chatterbox-specific settings
            chatterbox: {
                selectedVoice: 'female_expressive',
                exaggeration: 0.5,       // 50% emotion for balanced speech
                cfg_weight: 0.5,         // Balanced pacing
                voiceCloning: {
                    enabled: false,
                    audioFile: null,
                    fileName: null
                }
            },
            // Edge TTS-specific settings
            edge: {
                selectedVoice: 'en-GB-RyanNeural',
                speed: 1.0,              // Normal speed
                pitch: 0,                // No pitch adjustment
                volume: 0                // No volume adjustment
            },
            // ElevenLabs-specific settings
            elevenlabs: {
                selectedVoice: 'onwK4e9ZLuTAKqWW03F9',  // Daniel voice ID
                model_id: 'eleven_turbo_v2',           // Fast turbo model
                stability: 0.5,                        // Balanced stability
                similarity_boost: 0.75,                // Good similarity
                style: 0.0,                           // Neutral style
                use_speaker_boost: true               // Enhanced clarity
            }
        };
        
        // Available voices for each engine (loaded dynamically)
        let availableVoices = {
            chatterbox: [],
            edge_tts: [],
            elevenlabs: []
        };

        // Switch between voice engines
        async function switchVoiceEngine() {
            const selectedEngine = document.getElementById('voice-engine').value;
            voiceConfig.selectedEngine = selectedEngine;
            
            console.log(`🔄 Switching to engine: ${selectedEngine}`);
            
            // Update UI visibility
            if (selectedEngine === 'chatterbox') {
                document.getElementById('chatterbox-controls').style.display = 'block';
                document.getElementById('edge-controls').style.display = 'none';
                document.getElementById('elevenlabs-controls').style.display = 'none';
                document.getElementById('tts-enable-label').textContent = 'Enable Chatterbox TTS';
            } else if (selectedEngine === 'edge_tts') {
                document.getElementById('chatterbox-controls').style.display = 'none';
                document.getElementById('edge-controls').style.display = 'block';
                document.getElementById('elevenlabs-controls').style.display = 'none';
                document.getElementById('tts-enable-label').textContent = 'Enable Edge TTS';
            } else if (selectedEngine === 'elevenlabs') {
                document.getElementById('chatterbox-controls').style.display = 'none';
                document.getElementById('edge-controls').style.display = 'none';
                document.getElementById('elevenlabs-controls').style.display = 'block';
                document.getElementById('tts-enable-label').textContent = 'Enable ElevenLabs TTS';
            }
            
            // Load voices for selected engine
            await populateVoiceDropdown(selectedEngine);
            updateAIStatus(`🔄 Switched to ${selectedEngine === 'chatterbox' ? 'Chatterbox TTS' : selectedEngine === 'edge_tts' ? 'Edge TTS' : 'ElevenLabs'}`);
        }

        // Load available voices from API
        async function loadAvailableVoices() {
            try {
                // Load all voices from the single voices endpoint
                const response = await fetch('/api/alfred/voices');
                if (response.ok) {
                    const data = await response.json();
                    const voices = data.voices || [];
                    
                    // Separate voices by engine (case-insensitive)
                    availableVoices.chatterbox = voices.filter(v => 
                        v.engine && (v.engine.toLowerCase() === 'chatterbox' || v.engine.toLowerCase() === 'chatterbox tts')
                    );
                    availableVoices.edge_tts = voices.filter(v => 
                        v.engine && (v.engine.toLowerCase() === 'edge tts' || v.engine.toLowerCase() === 'edge_tts')
                    );
                    
                    // Add ElevenLabs voices (hardcoded popular ones)
                    availableVoices.elevenlabs = [
                        { id: 'pNInz6obpgDQGcFmaJgB', name: 'Adam (Male, Deep)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'EXAVITQu4vr4xnSDxMaL', name: 'Bella (Female, Sweet)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'VR6AewLTigWG4xSOukaG', name: 'Arnold (Male, Crisp)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'pMsXgVXv3BLzUgSXRplE', name: 'Freya (Female, Conversational)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'onwK4e9ZLuTAKqWW03F9', name: 'Daniel (Male, British)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'CYw3kZ02Hs0563khs1Fj', name: 'Gigi (Female, Childlike)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'bVMeCyTHy58xNoL34h3p', name: 'Jeremy (Male, American)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'XB0fDUnXU5powFXDhCwa', name: 'Charlotte (Female, Seductive)', gender: 'female', engine: 'elevenlabs' },
                        { id: 'JBFqnCBsd6RMkjVDRZzb', name: 'George (Male, Raspy)', gender: 'male', engine: 'elevenlabs' },
                        { id: 'oWAxZDx7w5VEj9dCyTzz', name: 'Grace (Female, Calm)', gender: 'female', engine: 'elevenlabs' }
                    ];
                    
                    console.log(`🎵 Loaded ${availableVoices.chatterbox.length} Chatterbox voices, ${availableVoices.edge_tts.length} Edge TTS voices, and ${availableVoices.elevenlabs.length} ElevenLabs voices`);
                    
                    // Populate dropdown for default engine
                    await populateVoiceDropdown(voiceConfig.selectedEngine);
                } else {
                    console.error('Failed to load voices:', response.status, await response.text());
                    updateAIStatus('⚠️ Failed to load voice options');
                }
                
            } catch (error) {
                console.error('Failed to load voices:', error);
                updateAIStatus('⚠️ Failed to load voice options');
            }
        }
        
        // Populate voice dropdown based on selected engine
        async function populateVoiceDropdown(engine) {
            const voiceSelect = document.getElementById('voice-select');
            voiceSelect.innerHTML = ''; // Clear existing options
            
            const voices = availableVoices[engine] || [];
            
            if (voices.length === 0) {
                voiceSelect.innerHTML = '<option value="">No voices available</option>';
                return;
            }
            
            // Group voices by gender for better organization
            const groupedVoices = {
                female: voices.filter(v => v.gender === 'female'),
                male: voices.filter(v => v.gender === 'male'),
                other: voices.filter(v => !['female', 'male'].includes(v.gender))
            };
            
            // Add female voices
            if (groupedVoices.female.length > 0) {
                const femaleGroup = document.createElement('optgroup');
                femaleGroup.label = 'Female Voices';
                groupedVoices.female.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    femaleGroup.appendChild(option);
                });
                voiceSelect.appendChild(femaleGroup);
            }
            
            // Add male voices
            if (groupedVoices.male.length > 0) {
                const maleGroup = document.createElement('optgroup');
                maleGroup.label = 'Male Voices';
                groupedVoices.male.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    maleGroup.appendChild(option);
                });
                voiceSelect.appendChild(maleGroup);
            }
            
            // Add other voices
            if (groupedVoices.other.length > 0) {
                const otherGroup = document.createElement('optgroup');
                otherGroup.label = 'Other Voices';
                groupedVoices.other.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.id;
                    option.textContent = voice.name;
                    option.title = voice.description || '';
                    otherGroup.appendChild(option);
                });
                voiceSelect.appendChild(otherGroup);
            }
            
            // Set default selection
            if (engine === 'chatterbox') {
                const defaultVoice = voices.find(v => v.id === 'female_expressive') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.chatterbox.selectedVoice = defaultVoice.id;
                }
            } else if (engine === 'edge_tts') {
                const defaultVoice = voices.find(v => v.id === 'en-US-AriaNeural') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.edge.selectedVoice = defaultVoice.id;
                }
            } else if (engine === 'elevenlabs') {
                const defaultVoice = voices.find(v => v.id === 'pNInz6obpgDQGcFmaJgB') || voices[0];
                if (defaultVoice) {
                    voiceSelect.value = defaultVoice.id;
                    voiceConfig.elevenlabs.selectedVoice = defaultVoice.id;
                }
            }
            
            console.log(`🎵 Populated ${voices.length} voices for ${engine}`);
        }

        // Handle voice selection change
        function updateVoiceSelection() {
            const selectedVoice = document.getElementById('voice-select').value;
            const engine = voiceConfig.selectedEngine;
            
            if (engine === 'chatterbox') {
                voiceConfig.chatterbox.selectedVoice = selectedVoice;
            } else if (engine === 'edge_tts') {
                voiceConfig.edge.selectedVoice = selectedVoice;
            } else if (engine === 'elevenlabs') {
                voiceConfig.elevenlabs.selectedVoice = selectedVoice;
            }
            
            console.log(`🎵 Selected voice: ${selectedVoice} for engine: ${engine}`);
        }

        // Chatterbox controls
        function updateEmotion(value) {
            voiceConfig.chatterbox.exaggeration = value / 100;
            document.getElementById('emotion-value').textContent = value + '%';
        }

        function updatePacing(value) {
            voiceConfig.chatterbox.cfg_weight = value / 100;
            document.getElementById('pacing-value').textContent = value + '%';
        }

        // Edge TTS controls
        function updateSpeed(value) {
            voiceConfig.edge.speed = value / 100;
            document.getElementById('speed-value').textContent = value + '%';
        }
        
        function updatePitch(value) {
            voiceConfig.edge.pitch = parseInt(value);
            document.getElementById('pitch-value').textContent = value + 'Hz';
        }
        
        function updateVolume(value) {
            voiceConfig.edge.volume = parseInt(value);
            document.getElementById('volume-value').textContent = value + '%';
        }

        // ElevenLabs controls
        function updateStability(value) {
            voiceConfig.elevenlabs.stability = value / 100;
            document.getElementById('stability-value').textContent = value + '%';
        }
        
        function updateSimilarity(value) {
            voiceConfig.elevenlabs.similarity_boost = value / 100;
            document.getElementById('similarity-value').textContent = value + '%';
        }
        
        function updateStyle(value) {
            voiceConfig.elevenlabs.style = value / 100;
            document.getElementById('style-value').textContent = value + '%';
        }
        
        function updateModel(value) {
            voiceConfig.elevenlabs.model_id = value;
        }

        // Toggle TTS enabled/disabled
        function toggleTTSEnabled() {
            const checkbox = document.getElementById('tts-enabled');
            voiceConfig.enabled = checkbox.checked;
            const engineName = voiceConfig.selectedEngine === 'chatterbox' ? 'Chatterbox TTS' : 
                             voiceConfig.selectedEngine === 'edge_tts' ? 'Edge TTS' : 'ElevenLabs';
            updateAIStatus(voiceConfig.enabled ? `${engineName} Enabled` : 'TTS Disabled');
        }

        // Universal voice synthesis function (handles all engines)
        async function synthesizeResponseWithChatterbox(text) {
            if (!voiceConfig.enabled) {
                console.log('Voice synthesis disabled, skipping');
                return;
            }

            const engine = voiceConfig.selectedEngine;
            
            try {
                if (engine === 'chatterbox') {
                    await synthesizeWithChatterbox(text);
                } else if (engine === 'edge_tts') {
                    await synthesizeWithEdge(text);
                } else if (engine === 'elevenlabs') {
                    await synthesizeWithElevenLabs(text);
                } else {
                    throw new Error(`Unknown engine: ${engine}`);
                }
            } catch (error) {
                console.error(`Voice synthesis failed with ${engine}:`, error);
                
                // Try fallback to Chatterbox if the primary engine fails
                if (engine !== 'chatterbox') {
                    console.log(`[TTS] Falling back to Chatterbox TTS...`);
                    updateAIStatus('🔄 Falling back to Chatterbox TTS...');
                    try {
                        await synthesizeWithChatterbox(text);
                        return; // Successfully fell back
                    } catch (fallbackError) {
                        console.error('[TTS] Chatterbox fallback also failed:', fallbackError);
                        updateAIStatus('❌ All TTS engines failed');
                    }
                } else {
                    updateAIStatus(`❌ ${engine} synthesis failed`);
                }
            }
        }

        // Synthesize with Chatterbox TTS
        async function synthesizeWithChatterbox(text) {
            try {
                updateAIStatus('🎭 Synthesizing with Chatterbox TTS...');
                
                const formData = new FormData();
                formData.append('text', text);
                formData.append('voice_id', voiceConfig.chatterbox.selectedVoice);
                formData.append('exaggeration', voiceConfig.chatterbox.exaggeration.toString());
                formData.append('cfg_weight', voiceConfig.chatterbox.cfg_weight.toString());
                formData.append('engine', 'chatterbox');

                const response = await fetch('/api/alfred/synthesize', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('Chatterbox synthesis failed:', error);
                throw error;
            }
        }

        // Synthesize with Edge TTS
        async function synthesizeWithEdge(text) {
            try {
                updateAIStatus('⚡ Synthesizing with Edge TTS...');
                
                const formData = new FormData();
                formData.append('text', text);
                formData.append('voice_id', voiceConfig.edge.selectedVoice);
                formData.append('speed', voiceConfig.edge.speed.toString());
                formData.append('engine', 'edge_tts');
                
                // Add exaggeration and cfg_weight for compatibility (Edge will convert these to pitch/volume)
                formData.append('exaggeration', (voiceConfig.edge.pitch / 10 + 0.5).toString());
                formData.append('cfg_weight', (voiceConfig.edge.volume / 20 + 0.5).toString());

                const response = await fetch('/api/alfred/synthesize', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('Edge TTS synthesis failed:', error);
                throw error;
            }
        }

        // Synthesize with ElevenLabs
        async function synthesizeWithElevenLabs(text) {
            try {
                updateAIStatus('🚀 Synthesizing with ElevenLabs...');
                
                const requestData = {
                    text: text,
                    voice_settings: {
                        stability: voiceConfig.elevenlabs.stability,
                        similarity_boost: voiceConfig.elevenlabs.similarity_boost,
                        style: voiceConfig.elevenlabs.style,
                        use_speaker_boost: voiceConfig.elevenlabs.use_speaker_boost
                    },
                    model_id: voiceConfig.elevenlabs.model_id
                };
                
                const response = await fetch(`/api/alfred/elevenlabs/${voiceConfig.elevenlabs.selectedVoice}/synthesize`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const audioBlob = await response.blob();
                await playAudio(audioBlob);
                
            } catch (error) {
                console.error('ElevenLabs synthesis failed:', error);
                throw error;
            }
        }

        // Helper function to play audio
        async function playAudio(audioBlob) {
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                updateAIStatus('Ready to answer questions!');
            };
            
            audio.onerror = (error) => {
                console.error('Audio playback failed:', error);
                URL.revokeObjectURL(audioUrl);
                updateAIStatus('Ready to answer questions!');
            };
            
            await audio.play();
            console.log('Audio synthesis and playback successful');
        }

        async function loadVoiceSettings() {
            try {
                console.log('🎵 Initializing voice system...');
                
                // Load available voices
                await loadAvailableVoices();
                
                // Initialize voice controls
                await switchVoiceEngine();
                
                console.log('🎵 Voice system initialized successfully');
                
            } catch (error) {
                console.error('🎵 Failed to initialize voice system:', error);
                updateAIStatus('⚠️ Voice system initialization failed');
            }
        }

        // Legacy function removed - replaced by comprehensive voice engine system

        // DEPRECATED: loadVoiceRecordTypes() - now handled by loadActualRecordTypes() in main app init
        // async function loadVoiceRecordTypes() { ... }

        // DEPRECATED: populateVoiceRecordTypeFilter() - now handled by populateAllRecordTypeDropdowns()
        // function populateVoiceRecordTypeFilter(recordTypes) { ... }

        function updateAIStatus(main) {
            document.getElementById('ai-status-text').textContent = main;
        }

        // Chat Input Functions
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize textarea
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('ai-chat-input');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 200) + 'px';
                });
            }
        });

        async function sendChatMessage() {
            const input = document.getElementById('ai-chat-input');
            const question = input.value.trim();
            
            if (!question || chatState.isProcessing) {
                return;
            }
            
            // Clear input and disable send button temporarily
            input.value = '';
            input.style.height = '60px'; // Reset textarea height
            const sendBtn = document.getElementById('ai-chat-send-btn');
            sendBtn.disabled = true;
            
            try {
                // Add user message to conversation immediately
                addToConversation('user', question);
                
                // Update selected model and voice
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                await processTextWithAI(question);
            } catch (error) {
                console.error('[Chat] Error processing message:', error);
                updateAIStatus('Error occurred');
                addToConversation('system', `Error: ${error.message}`);
            } finally {
                // Re-enable send button and ensure input is ready
                sendBtn.disabled = false;
                ensureChatInputReady();
            }
        }

        // AI Processing Functions

        async function processTextWithAI(text) {
            try {
                updateAIStatus('Analyzing question...');
                chatState.isProcessing = true;
                
                // Determine if this is a follow-up question or new subject
                const isFollowUp = await detectFollowUpQuestion(text);
                
                if (isFollowUp && (chatState.lastSearchResults.length > 0 || (currentRecords && currentRecords.length === 1))) {
                    updateAIStatus('Processing follow-up with existing data...');
                    await processFollowUpQuestion(text);
                } else {
                    updateAIStatus('Searching for new information...');
                    await processNewQuestion(text);
                }
                
                updateAIStatus('Ready to answer questions!');
                
            } catch (error) {
                console.error('[Chat] AI processing error:', error);
                updateAIStatus('AI processing failed');
                addToConversation('system', `AI Error: ${error.message}`);
            } finally {
                chatState.isProcessing = false;
            }
        }

        async function detectFollowUpQuestion(text) {
            const lowerText = text.toLowerCase();
            
            // Special case: If we have exactly one record loaded, check for follow-up patterns
            if (currentRecords && currentRecords.length === 1) {
                console.log('[Chat] Single record context detected, analyzing for follow-up patterns');
                
                // Direct follow-up phrases
                const singleRecordFollowUpPatterns = [
                    /^(tell me more|give me more details|more info|more information|what else|anything else)/,
                    /^(how many calories|what about calories|calories|nutrition|nutritional info)/,
                    /^(how long|cook time|cooking time|prep time|preparation time)/,
                    /^(ingredients|what ingredients|recipe|instructions|how to make)/,
                    /^(servings|how many servings|serves how many)/,
                    /^(can you|could you|would you|will you).+(tell|give|show|explain)/,
                    /^(what about|how about|what's the|what is the)/,
                    /^(it|this|that|the recipe|the dish|the food)/,
                    /^(what does it|how does it|when does it|where does it)/,
                    /^(what is it|what's it|how is it|how's it)/
                ];
                
                if (singleRecordFollowUpPatterns.some(pattern => pattern.test(lowerText))) {
                    console.log('[Chat] Follow-up pattern detected for single record context');
                    return true;
                }
                
                // Check for questions with just attributes (likely follow-ups)
                const words = lowerText.split(/\s+/).filter(w => w.length > 2);
                const questionWords = ['what', 'how', 'when', 'where', 'why', 'which', 'who'];
                const attributeWords = ['calories', 'time', 'ingredients', 'servings', 'nutrition', 'cook', 'prep', 'difficulty'];
                
                const nonQuestionWords = words.filter(word => !questionWords.includes(word));
                const isAttributeQuery = nonQuestionWords.length > 0 && 
                                        nonQuestionWords.every(word => attributeWords.includes(word));
                
                if (isAttributeQuery) {
                    console.log('[Chat] Attribute-only question detected for single record context');
                    return true;
                }
            }
            
            // If no previous conversation, definitely not a follow-up (unless single record case above)
            if (chatState.conversation.length === 0 || !chatState.lastSearchSubject) {
                return false;
            }
            
            // Obvious new subject indicators
            const newSubjectPatterns = [
                /^(find|search|show|get|tell me about|what is|who is|where is|when is|how is)/,
                /recipe for/,
                /workout for/,
                /video about/,
                /image of/,
                /post about/,
                /information about/,
                /data on/
            ];
            
            if (newSubjectPatterns.some(pattern => pattern.test(lowerText))) {
                // Check if it mentions the same subject as before
                const lastSubjectWords = chatState.lastSearchSubject.toLowerCase().split(' ');
                const hasCommonSubject = lastSubjectWords.some(word => 
                    word.length > 3 && lowerText.includes(word)
                );
                
                if (!hasCommonSubject) {
                    return false; // Definitely new subject
                }
            }
            
            // Follow-up indicators
            const followUpPatterns = [
                /^(how many|how much|what about|what else|also|and|more|any other|tell me more)/,
                /^(where|when|why|who|which|whose)/,
                /(more|additional|other|else|further|next)/,
                /^(can you|could you|please)/
            ];
            
            if (followUpPatterns.some(pattern => pattern.test(lowerText))) {
                return true;
            }
            
            // Check for context continuity
            const lastSearchWords = chatState.lastSearchKeywords;
            if (lastSearchWords.length > 0) {
                const hasContextOverlap = lastSearchWords.some(keyword => 
                    lowerText.includes(keyword.toLowerCase())
                );
                
                if (hasContextOverlap) {
                    return true;
                }
            }
            
            return false;
        }

        async function processFollowUpQuestion(text) {
            console.log('[Chat] Processing follow-up question with existing data');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 20000);
            
            try {
                // Send the question with context and existing search results
                const response = await fetch('/api/alfred/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: false, // Don't perform new search
                        is_follow_up: true,
                        conversation_context: chatState.conversation.slice(-4), // Last 4 messages for context
                        existing_search_results: currentRecords && currentRecords.length === 1 ? currentRecords : chatState.lastSearchResults,
                        pinnedDidTx: (window.__alfredPinnedDid || '').trim() || undefined
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Follow-up processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] Follow-up Response:', aiData);
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: chatState.lastSearchResults,
                    searchResults: chatState.lastSearchResults.length,
                    isFollowUp: true
                });
                
                // Synthesize AI response with selected voice engine
                if (voiceConfig.enabled && aiData.response_text) {
                    await synthesizeResponseWithChatterbox(aiData.response_text);
                }
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                throw fetchError;
            }
        }

        /**
         * Check if any filters are currently active that would reduce the total record set
         */
        function hasActiveFilters() {
            return !!(
                currentFilters.search ||
                currentFilters.recordType ||
                currentFilters.dateStart ||
                currentFilters.dateEnd ||
                currentFilters.did ||
                currentFilters.didTx ||
                currentFilters.tags ||
                currentFilters.tag ||
                currentFilters.hasAudio ||
                currentFilters.aiTags
            );
        }

        async function processNewQuestion(text) {
            console.log('[Chat] Processing new question with fresh search');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 25000);
            
            try {
                // Determine if we should pass existing context based on active filters
                const filtersActive = hasActiveFilters();
                const shouldPassFullContext = filtersActive && currentRecords && currentRecords.length > 0 && currentRecords.length < 1000;
                const hasRecordTypeFilter = currentFilters.recordType && currentFilters.recordType.trim() !== '';
                
                console.log(`[Chat] Filters active: ${filtersActive}, Current records: ${currentRecords?.length || 0}, Record type: ${currentFilters.recordType || 'none'}`);
                console.log(`[Chat] Passing full context: ${shouldPassFullContext}, Has record type filter: ${hasRecordTypeFilter}`);
                
                // Build request body
                const requestBody = {
                    text: text,
                    model: chatState.selectedModel,
                    return_audio: false,
                    include_filter_analysis: true,
                    is_follow_up: false
                };
                
                // If a pinned DID is set, force single-record mode server-side
                if ((window.__alfredPinnedDid || '').trim()) {
                    requestBody.pinnedDidTx = window.__alfredPinnedDid.trim();
                    // In single-record mode, there is no need to pass existingContext/searchParams
                    requestBody.include_filter_analysis = false;
                }

                // Pass existing context if filters are active and we have a reasonable number of records
                if (shouldPassFullContext) {
                    // Pass first 10 records as context to avoid overwhelming the API
                    requestBody.existingContext = currentRecords.slice(0, 10);
                    console.log(`[Chat] Passing ${requestBody.existingContext.length} filtered records as existing context`);
                } else if (hasRecordTypeFilter) {
                    // Even if we can't pass full records, pass the record type for domain context
                    requestBody.searchParams = {
                        recordType: currentFilters.recordType
                    };
                    console.log(`[Chat] Passing record type context: ${currentFilters.recordType}`);
                }
                
                // Send to chat endpoint for new search
                const response = await fetch('/api/alfred/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 408 || response.status === 504) {
                        throw new Error('Request timeout - service may be busy, please try again');
                    }
                    throw new Error(`AI processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] New Question Response:', aiData);
                
                // Store search results and subject for future follow-ups
                chatState.lastSearchResults = aiData.search_results || [];
                chatState.lastSearchSubject = aiData.extracted_subject || text;
                chatState.lastSearchKeywords = aiData.extracted_keywords || [];
                
                // Use applied filters from backend (enhanced RAG service)
                const appliedFilters = aiData.applied_filters || {};
                
                console.log('[Chat] AI found search results:', aiData.search_results?.length || 0);
                console.log('[Chat] AI applied filters:', appliedFilters);
                
                // If AI found specific search results, display them directly
                if (aiData.search_results && aiData.search_results.length > 0) {
                    console.log('[Chat] 🎯 Displaying AI search results directly');
                    displayAISearchResults(aiData.search_results, appliedFilters);
                    // Update filters display but don't reload records (use AI results instead)
                    displayAppliedFilters(appliedFilters, aiData.sources);
                } else {
                    console.log('[Chat] 📋 No AI search results, using filter-based search');
                    // Apply the filters to the UI and reload records
                    await applyAIFilters(appliedFilters, aiData.sources);
                }
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: aiData.sources,
                    searchResults: aiData.search_results_count,
                    filtersApplied: appliedFilters,
                    isFollowUp: false
                });
                
                // Synthesize AI response with selected voice engine
                if (voiceConfig.enabled && aiData.response_text) {
                    await synthesizeResponseWithChatterbox(aiData.response_text);
                }
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                if (fetchError.message.includes('Failed to fetch')) {
                    throw new Error('Connection failed - please check your connection and try again');
                }
                
                throw fetchError;
            }
        }

        // Manage pinned DID state from the new input
        function onPinnedDidChange(value) {
            const val = (value || '').trim();
            if (!val) {
                window.__alfredPinnedDid = '';
                return;
            }
            if (!val.startsWith('did:arweave:')) {
                alert('Please enter a valid DID that starts with did:arweave:');
                return;
            }
            window.__alfredPinnedDid = val;
            // Also reflect to the main filters DID input so the browse view loads that record
            const didInput = document.getElementById('voice-did-tx');
            if (didInput) {
                didInput.value = val;
                validateAndApplyDidTx();
            }
        }

        function clearPinnedDid() {
            window.__alfredPinnedDid = '';
            const pinned = document.getElementById('alfred-pinned-did');
            if (pinned) pinned.value = '';
        }



        function displayAISearchResults(searchResults, appliedFilters) {
            console.log(`[Chat AI] 🎯 Displaying ${searchResults.length} exact AI search results`);
            
            // Switch to Browse tab to show the visual representation
            showSearchInterface();
            
            // Update global state to match AI results
            currentRecords = searchResults;
            currentPage = 1;
            hasMoreRecords = false; // AI results are finite
            
            // Update the interface with AI filters
            Object.assign(currentFilters, appliedFilters);
            
            // Update UI elements
            if (appliedFilters.search) {
                document.getElementById('voice-search-input').value = appliedFilters.search;
            }
            if (appliedFilters.searchMatchMode) {
                document.getElementById('voice-search-match-mode').value = appliedFilters.searchMatchMode;
            }
            if (appliedFilters.recordType) {
                document.getElementById('voice-record-type-filter').value = appliedFilters.recordType;
            }
            if (appliedFilters.sortBy) {
                document.getElementById('voice-sort-by').value = appliedFilters.sortBy;
            }
            
            // Handle AI multi-tag filters
            if (appliedFilters.tags && appliedFilters.tagsMatchMode) {
                currentFilters.aiTags = appliedFilters.tags;
                currentFilters.aiTagsMatchMode = appliedFilters.tagsMatchMode;
            }
            
            // Display the exact results the AI found
            displayVoiceRecords(searchResults, false);
            
            // Update pagination info
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${searchResults.length} AI search results • Page 1`;
            
            // Hide load more button since AI results are finite
            document.getElementById('voice-load-more-container').classList.add('hidden');
            
            // Extract and update tag summary if available
            const allTags = [];
            searchResults.forEach(record => {
                const tags = record.data?.basic?.tagItems || [];
                tags.forEach(tag => {
                    const existing = allTags.find(t => t.tag === tag);
                    if (existing) {
                        existing.count++;
                    } else {
                        allTags.push({ tag, count: 1 });
                    }
                });
            });
            
            if (allTags.length > 0) {
                updateVoiceTagFilter(allTags);
            }
            
            console.log(`[Chat AI] ✅ Successfully displayed ${searchResults.length} AI search results`);
        }

        async function applyAIFilters(filters, sources = []) {
            // Switch to Browse tab to show the visual representation
            showSearchInterface();
            
            // Update the enhanced unified filters state
            Object.assign(currentFilters, filters);
            
            // Update the UI elements for basic filters
            if (filters.search) {
                document.getElementById('voice-search-input').value = filters.search;
            }
            if (filters.searchMatchMode) {
                document.getElementById('voice-search-match-mode').value = filters.searchMatchMode;
            }
            if (filters.recordType) {
                document.getElementById('voice-record-type-filter').value = filters.recordType;
            }
            if (filters.sortBy) {
                document.getElementById('voice-sort-by').value = filters.sortBy;
            }
            if (filters.did || filters.didTx) {
                document.getElementById('voice-did-tx').value = filters.did || filters.didTx;
            }
            
            // Handle enhanced multi-tag filtering from AI
            if (filters.tags && filters.tagsMatchMode) {
                console.log(`[Enhanced AI] Applying multi-tag filter: ${filters.tags} (${filters.tagsMatchMode} mode)`);
                // Store the AI-applied tag filters separately since UI doesn't support multi-tag
                currentFilters.aiTags = filters.tags;
                currentFilters.aiTagsMatchMode = filters.tagsMatchMode;
                
                // Clear the single tag filter since we're using AI multi-tag
                currentFilters.tag = '';
                document.getElementById('voice-tag-filter').value = '';
            } else if (filters.tag) {
                // Handle single tag from regular filtering
                currentFilters.tag = filters.tag;
                if (document.getElementById('voice-tag-filter')) {
                    document.getElementById('voice-tag-filter').value = filters.tag;
                }
            }
            
            // Update applied filters display
            displayAppliedFilters(filters, sources);
            
            // Reload records with new filters using enhanced system
            await loadVoiceRecords(true);
            
            console.log('[Enhanced AI] Applied AI filters:', filters);
        }

        function displayAppliedFilters(filters, sources) {
            const display = document.getElementById('applied-filters-display');
            const container = document.getElementById('filter-chips-container');
            const rationale = document.getElementById('filter-rationale');
            
            // Clear existing chips
            container.innerHTML = '';
            
            // Create filter chips
            let hasFilters = false;
            if (filters.search) {
                addFilterChip(container, 'Search', filters.search);
                hasFilters = true;
            }
            if (filters.recordType) {
                addFilterChip(container, 'Type', filters.recordType);
                hasFilters = true;
            }
            if (currentFilters.hasAudio) {
                addFilterChip(container, 'Content', 'Has Audio');
                hasFilters = true;
            }
            if (currentFilters.did || currentFilters.didTx) {
                const didValue = currentFilters.did || currentFilters.didTx;
                const shortDid = didValue.length > 25 ? 
                    didValue.substring(0, 25) + '...' : 
                    didValue;
                addFilterChip(container, 'DID', shortDid);
                hasFilters = true;
            }
            if (filters.sortBy && filters.sortBy !== 'inArweaveBlock:desc') {
                addFilterChip(container, 'Sort', filters.sortBy.replace(':', ' '));
                hasFilters = true;
            }
            // Show manual multi-tag filters first (highest priority)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                const tagMode = currentFilters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `Tags (${tagMode})`, currentFilters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show AI-applied filters if no manual filters
            else if (filters.tags && filters.tagsMatchMode) {
                const tagMode = filters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `AI Tags (${tagMode})`, filters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show legacy single tag filter (fallback)
            else if (filters.tag) {
                addFilterChip(container, 'Tag', filters.tag);
                hasFilters = true;
            }
            
            if (hasFilters) {
                display.classList.remove('hidden');
                
                // Use rationale from backend or generate fallback
                const rationaleText = filters.rationale || `AI applied these filters automatically based on your query.`;
                rationale.textContent = rationaleText;
            } else {
                display.classList.add('hidden');
            }
        }

        function addFilterChip(container, label, value) {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';
            chip.textContent = `${label}: ${value}`;
            container.appendChild(chip);
        }

        // No audio playback needed for text chat

        // Conversation Management
        function addToConversation(role, content, metadata = {}) {
            const message = {
                role,
                content,
                timestamp: new Date().toISOString(),
                ...metadata
            };
            
            chatState.conversation.push(message);
            updateConversationDisplay();
        }

        function updateConversationDisplay() {
            const container = document.getElementById('chat-messages');
            const emptyState = document.getElementById('chat-empty-state');
            
            if (chatState.conversation.length === 0) {
                emptyState.style.display = 'flex';
                container.innerHTML = '';
                return;
            }
            
            emptyState.style.display = 'none';
            container.innerHTML = '';
            
            // Show all messages
            chatState.conversation.forEach((message, index) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}`;
                
                const avatar = getMessageAvatar(message.role);
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                
                let sourcesHtml = '';
                if (message.role === 'assistant' && message.sources && message.sources.length > 0) {
                    sourcesHtml = `
                        <div class="message-sources">
                            <span class="source-count">📚 ${message.sources.length} sources found</span>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-content">
                        <div class="message-text">${escapeHtml(message.content)}</div>
                        ${sourcesHtml}
                        <div class="message-meta">
                            <span class="message-timestamp">${timestamp}</span>
                        </div>
                    </div>
                `;
                
                container.appendChild(messageDiv);
            });
            
            // Scroll to bottom
            const chatConversation = document.getElementById('chat-conversation');
            setTimeout(() => {
                chatConversation.scrollTop = chatConversation.scrollHeight;
            }, 10);
        }

        function ensureChatInputReady() {
            const chatInput = document.getElementById('ai-chat-input');
            const sendBtn = document.getElementById('ai-chat-send-btn');
            
            if (chatInput) {
                chatInput.disabled = false;
                chatInput.removeAttribute('readonly');
                chatInput.removeAttribute('hidden');
                chatInput.classList.remove('hidden');
                
                // Only reset dimensions if they're problematic
                if (chatInput.offsetHeight === 0) {
                    chatInput.style.height = '60px';
                }
            }
            
            if (sendBtn) {
                sendBtn.disabled = chatState.isProcessing;
                sendBtn.removeAttribute('hidden');
                sendBtn.classList.remove('hidden');
            }
        }

        function getMessageAvatar(role) {
            switch (role) {
                case 'user': return '👤';
                case 'assistant': return '🤖';
                case 'system': return '⚠️';
                default: return '💬';
            }
        }

        // STT (Speech-to-Text) Functions
        
        // Voice Activity Detection configuration
        const VAD_CONFIG = {
            silenceThreshold: 0.01,
            silenceTimeoutMs: 2000,
            minRecordingMs: 1500,
            volumeThreshold: 0.12,
        };

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator?.mediaDevices?.getUserMedia);
            const hasMediaRecorder = typeof MediaRecorder !== 'undefined';
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            
            return hasMediaDevices && hasMediaRecorder && hasAudioContext;
        }

        async function toggleRecording() {
            if (chatState.isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            if (!checkBrowserSupport()) {
                updateAIStatus('Browser does not support voice recording');
                return;
            }

            try {
                chatState.mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                await setupVAD(chatState.mediaStream);

                chatState.mediaRecorder = new MediaRecorder(chatState.mediaStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                chatState.audioChunks = [];

                chatState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chatState.audioChunks.push(event.data);
                    }
                };

                chatState.mediaRecorder.onstop = async () => {
                    if (chatState.audioChunks.length > 0) {
                        const audioBlob = new Blob(chatState.audioChunks, { type: 'audio/webm' });
                        await processAudioBlob(audioBlob);
                    }
                };

                chatState.mediaRecorder.start();
                chatState.isRecording = true;
                updateMicrophoneButton();
                updateAIStatus('Recording... Speak now');

            } catch (error) {
                console.error('Error starting recording:', error);
                updateAIStatus('Microphone access denied');
                cleanupRecording();
            }
        }

        async function setupVAD(stream) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            chatState.audioContext = new AudioContext();

            if (chatState.audioContext.state === 'suspended') {
                await chatState.audioContext.resume();
            }

            chatState.analyser = chatState.audioContext.createAnalyser();
            chatState.analyser.fftSize = 512;

            const source = chatState.audioContext.createMediaStreamSource(stream);
            source.connect(chatState.analyser);

            const bufferLength = chatState.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const monitorAudio = () => {
                if (!chatState.analyser || !chatState.isRecording) return;

                chatState.analyser.getByteFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength) / 255;

                const now = Date.now();

                if (rms > VAD_CONFIG.volumeThreshold) {
                    chatState.lastSpeechTime = now;
                    chatState.isListening = true;
                    updateMicrophoneButton();

                    if (chatState.silenceTimeout) {
                        clearTimeout(chatState.silenceTimeout);
                        chatState.silenceTimeout = null;
                    }
                } else {
                    const recordingDuration = now - (chatState.lastSpeechTime || now);

                    if (recordingDuration > VAD_CONFIG.minRecordingMs && chatState.lastSpeechTime > 0) {
                        if (!chatState.silenceTimeout) {
                            chatState.silenceTimeout = setTimeout(() => {
                                stopRecording();
                            }, VAD_CONFIG.silenceTimeoutMs);
                        }
                    }

                    chatState.isListening = false;
                    updateMicrophoneButton();
                }
            };

            chatState.vadInterval = setInterval(monitorAudio, 100);
        }

        function stopRecording() {
            if (chatState.mediaRecorder && chatState.isRecording) {
                chatState.mediaRecorder.stop();
            }
            
            chatState.isRecording = false;
            chatState.isListening = false;
            updateMicrophoneButton();
            cleanupVAD();

            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            updateAIStatus('Processing speech...');
        }

        function cleanupVAD() {
            if (chatState.vadInterval) {
                clearInterval(chatState.vadInterval);
                chatState.vadInterval = null;
            }

            if (chatState.silenceTimeout) {
                clearTimeout(chatState.silenceTimeout);
                chatState.silenceTimeout = null;
            }

            if (chatState.analyser) {
                chatState.analyser = null;
            }
        }

        function cleanupRecording() {
            cleanupVAD();
            
            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            if (chatState.audioContext && chatState.audioContext.state !== 'closed') {
                chatState.audioContext.close();
                chatState.audioContext = null;
            }

            chatState.isRecording = false;
            chatState.isTranscribing = false;
            chatState.isListening = false;
            updateMicrophoneButton();
        }

        async function processAudioBlob(audioBlob) {
            try {
                chatState.isTranscribing = true;
                updateMicrophoneButton();
                updateAIStatus('Transcribing speech...');

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                
                // Add language if specified
                const language = document.getElementById('stt-language').value;
                if (language && language !== 'auto') {
                    formData.append('language', language);
                }

                const response = await fetch('/api/alfred/transcribe', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Speech transcription failed');
                }

                const data = await response.json();
                const transcribedText = data.text?.trim();

                if (!transcribedText) {
                    updateAIStatus('No speech detected. Try again.');
                    return;
                }

                console.log('[STT] Transcribed:', transcribedText);

                // Add transcribed text to the conversation window immediately
                addToConversation('user', transcribedText);

                // Also put transcribed text in the input field for editing if needed
                const input = document.getElementById('ai-chat-input');
                input.value = transcribedText;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 200) + 'px';

                // Automatically process the transcribed text with AI (like working index.html)
                updateAIStatus('Processing your question...');
                
                // Update selected model and voice from current settings
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                // Automatically trigger AI processing
                await processTextWithAI(transcribedText);

            } catch (error) {
                console.error('Transcription error:', error);
                updateAIStatus('Speech transcription failed');
            } finally {
                chatState.isTranscribing = false;
                updateMicrophoneButton();
            }
        }

        function updateMicrophoneButton() {
            const micBtn = document.getElementById('mic-btn');
            
            // Default microphone SVG
            const microphoneSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M50,10 C43.373,10 38,15.373 38,22 L38,50 C38,56.627 43.373,62 50,62 C56.627,62 62,56.627 62,50 L62,22 C62,15.373 56.627,10 50,10 Z M50,15 C53.866,15 57,18.134 57,22 L57,50 C57,53.866 53.866,57 50,57 C46.134,57 43,53.866 43,50 L43,22 C43,18.134 46.134,15 50,15 Z M20,45 L20,50 C20,66.568 33.432,80 50,80 C66.568,80 80,66.568 80,50 L80,45 L85,45 L85,50 C85,69.33 69.33,85 50,85 L50,90 L60,90 L60,95 L40,95 L40,90 L50,90 L50,85 C30.67,85 15,69.33 15,50 L15,45 L20,45 Z"/>
            </svg>`;
            
            // Processing/loading SVG
            const processingSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="35" fill="none" stroke="currentColor" stroke-width="8" stroke-dasharray="164.93361431346415 54.97787143782138">
                    <animateTransform attributeName="transform" type="rotate" values="0 50 50;360 50 50" dur="1s" repeatCount="indefinite"/>
                </circle>
            </svg>`;
            
            // Recording dot SVG
            const recordingSVG = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="30" fill="currentColor"/>
            </svg>`;
            
            // Reset all classes
            micBtn.classList.remove('recording', 'listening', 'transcribing');
            
            if (chatState.isTranscribing) {
                micBtn.classList.add('transcribing');
                micBtn.innerHTML = processingSVG;
                micBtn.title = 'Processing speech...';
            } else if (chatState.isRecording) {
                if (chatState.isListening) {
                    micBtn.classList.add('listening');
                    micBtn.innerHTML = microphoneSVG;
                    micBtn.title = 'Listening... (click to stop)';
                } else {
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = recordingSVG;
                    micBtn.title = 'Recording... (click to stop)';
                }
            } else {
                micBtn.innerHTML = microphoneSVG;
                micBtn.title = 'Click to record voice message';
            }
        }

        function clearConversation() {
            // Stop any current recording
            if (chatState.isRecording) {
                stopRecording();
            }
            
            // Clear conversation array
            chatState.conversation = [];
            
            // Clear follow-up tracking state
            chatState.lastSearchResults = [];
            chatState.lastSearchSubject = '';
            chatState.lastSearchKeywords = [];
            
            // Update display
            updateConversationDisplay();
            
            // Clear any applied filters
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            // Ensure input is ready
            ensureChatInputReady();
            
            updateAIStatus('Ready to answer questions!');
        }

        // No conversation mode needed for text chat

        // View Mode Management
        let currentViewMode = 'grid'; // Default view mode
        let tagFilterIndex = 0; // Track multi-tag filter indices
        const viewModeDefaults = {
            'podcast': 'list',
            'post': 'grid', 
            'recipe': 'grid',
            'video': 'grid',
            'audio': 'list',
            'image': 'grid',
            'text': 'list',
            'workout': 'grid'
        };

        // Enhanced view mode functionality with error handling
        function changeViewMode() {
            try {
                const viewAsElement = document.getElementById('voice-view-as');
                if (!viewAsElement) {
                    console.error('[View Mode] voice-view-as element not found');
                    return;
                }
                
                const newMode = viewAsElement.value;
                console.log(`[View Mode] Attempting to change from ${currentViewMode} to ${newMode}`);
                
                if (newMode !== currentViewMode) {
                    currentViewMode = newMode;
                    
                    // Re-render current records with new view mode
                    if (currentRecords && currentRecords.length > 0) {
                        console.log(`[View Mode] Re-rendering ${currentRecords.length} records with ${newMode} view`);
                        displayVoiceRecords(currentRecords, false);
                    } else {
                        console.log('[View Mode] No records to re-render');
                        // Still update the container class even if no records
                        const container = document.getElementById('voice-records-grid');
                        if (container) {
                            container.className = newMode === 'list' ? 'records-list' : 'records-grid';
                        }
                    }
                    
                    console.log(`[View Mode] Successfully changed to ${newMode} view`);
                } else {
                    console.log('[View Mode] No change needed - already in', newMode, 'mode');
                }
            } catch (error) {
                console.error('[View Mode] Error in changeViewMode:', error);
                // Show user-friendly error message
                const statusDiv = document.getElementById('voice-loading-indicator');
                if (statusDiv) {
                    statusDiv.innerHTML = '❌ View mode change failed. Please refresh the page.';
                    statusDiv.classList.remove('hidden');
                    setTimeout(() => {
                        statusDiv.classList.add('hidden');
                    }, 5000);
                }
            }
        }

        // Enhanced displayVoiceRecords function with improved error handling
        function displayVoiceRecords(records, append = false) {
            try {
                const container = document.getElementById('voice-records-grid');
                if (!container) {
                    console.error('[Enhanced Display] voice-records-grid container not found');
                    return;
                }
                
                console.log(`[Enhanced Display] Displaying ${records.length} records, append=${append}, currentViewMode=${currentViewMode}`);
                
                if (!append) {
                    container.innerHTML = '';
                }
                
                // Update container class based on view mode
                const containerClass = currentViewMode === 'list' ? 'records-list' : 'records-grid';
                container.className = containerClass;
                console.log(`[Enhanced Display] Set container class to: ${containerClass}`);
                
                // Group podcast records by show
                const podcastShows = {};
                const nonPodcastRecords = [];
                
                records.forEach(record => {
                    try {
                        if (record.oip?.recordType === 'podcast' && record.data?.podcast?.show) {
                            const showName = record.data.podcast.show;
                            if (!podcastShows[showName]) {
                                podcastShows[showName] = [];
                            }
                            podcastShows[showName].push(record);
                        } else {
                            nonPodcastRecords.push(record);
                        }
                    } catch (recordError) {
                        console.error('[Enhanced Display] Error processing record:', recordError, record);
                        nonPodcastRecords.push(record); // Add to non-podcast as fallback
                    }
                });
                
                const startIndex = currentRecords.length - records.length;
                let recordIndex = startIndex;
                
                // Render podcast shows
                Object.keys(podcastShows).forEach(showName => {
                    try {
                        const episodes = podcastShows[showName];
                        
                        if (currentViewMode === 'list') {
                            // In list view, render individual podcast episodes
                            episodes.forEach(episode => {
                                const episodeCard = createRecordCard(episode, recordIndex, true);
                                container.appendChild(episodeCard);
                                recordIndex++;
                            });
                        } else {
                            // In grid view, use grouped podcast show cards
                            const showCard = createPodcastShowCard(showName, episodes, recordIndex);
                            container.appendChild(showCard);
                            recordIndex += episodes.length;
                        }
                    } catch (showError) {
                        console.error('[Enhanced Display] Error rendering podcast show:', showError, showName);
                    }
                });
                
                // Render non-podcast records
                nonPodcastRecords.forEach(record => {
                    try {
                        const card = createRecordCard(record, recordIndex, currentViewMode === 'list');
                        container.appendChild(card);
                        recordIndex++;
                    } catch (cardError) {
                        console.error('[Enhanced Display] Error creating record card:', cardError, record);
                    }
                });
                
                container.classList.remove('hidden');
                document.getElementById('voice-no-results').classList.add('hidden');
                
                console.log(`[Enhanced Display] Successfully rendered ${records.length} records in ${currentViewMode} view (${Object.keys(podcastShows).length} podcast shows)`);
                
            } catch (error) {
                console.error('[Enhanced Display] Error in displayVoiceRecords:', error);
                
                // Show error message to user
                const container = document.getElementById('voice-records-grid');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px; margin: 20px 0;">
                            <h4>❌ Error Displaying Records</h4>
                            <p>There was an error displaying the records. Please try refreshing the page.</p>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                    container.classList.remove('hidden');
                }
            }
        }

        // Enhanced createRecordCard function with better error handling
        function createRecordCard(record, recordIndex, isListView = false) {
            try {
                const card = document.createElement('div');
                card.className = isListView ? 'record-card list-view' : 'record-card';
                
                const recordType = record.oip?.recordType || 'unknown';
                const basicData = record.data?.basic || {};
                
                let templatesUsed = [];
                try {
                    templatesUsed = analyzeRecordTemplates(record);
                } catch (error) {
                    console.warn('[Card Creation] Error analyzing templates:', error);
                    templatesUsed = [recordType];
                }
                
                // Extract media and content for modern display
                let mediaContent = {};
                try {
                    mediaContent = extractMediaContent(record);
                } catch (error) {
                    console.warn('[Card Creation] Error extracting media content:', error);
                    mediaContent = { featuredImage: null, audioItems: [], videoItems: [] };
                }
                
                const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
                
                if (isListView) {
                    // List view layout - horizontal layout with thumbnail on left
                    card.innerHTML = `
                        ${renderMediaPreview(mediaContent, recordIndex, record)}
                        
                        <div class="record-content-area">
                            <div class="record-header">
                                <div class="record-type">${recordType}</div>
                                <div class="record-date">${dateDisplay}</div>
                            </div>
                            
                            ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                            
                            <div class="list-meta-row">
                                <div class="list-controls">
                                    ${renderMediaControls(mediaContent, record, recordIndex)}
                                    ${renderArticleTextButton(mediaContent, recordIndex)}
                                    ${renderWebUrlButton(mediaContent)}
                                </div>
                                <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                    🔧
                                </button>
                            </div>
                            
                            ${createTagsDisplay(basicData.tagItems)}
                            ${renderPodcastCitations(mediaContent, recordIndex)}
                        </div>
                        
                        <div id="structure-${recordIndex}" class="record-structure hidden">
                            <div class="structure-header">
                                <h4>🔧 Technical Record Structure</h4>
                                <div class="template-info">
                                    <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                    <strong>Record Type:</strong> ${recordType}<br>
                                    <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                    ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                                </div>
                            </div>
                            ${renderAllTemplateData(record, templatesUsed)}
                        </div>
                    `;
                } else {
                    // Grid view layout - vertical layout (original)
                    card.innerHTML = `
                        <div class="record-header">
                            <div class="record-type">${recordType}</div>
                            <div class="record-date">${dateDisplay}</div>
                        </div>
                        
                        ${renderMediaPreview(mediaContent, recordIndex, record)}
                        
                        <div class="record-content">
                            ${renderRecordTitleAndDescription(mediaContent, basicData, recordType, recordIndex, record)}
                            
                            ${renderMediaControls(mediaContent, record, recordIndex)}
                            ${renderArticleTextButton(mediaContent, recordIndex)}
                            ${renderWebUrlButton(mediaContent)}
                            ${renderPodcastCitations(mediaContent, recordIndex)}
                        </div>
                        
                        ${createTagsDisplay(basicData.tagItems)}
                        
                        <div class="record-footer">
                            <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                                <span class="structure-icon">🔧</span> Show Record Structure
                            </button>
                            <div class="record-did">DID: ${truncateText(record.oip?.did || record.oip?.didTx || 'Unknown', 20)}</div>
                        </div>
                        
                        <div id="structure-${recordIndex}" class="record-structure hidden">
                            <div class="structure-header">
                                <h4>🔧 Technical Record Structure</h4>
                                <div class="template-info">
                                    <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                                    <strong>Record Type:</strong> ${recordType}<br>
                                    <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                                    ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                                </div>
                            </div>
                            ${renderAllTemplateData(record, templatesUsed)}
                        </div>
                    `;
                }
                
                return card;
                
            } catch (error) {
                console.error('[Card Creation] Error creating record card:', error, record);
                
                // Return a fallback error card
                const errorCard = document.createElement('div');
                errorCard.className = isListView ? 'record-card list-view' : 'record-card';
                errorCard.innerHTML = `
                    <div style="padding: 15px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px;">
                        <h4>❌ Error Displaying Record</h4>
                        <p>There was an error displaying this record.</p>
                        <small>Record Type: ${record.oip?.recordType || 'Unknown'}</small>
                    </div>
                `;
                return errorCard;
            }
        }

        // Add initialization check to ensure view mode works on page load
        function initializeViewMode() {
            try {
                const viewAsElement = document.getElementById('voice-view-as');
                if (viewAsElement) {
                    viewAsElement.value = currentViewMode;
                    console.log(`[View Mode] Initialized with mode: ${currentViewMode}`);
                } else {
                    console.warn('[View Mode] voice-view-as element not found during initialization');
                }
            } catch (error) {
                console.error('[View Mode] Error during initialization:', error);
            }
        }

        // Call initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeViewMode();
        });

        // Also initialize if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeViewMode);
        } else {
            initializeViewMode();
        }
        
        function updateAllTagDropdowns() {
            const selects = document.querySelectorAll('.tag-filter-select');
            const container = document.getElementById('tag-filters-container');
            
            // Store current values before clearing dropdowns
            const currentValues = [];
            selects.forEach(select => {
                currentValues.push({
                    index: parseInt(select.getAttribute('data-tag-index')),
                    value: select.value
                });
            });
            
            // Add compact styling when there are many tag filters
            if (selects.length >= 3) {
                container.classList.add('has-many-tags');
            } else {
                container.classList.remove('has-many-tags');
            }
            
            // Get all currently selected tags (exclude empty values)
            const allSelectedTags = currentValues
                .filter(item => item.value && item.value.trim())
                .map(item => item.value.trim());
            
            selects.forEach((select, selectIndex) => {
                const selectTagIndex = parseInt(select.getAttribute('data-tag-index'));
                const currentValue = currentValues.find(item => item.index === selectTagIndex)?.value || '';
                
                // Clear and repopulate options
                select.innerHTML = '<option value="">Select a tag...</option>';
                
                if (availableTags && availableTags.length > 0) {
                    availableTags.forEach(tag => {
                        // Add this tag if:
                        // 1. It's not selected by any other dropdown, OR
                        // 2. It's the current value of THIS dropdown
                        const isSelectedByOthers = allSelectedTags.some(selectedTag => 
                            selectedTag === tag.tag && selectedTag !== currentValue
                        );
                        
                        if (!isSelectedByOthers) {
                            const option = document.createElement('option');
                            option.value = tag.tag;
                            option.textContent = `${tag.tag} (${tag.count})`;
                            select.appendChild(option);
                        }
                    });
                }
                
                // Restore the current value (this will work now because we rebuilt the options)
                if (currentValue && currentValue.trim()) {
                    select.value = currentValue;
                    console.log(`[Multi-Tag] Restored value "${currentValue}" for select ${selectTagIndex}`);
                }
            });
            
            // Get final selected tags for logging
            const finalSelectedTags = getSelectedTags();
            console.log('[Multi-Tag] Updated dropdowns. Selected tags:', finalSelectedTags, 'Compact mode:', selects.length >= 3);
        }
        
        function clearAllTagFilters() {
            // Reset to single empty tag filter
            const container = document.getElementById('tag-filters-container');
            
            // Remove compact styling
            container.classList.remove('has-many-tags');
            
            container.innerHTML = `
                <div class="tag-filter-row" data-tag-index="0">
                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                        <option value="">Select a tag...</option>
                    </select>
                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                </div>
            `;
            
            // Reset the match mode
            document.getElementById('tag-match-mode').value = 'OR';
            
            tagFilterIndex = 0;
            updateAllTagDropdowns(); // This will ensure compact styling stays off
            console.log('[Multi-Tag] Cleared all tag filters');
        }
        
        function setDefaultViewMode() {
            // Set appropriate default view mode based on record type
            const recordType = currentFilters.recordType;
            if (recordType && viewModeDefaults[recordType]) {
                const defaultMode = viewModeDefaults[recordType];
                if (currentViewMode !== defaultMode) {
                    currentViewMode = defaultMode;
                    const viewAsElement = document.getElementById('voice-view-as');
                    if (viewAsElement) {
                        viewAsElement.value = defaultMode;
                    }
                    console.log(`[View Mode] Set default view mode for ${recordType}: ${defaultMode}`);
                }
            }
        }

        function getSelectedTags() {
            // Get all selected tags from the multi-tag filter system
            const tagSelects = document.querySelectorAll('.tag-filter-select');
            const selectedTags = [];
            
            tagSelects.forEach(select => {
                const value = select.value.trim();
                if (value) {
                    selectedTags.push(value);
                }
            });
            
            return selectedTags;
        }

        function addTagFilter() {
            // Add another tag filter row
            tagFilterIndex++;
            const container = document.getElementById('tag-filters-container');
            
            const newRow = document.createElement('div');
            newRow.className = 'tag-filter-row';
            newRow.setAttribute('data-tag-index', tagFilterIndex);
            
            newRow.innerHTML = `
                <select class="tag-filter-select" onchange="onTagFilterChange(${tagFilterIndex})" data-tag-index="${tagFilterIndex}">
                    <option value="">Select a tag...</option>
                </select>
                <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                <button type="button" class="remove-tag-btn" onclick="removeTagFilter(${tagFilterIndex})" title="Remove this tag filter">×</button>
            `;
            
            container.appendChild(newRow);
            updateAllTagDropdowns();
            console.log(`[Multi-Tag] Added tag filter ${tagFilterIndex}`);
        }

        function removeTagFilter(index) {
            // Remove a specific tag filter
            const row = document.querySelector(`[data-tag-index="${index}"]`);
            if (row) {
                row.remove();
                updateAllTagDropdowns();
                console.log(`[Multi-Tag] Removed tag filter ${index}`);
            }
        }

        function onTagFilterChange(index) {
            // Handle tag filter selection change
            console.log(`[Multi-Tag] Tag filter ${index} changed`);
            updateAllTagDropdowns();
            // Auto-apply filters when tags are selected
            applyVoiceFilters();
        }

        function applyVoiceFilters() {
            collectVoiceFilters();
            setDefaultViewMode(); // Set appropriate default view mode based on record type
            loadVoiceRecords(true);
        }

        function collectVoiceFilters() {
            // Sync header search to hidden search input
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                hiddenSearch.value = headerSearch.value;
            }
            
            // Update the main currentFilters object to work with enhanced system
            currentFilters.search = document.getElementById('voice-search-input').value.trim();
            currentFilters.searchMatchMode = document.getElementById('voice-search-match-mode').value;
            currentFilters.recordType = document.getElementById('voice-record-type-filter').value;
            currentFilters.source = document.getElementById('voice-storage-filter').value; // NEW: Storage type filter
            currentFilters.sortBy = document.getElementById('voice-sort-by').value;
            currentFilters.resolveDepth = parseInt(document.getElementById('voice-resolve-depth').value) || 2;
            currentFilters.dateStart = document.getElementById('voice-date-start').value;
            currentFilters.dateEnd = document.getElementById('voice-date-end').value;
            const didValue = document.getElementById('voice-did-tx').value.trim();
            currentFilters.did = didValue;
            currentFilters.didTx = didValue; // Backward compatibility
            currentFilters.includeSigs = document.getElementById('voice-include-sigs-toggle').classList.contains('active');
            currentFilters.includePubKeys = document.getElementById('voice-include-pubkeys-toggle').classList.contains('active');
            currentFilters.hasAudio = document.getElementById('voice-includes-audio-toggle').classList.contains('active');
            
            // Collect multi-tag filters (prioritize user manual selection over AI)
            const selectedTags = getSelectedTags();
            const tagMatchMode = document.getElementById('tag-match-mode').value;
            
            console.log(`[Filters] DEBUG: getSelectedTags() returned:`, selectedTags);
            console.log(`[Filters] DEBUG: tagMatchMode is:`, tagMatchMode);
            
            if (selectedTags.length > 0) {
                // Use manual multi-tag selection
                currentFilters.tags = selectedTags.join(',');
                currentFilters.tagsMatchMode = tagMatchMode;
                currentFilters.tag = ''; // Clear legacy single tag
                
                // Clear AI tags since user is manually filtering
                delete currentFilters.aiTags;
                delete currentFilters.aiTagsMatchMode;
                
                console.log('[Filters] ✅ Using manual multi-tag filters:', selectedTags, 'mode:', tagMatchMode);
                console.log('[Filters] ✅ Final tags parameter:', currentFilters.tags);
            } else {
                // No manual tags selected, keep AI tags if they exist
                if (!currentFilters.aiTags) {
                    currentFilters.tags = '';
                    currentFilters.tagsMatchMode = '';
                    currentFilters.tag = '';
                }
                console.log('[Filters] ❌ No manual tags, keeping AI tags:', currentFilters.aiTags);
            }
            
            // Update debug setting
            showDebugInfo = document.getElementById('show-template-debug')?.checked || false;
            
            console.log('[Filters] Updated filters:', currentFilters);
        }

        function handleVoiceSearchKeyup(event) {
            if (event.key === 'Enter') {
                applyVoiceFilters();
            }
        }

        function validateAndApplyDidTx() {
            const didTxInput = document.getElementById('voice-did-tx');
            const errorDiv = document.getElementById('did-tx-error');
            const value = didTxInput.value.trim();
            
            if (value && !value.startsWith('did:')) {
                errorDiv.classList.remove('hidden');
                didTxInput.style.borderColor = '#dc3545';
                return false;
            } else {
                errorDiv.classList.add('hidden');
                didTxInput.style.borderColor = '';
                applyVoiceFilters();
                return true;
            }
        }
        
        function clearDidTxError() {
            const errorDiv = document.getElementById('did-tx-error');
            const didTxInput = document.getElementById('voice-did-tx');
            errorDiv.classList.add('hidden');
            didTxInput.style.borderColor = '';
        }

        function clearVoiceFilters() {
            document.getElementById('voice-search-input').value = '';
            document.getElementById('voice-search-match-mode').value = 'AND';
            document.getElementById('voice-record-type-filter').value = '';
            document.getElementById('voice-storage-filter').value = 'all'; // NEW: Reset storage filter
            document.getElementById('voice-sort-by').value = 'matchCount:desc';
            document.getElementById('voice-resolve-depth').value = '2';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-did-tx').value = '';
            document.getElementById('voice-include-sigs-toggle').classList.remove('active');
            document.getElementById('voice-include-pubkeys-toggle').classList.remove('active');
            document.getElementById('voice-includes-audio-toggle').classList.remove('active');
            
            // Reset view mode to default grid
            currentViewMode = 'grid';
            document.getElementById('voice-view-as').value = 'grid';
            
            // Clear DID TX error
            clearDidTxError();
            
            // Clear multi-tag filters
            clearAllTagFilters();
            
            // Clear AI-applied multi-tag filters
            delete currentFilters.aiTags;
            delete currentFilters.aiTagsMatchMode;
            delete currentFilters.tags;
            delete currentFilters.tagsMatchMode;
            delete currentFilters.tag;
            
            // Clear DID filters
            delete currentFilters.did;
            delete currentFilters.didTx;
            
            // Clear hasAudio filter
            delete currentFilters.hasAudio;
            
            // Clear applied filters display
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            applyVoiceFilters();
        }

        function toggleVoiceSwitch(elementId) {
            document.getElementById(elementId).classList.toggle('active');
        }

        // ====== ENHANCED VOICE RECORDS LOADING WITH DYNAMIC TEMPLATES ======
        
        async function loadVoiceRecords(reset = false) {
            if (isLoading) return;
            
            try {
                isLoading = true;
                
                if (reset) {
                    currentPage = 1;
                    currentRecords = [];
                    document.getElementById('voice-records-grid').innerHTML = '';
                }
                
                document.getElementById('voice-loading-indicator').classList.remove('hidden');
                
                const params = buildVoiceApiParams();
                console.log(`[Enhanced Records] Loading with resolveDepth=${currentFilters.resolveDepth}, debug=${showDebugInfo}`);
                
                // Add authentication header if available
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`/api/records?${params}`, { headers });
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    hasMoreRecords = data.totalPages > currentPage;
                    displayVoiceRecords(data.records, !reset);
                    updateVoicePaginationInfo(data);
                    updateVoiceTagFilter(data.tagSummary);
                    
                    // Log template analysis for first record if debug is on
                    if (showDebugInfo && data.records.length > 0) {
                        const firstRecord = data.records[0];
                        const templates = analyzeRecordTemplates(firstRecord);
                        console.log(`[Enhanced Records] First record uses templates:`, templates);
                    }
                } else {
                    showVoiceNoResults();
                }
                
                updateVoiceLoadMoreButton();
                
            } catch (error) {
                console.error('[Enhanced Records] Error loading records:', error);
                showVoiceNoResults();
            } finally {
                isLoading = false;
                document.getElementById('voice-loading-indicator').classList.add('hidden');
            }
        }

        function buildVoiceApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.searchMatchMode) {
                params.append('searchMatchMode', currentFilters.searchMatchMode);
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.source && currentFilters.source !== 'all') {
                params.append('source', currentFilters.source);
                console.log('[Enhanced API] Using source filter:', currentFilters.source);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.did) {
                params.append('did', currentFilters.did);
                console.log('[Enhanced API] Using did filter:', currentFilters.did);
            } else if (currentFilters.didTx) {
                params.append('didTx', currentFilters.didTx);
                console.log('[Enhanced API] Using didTx filter:', currentFilters.didTx);
            }
            
            // Handle hasAudio filter (for finding records with audio content)
            if (currentFilters.hasAudio) {
                params.append('hasAudio', 'true');
                console.log('[Enhanced API] Using hasAudio filter: true');
            }
            
            // Handle tag filters (prioritize manual selection over AI)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                // Use manual multi-tag selection (highest priority)
                params.append('tags', currentFilters.tags);
                params.append('tagsMatchMode', currentFilters.tagsMatchMode);
                console.log(`[Enhanced API] Using manual multi-tag filter: ${currentFilters.tags} (${currentFilters.tagsMatchMode})`);
            } else if (currentFilters.aiTags && currentFilters.aiTagsMatchMode) {
                // Use AI-applied multi-tag filters (fallback)
                params.append('tags', currentFilters.aiTags);
                params.append('tagsMatchMode', currentFilters.aiTagsMatchMode);
                console.log(`[Enhanced API] Using AI multi-tag filter: ${currentFilters.aiTags} (${currentFilters.aiTagsMatchMode})`);
            } else if (currentFilters.tag) {
                // Fallback to legacy single tag
                params.append('tags', currentFilters.tag);
                console.log(`[Enhanced API] Using legacy single tag: ${currentFilters.tag}`);
            }

            console.log('[API] Building request with resolveDepth:', currentFilters.resolveDepth);
            return params.toString();
        }

        /**
         * Display voice records using enhanced dynamic template rendering
         */
        function displayVoiceRecords(records, append = false) {
            try {
                const container = document.getElementById('voice-records-grid');
                if (!container) {
                    console.error('[Enhanced Display] voice-records-grid container not found');
                    return;
                }
                
                console.log(`[Enhanced Display] Displaying ${records.length} records, append=${append}, currentViewMode=${currentViewMode}`);
                
                if (!append) {
                    container.innerHTML = '';
                }
                
                // Update container class based on view mode
                const containerClass = currentViewMode === 'list' ? 'records-list' : 'records-grid';
                container.className = containerClass;
                console.log(`[Enhanced Display] Set container class to: ${containerClass}`);
                
                // Group podcast records by show
                const podcastShows = {};
                const nonPodcastRecords = [];
                
                records.forEach(record => {
                    try {
                        if (record.oip?.recordType === 'podcast' && record.data?.podcast?.show) {
                            const showName = record.data.podcast.show;
                            if (!podcastShows[showName]) {
                                podcastShows[showName] = [];
                            }
                            podcastShows[showName].push(record);
                        } else {
                            nonPodcastRecords.push(record);
                        }
                    } catch (recordError) {
                        console.error('[Enhanced Display] Error processing record:', recordError, record);
                        nonPodcastRecords.push(record); // Add to non-podcast as fallback
                    }
                });
                
                const startIndex = currentRecords.length - records.length;
                let recordIndex = startIndex;
                
                // Render podcast shows
                Object.keys(podcastShows).forEach(showName => {
                    try {
                        const episodes = podcastShows[showName];
                        
                        if (currentViewMode === 'list') {
                            // In list view, render individual podcast episodes
                            episodes.forEach(episode => {
                                const episodeCard = createRecordCard(episode, recordIndex, true);
                                container.appendChild(episodeCard);
                                recordIndex++;
                            });
                        } else {
                            // In grid view, use grouped podcast show cards
                            const showCard = createPodcastShowCard(showName, episodes, recordIndex);
                            container.appendChild(showCard);
                            recordIndex += episodes.length;
                        }
                    } catch (showError) {
                        console.error('[Enhanced Display] Error rendering podcast show:', showError, showName);
                    }
                });
                
                // Render non-podcast records
                nonPodcastRecords.forEach(record => {
                    try {
                        const card = createRecordCard(record, recordIndex, currentViewMode === 'list');
                        container.appendChild(card);
                        recordIndex++;
                    } catch (cardError) {
                        console.error('[Enhanced Display] Error creating record card:', cardError, record);
                    }
                });
                
                container.classList.remove('hidden');
                document.getElementById('voice-no-results').classList.add('hidden');
                
                console.log(`[Enhanced Display] Successfully rendered ${records.length} records in ${currentViewMode} view (${Object.keys(podcastShows).length} podcast shows)`);
                
            } catch (error) {
                console.error('[Enhanced Display] Error in displayVoiceRecords:', error);
                
                // Show error message to user
                const container = document.getElementById('voice-records-grid');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f8d7da; color: #721c24; border-radius: 8px; margin: 20px 0;">
                            <h4>❌ Error Displaying Records</h4>
                            <p>There was an error displaying the records. Please try refreshing the page.</p>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                    container.classList.remove('hidden');
                }
            }
        }

        function showVoiceNoResults() {
            document.getElementById('voice-records-grid').classList.add('hidden');
            document.getElementById('voice-no-results').classList.remove('hidden');
        }

        function updateVoicePaginationInfo(data) {
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${currentRecords.length} of ${data.totalRecords || 'many'} records • Page ${currentPage}`;
        }

        function updateVoiceTagFilter(tagSummary) {
            if (!tagSummary) return;
            
            // Store available tags globally for multi-tag system
            availableTags = tagSummary;
            
            // Update legacy single tag filter (hidden, for backward compatibility)
            const legacySelect = document.getElementById('voice-tag-filter');
            if (legacySelect) {
                const currentValue = legacySelect.value;
                legacySelect.innerHTML = '<option value="">All Tags</option>';
                
                tagSummary.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.tag;
                    option.textContent = `${tag.tag} (${tag.count})`;
                    legacySelect.appendChild(option);
                });
                
                legacySelect.value = currentValue;
            }
            
            // Update all multi-tag dropdowns
            updateAllTagDropdowns();
            
            console.log('[Multi-Tag] Updated tag filter with', tagSummary.length, 'available tags');
        }

        function updateVoiceLoadMoreButton() {
            const container = document.getElementById('voice-load-more-container');
            const button = document.getElementById('voice-load-more-btn');
            
            if (hasMoreRecords && currentRecords.length > 0) {
                container.classList.remove('hidden');
                button.disabled = isLoading;
                button.textContent = isLoading ? 'Loading...' : 'Load More Records';
            } else {
                container.classList.add('hidden');
            }
        }

        function loadMoreVoiceRecords() {
            if (!hasMoreRecords || isLoading) return;
            currentPage++;
            loadVoiceRecords(false);
        }

        // Voice-specific text content toggle (for embedded text content)
        async function toggleVoiceTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`voice-textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`voice-textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Text';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading text:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Text';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Show Full Text';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }

        // Text content toggle function
        async function toggleTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Article';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading article:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Article';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Load Full Article';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }

        // Interface update functions
        function updatePostInterface() {
            const postType = document.getElementById('post-type').value;
            const authorSection = document.getElementById('author-section');
            
            if (postType === 'microblog') {
                authorSection.style.display = 'none';
            } else {
                authorSection.style.display = 'block';
            }
        }

        function updatePostSource() {
            const source = document.getElementById('post-source').value;
            const manualInterface = document.getElementById('manual-post-interface');
            const xInterface = document.getElementById('x-post-interface');
            const webArticleInterface = document.getElementById('web-article-interface');
            const publishText = document.getElementById('post-publish-text');
            
            // Hide all interfaces first
            manualInterface.classList.add('hidden');
            xInterface.classList.add('hidden');
            webArticleInterface.classList.add('hidden');
            
            if (source === 'archive-x') {
                xInterface.classList.remove('hidden');
                publishText.textContent = '📱 Archive X Post';
            } else if (source === 'archive-web') {
                webArticleInterface.classList.remove('hidden');
                publishText.textContent = '📰 Archive Web Article';
            } else {
                manualInterface.classList.remove('hidden');
                publishText.textContent = '📤 Publish Post';
            }
        }

        function updateVideoInterface() {
            const source = document.getElementById('video-source').value;
            const inputSection = document.getElementById('video-input-section');
            
            switch (source) {
                case 'manual':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'youtube-archive':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="youtube-url">YouTube URL:</label>
                            <input type="url" id="youtube-url" placeholder="https://youtube.com/watch?v=..." required>
                            <button type="button" onclick="archiveYouTubeVideo()" style="margin-top: 10px; width: 100%;">
                                📥 Archive Video & Get Metadata
                            </button>
                        </div>

                        <div id="youtube-progress" class="hidden" style="margin-top: 20px;">
                            <div class="publish-progress">
                                <h4>📥 Archiving YouTube Video...</h4>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="youtube-progress-bar" style="width: 0%;"></div>
                                </div>
                                <div id="youtube-status" style="margin-top: 10px; font-size: 0.9rem;">Initializing...</div>
                            </div>
                        </div>

                        <div id="youtube-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #ff0000;">
                            <h4>🎥 Video Preview</h4>
                            <div id="youtube-thumbnail" style="margin-bottom: 15px;"></div>
                            <div id="youtube-metadata"></div>
                        </div>
                    `;
                    break;
                case 'direct':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'upload':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-file">Upload Video:</label>
                            <input type="file" id="video-file" accept="video/*">
                            <small>Note: Large files may take time to upload</small>
                        </div>
                    `;
                    break;
            }
        }

        function updateAudioTypeInterface() {
            const audioType = document.getElementById('audio-type').value;
            const musicFields = document.getElementById('music-fields');
            
            if (audioType === 'music') {
                musicFields.style.display = 'block';
            } else {
                musicFields.style.display = 'none';
            }
        }

        function updateAudioInterface() {
            const source = document.getElementById('audio-source').value;
            const inputSection = document.getElementById('audio-input-section');
            
            switch (source) {
                case 'url':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="audio-url">Audio URL:</label>
                            <input type="url" id="audio-url" placeholder="https://example.com/audio.mp3">
                        </div>
                    `;
                    break;
                case 'upload':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="audio-file">Upload Audio File:</label>
                            <input type="file" id="audio-file" accept="audio/*" onchange="updateAudioFilePreview()">
                            <small>Supported: MP3, WAV, FLAC, OGG, AAC, M4A</small>
                        </div>
                        
                        <!-- Detected File Type Display -->
                        <div id="detected-audio-type" class="form-group hidden" style="background: #f0f4ff; padding: 10px; border-radius: 6px; border: 1px solid #c7d2fe;">
                            <label>Detected Audio Type:</label>
                            <div id="detected-audio-display" style="font-weight: bold; color: #3730a3;"></div>
                            <small id="detected-audio-description"></small>
                        </div>
                    `;
                    break;
            }
        }

        function updateAudioFilePreview() {
            const fileInput = document.getElementById('audio-file');
            const detectedTypeDiv = document.getElementById('detected-audio-type');
            const typeDisplay = document.getElementById('detected-audio-display');
            const typeDescription = document.getElementById('detected-audio-description');
            
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const mimeType = file.type;
                let description = '';
                
                if (mimeType.startsWith('audio/')) {
                    description = 'Will create an OIP audio record with BitTorrent distribution and streaming support';
                } else {
                    description = 'Unsupported file type - please select an audio file';
                }
                
                typeDisplay.textContent = 'AUDIO Record';
                typeDescription.textContent = description;
                detectedTypeDiv.classList.remove('hidden');
                
                // Auto-populate name if empty
                const nameInput = document.getElementById('audio-title');
                if (!nameInput.value) {
                    // Use filename without extension as default name
                    const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
                    nameInput.value = nameWithoutExt;
                }

                // Try to extract audio duration and other metadata
                extractAudioMetadata(file);
            } else {
                detectedTypeDiv.classList.add('hidden');
            }
        }

        async function extractAudioMetadata(file) {
            try {
                const audio = document.createElement('audio');
                audio.preload = 'metadata';
                
                audio.onloadedmetadata = () => {
                    const duration = Math.floor(audio.duration) || 0;
                    const durationInput = document.getElementById('audio-duration');
                    if (durationInput && !durationInput.value && duration > 0) {
                        durationInput.value = duration;
                    }
                    
                    console.log(`🎵 Auto-detected audio duration: ${duration} seconds`);
                    URL.revokeObjectURL(audio.src);
                };
                
                audio.onerror = () => {
                    console.warn('Could not extract audio metadata');
                    URL.revokeObjectURL(audio.src);
                };
                
                audio.src = URL.createObjectURL(file);
            } catch (error) {
                console.warn('Could not extract audio metadata:', error);
            }
        }

        // Dynamic ingredient/exercise management
        function addIngredient() {
            const container = document.getElementById('ingredients-container');
            const newRow = document.createElement('div');
            newRow.className = 'ingredient-row';
            newRow.style = 'display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Amount" class="ingredient-amount">
                <input type="text" placeholder="Unit" class="ingredient-unit">
                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                <button type="button" onclick="removeIngredient(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeIngredient(button) {
            button.parentElement.remove();
        }

        function addExercise() {
            const container = document.getElementById('exercises-container');
            const newRow = document.createElement('div');
            newRow.className = 'exercise-row';
            newRow.style = 'display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Exercise name" class="exercise-name">
                <input type="text" placeholder="Sets" class="exercise-sets">
                <input type="text" placeholder="Reps" class="exercise-reps">
                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                <button type="button" onclick="removeExercise(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeExercise(button) {
            button.parentElement.remove();
        }

        // Equipment management functions
        let availableEquipment = [];

        async function loadEquipment() {
            try {
                console.log('📋 Loading equipment from API...');
                
                // Get the API base URL from environment variable or use current host as fallback
                const apiBaseUrl = window.API_BASE_URL || window.location.origin;
                const equipmentUrl = `${apiBaseUrl}/api/records?resolveDepth=0&recordType=fitnessEquipment&noDuplicates=true`;
                
                console.log(`🔗 Using API base URL: ${apiBaseUrl}`);
                
                const response = await fetch(equipmentUrl);
                
                if (response.ok) {
                    const data = await response.json();
                    availableEquipment = data.records || [];
                    console.log(`✅ Loaded ${availableEquipment.length} equipment items`);
                    updateEquipmentDropdowns();
                } else {
                    console.warn('⚠️ Failed to load equipment from API');
                    updateEquipmentDropdowns();
                }
            } catch (error) {
                console.warn('⚠️ Error loading equipment:', error);
                updateEquipmentDropdowns();
            }
        }

        function updateEquipmentDropdowns() {
            const selects = document.querySelectorAll('.equipment-select');
            selects.forEach(select => {
                // Clear existing options except the first one
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                
                // Add equipment options
                availableEquipment.forEach(equipment => {
                    const option = document.createElement('option');
                    const did = equipment.oip?.did || '';
                    const name = equipment.data?.basic?.name || 'Unknown Equipment';
                    
                    option.value = did;
                    option.textContent = name;
                    
                    // Debug logging
                    console.log(`🔧 Equipment option: "${name}" -> DID: "${did}"`);
                    
                    select.appendChild(option);
                });
            });
        }

        function addEquipmentRow(containerId) {
            const container = document.getElementById(containerId);
            const newRow = document.createElement('div');
            newRow.className = 'equipment-row';
            newRow.style = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: end;';
            newRow.innerHTML = `
                <select class="equipment-select" style="flex: 1;">
                    <option value="">Select equipment...</option>
                </select>
                <button type="button" onclick="removeEquipmentRow(this)" class="btn-small" title="Remove equipment">✕</button>
            `;
            container.appendChild(newRow);
            updateEquipmentDropdowns();
        }

        function removeEquipmentRow(button) {
            button.parentElement.remove();
        }

        function getEquipmentValues(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            
            const selects = container.querySelectorAll('.equipment-select');
            const values = [];
            selects.forEach((select, index) => {
                if (select.value && select.value.trim()) {
                    const value = select.value.trim();
                    values.push(value);
                    console.log(`🔧 Equipment ${containerId} [${index}]: Selected "${select.options[select.selectedIndex]?.textContent}" -> DID: "${value}"`);
                }
            });
            console.log(`🔧 Equipment ${containerId} values:`, values);
            return values;
        }

        // Exercise measurement type handler
        function updateExerciseMeasurementFields() {
            const measurementType = document.getElementById('exercise-measurement-type').value;
            const repsFields = document.getElementById('exercise-reps-fields');
            const timeFields = document.getElementById('exercise-time-fields');
            
            if (measurementType === 'timed' || measurementType === 'hold' || measurementType === 'maxdur') {
                repsFields.style.display = 'none';
                timeFields.style.display = 'block';
            } else {
                repsFields.style.display = 'flex';
                timeFields.style.display = 'none';
            }
        }

        // X Post Scraping Functions
        async function scrapeXPost() {
            const url = document.getElementById('x-post-url').value;
            const statusDiv = document.getElementById('x-post-status');
            const previewDiv = document.getElementById('x-post-preview');
            
            if (!url || (!url.includes('x.com') && !url.includes('twitter.com'))) {
                showXPostStatus('Please enter a valid X/Twitter URL', 'error');
                return;
            }

            try {
                showXPostStatus('🔍 Fetching post data...', 'loading');
                
                const response = await fetch('/api/scrape/x-post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();
                console.log('[X Post] Received data:', data); // Debug log

                if (response.ok) {
                    displayXPostPreview(data);
                    showXPostStatus('✅ Post data fetched successfully!', 'success');
                } else {
                    console.error('[X Post] Error response:', data);
                    let errorMessage = data.error || 'Unknown error occurred';
                    
                    // Provide more helpful error messages
                    if (errorMessage.includes('Bearer Token')) {
                        errorMessage = `
                            <div style="text-align: left; line-height: 1.5;">
                                <strong>🔑 X API Setup Required</strong><br><br>
                                To reliably archive X posts, you need X API access:<br><br>
                                <strong>1. Get X API Access:</strong><br>
                                • Go to <a href="https://developer.twitter.com/en/portal/dashboard" target="_blank" style="color: #1da1f2;">developer.twitter.com</a><br>
                                • Create a developer account and app<br>
                                • Get your Bearer Token<br><br>
                                <strong>2. Configure Server:</strong><br>
                                • Add X_BEARER_TOKEN to environment variables<br>
                                • Restart the server<br><br>
                                <em>Without this, X post archiving is unreliable due to X.com login requirements.</em>
                            </div>
                        `;
                    } else if (errorMessage.includes('login') || errorMessage.includes('protected')) {
                        errorMessage = '❌ This X post requires login or is from a protected account. Set up X API access for reliable extraction.';
                    } else if (errorMessage.includes('rate limit')) {
                        errorMessage = '❌ Rate limited by X. Please wait a few minutes and try again.';
                    } else if (errorMessage.includes('Failed to retrieve')) {
                        errorMessage = '❌ Could not extract post data. X may have changed their structure or the post may be unavailable.';
                    }
                    
                    showXPostStatus(errorMessage, 'error');
                }
            } catch (error) {
                console.error('[X Post] Network error:', error);
                let errorMessage = error.message;
                
                if (errorMessage.includes('Failed to fetch')) {
                    errorMessage = '❌ Network error. Please check your connection and try again.';
                } else if (errorMessage.includes('timeout')) {
                    errorMessage = '❌ Request timed out. X may be slow to respond.';
                }
                
                showXPostStatus(`❌ ${errorMessage}`, 'error');
            }
        }

        // Web Article Scraping Functions
        async function scrapeWebArticle() {
            const url = document.getElementById('web-article-url').value;
            
            if (!url) {
                showWebArticleStatus('Please enter a valid article URL', 'error');
                return;
            }

            // Validate URL format
            try {
                new URL(url);
            } catch (error) {
                showWebArticleStatus('Please enter a valid URL format', 'error');
                return;
            }

            try {
                // Show progress
                document.getElementById('web-article-progress').classList.remove('hidden');
                document.getElementById('web-article-preview').classList.add('hidden');
                document.getElementById('web-article-result').classList.add('hidden');
                
                updateWebArticleProgress(5, 'Starting article archival...');
                
                // Start the scraping process
                const response = await fetch('/api/scrape/web-article', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();
                console.log('[Web Article] Received scrape ID:', data);

                if (response.ok && data.scrapeId) {
                    // Open EventSource stream to receive real-time updates
                    openWebArticleStream(data.scrapeId);
                } else {
                    throw new Error(data.error || 'Failed to start article archival');
                }
            } catch (error) {
                console.error('[Web Article] Error:', error);
                showWebArticleStatus(`❌ Error: ${error.message}`, 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
            }
        }

        function openWebArticleStream(scrapeId) {
            const eventSource = new EventSource(`/api/scrape/open-stream?streamId=${scrapeId}`);
            
            eventSource.onopen = function() {
                console.log('[Web Article] Stream opened for scrapeId:', scrapeId);
                updateWebArticleProgress(10, 'Connected to server...');
            };

            eventSource.onmessage = function(event) {
                console.log('[Web Article] Received message:', event);
            };

            eventSource.addEventListener('initializing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Initializing:', data);
                updateWebArticleProgress(15, data.data?.message || 'Initializing browser...');
            });

            eventSource.addEventListener('loading', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Loading:', data);
                updateWebArticleProgress(25, data.data?.message || 'Loading page...');
            });

            eventSource.addEventListener('processing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Processing:', data);
                updateWebArticleProgress(40, data.data?.message || 'Processing content...');
            });

            eventSource.addEventListener('screenshot', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Screenshot:', data);
                updateWebArticleProgress(55, data.data?.message || 'Taking screenshot...');
            });

            eventSource.addEventListener('parsing', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Parsing:', data);
                updateWebArticleProgress(70, data.data?.message || 'Parsing article...');
            });

            eventSource.addEventListener('initialData', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Initial data:', data);
                updateWebArticleProgress(75, 'Article data extracted...');
                displayWebArticlePreview(data.data);
            });

            eventSource.addEventListener('finalData', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Final data:', data);
                updateWebArticleProgress(90, 'Finalizing article...');
                // Store the final data for publishing
                window.scrapedWebArticleData = data.data;
            });

            eventSource.addEventListener('archived', function(event) {
                const data = JSON.parse(event.data);
                console.log('[Web Article] Archived:', data);
                updateWebArticleProgress(100, 'Article archived successfully!');
                showWebArticleStatus(`✅ Article archived successfully! DID: ${data.data?.archived}`, 'success');
                setTimeout(() => {
                    document.getElementById('web-article-progress').classList.add('hidden');
                }, 2000);
                eventSource.close();
            });

            eventSource.addEventListener('error', function(event) {
                const data = JSON.parse(event.data);
                console.error('[Web Article] Error:', data);
                showWebArticleStatus(`❌ Error: ${data.data?.message || 'Unknown error occurred'}`, 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
                eventSource.close();
            });

            eventSource.onerror = function(event) {
                console.error('[Web Article] Stream error:', event);
                showWebArticleStatus('❌ Connection error occurred', 'error');
                document.getElementById('web-article-progress').classList.add('hidden');
                eventSource.close();
            };
        }

        function updateWebArticleProgress(percent, status) {
            document.getElementById('web-article-progress-bar').style.width = `${percent}%`;
            document.getElementById('web-article-status').textContent = status;
        }

        function displayWebArticlePreview(data) {
            const previewDiv = document.getElementById('web-article-preview');
            const contentDiv = document.getElementById('web-article-content');
            const metaDiv = document.getElementById('web-article-meta');

            console.log('[Web Article] Displaying preview for data:', data);

            const title = data.title || 'Unknown Title';
            const description = data.description || 'No description available';
            const byline = data.byline || 'Unknown Author';
            const domain = data.domain || 'Unknown Domain';
            const publishDate = data.publishDate ? new Date(data.publishDate * 1000).toLocaleDateString() : 'Unknown Date';

            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px; color: #28a745;">${title}</div>
                <div style="line-height: 1.4; margin-bottom: 10px; color: #666;">${description}</div>
                ${data.screenshotURL ? `
                    <div style="margin-top: 10px;">
                        <img src="${data.screenshotURL}" 
                             style="max-width: 100%; max-height: 200px; border-radius: 8px; border: 1px solid #ddd;" 
                             alt="Article screenshot"
                             onerror="this.style.display='none';">
                    </div>
                ` : ''}
            `;

            metaDiv.innerHTML = `
                <strong>Author:</strong> ${byline}<br>
                <strong>Domain:</strong> ${domain}<br>
                <strong>Published:</strong> ${publishDate}<br>
                <strong>URL:</strong> <a href="${data.url}" target="_blank" style="color: #28a745;">${data.url}</a><br>
                ${data.tags && data.tags.length > 0 ? `<strong>Tags:</strong> ${data.tags.join(', ')}<br>` : ''}
                ${data.summaryTTS ? `<strong>Audio Summary:</strong> <a href="${data.summaryTTS}" target="_blank">🎵 Listen</a><br>` : ''}
            `;

            previewDiv.classList.remove('hidden');
        }

        function showWebArticleStatus(message, type) {
            const statusDiv = document.getElementById('web-article-result');
            statusDiv.className = 'hidden';
            
            if (type === 'error') {
                statusDiv.className = 'error-message';
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            } else if (type === 'success') {
                statusDiv.className = 'success-message';
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else {
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.style.border = '1px solid #2196f3';
            }
            
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden');
        }

        function displayXPostPreview(data) {
            const previewDiv = document.getElementById('x-post-preview');
            const contentDiv = document.getElementById('x-post-content');
            const metaDiv = document.getElementById('x-post-meta');

            console.log('[X Post] Displaying preview for data:', data); // Debug log

            // Store data for publishing
            window.scrapedXPostData = data;

            // Handle different possible data structures from the API
            const author = data.author || data.username || data.user?.screen_name || data.user?.username || '';
            const text = data.text || data.full_text || data.tweet_text || data.content || '';
            const postUrl = data.url || data.original_url || url;
            const postDate = data.date || data.created_at || data.timestamp || '';
            const images = data.images || data.media || data.photos || [];

            // Ensure we have an array for images
            const imageArray = Array.isArray(images) ? images : (images ? [images] : []);

            // Check if we have any meaningful data
            const hasData = author.trim() || text.trim() || imageArray.length > 0;
            
            if (!hasData) {
                contentDiv.innerHTML = `
                    <div style="color: #dc3545; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <strong>⚠️ No content extracted</strong><br>
                        This X post may be:<br>
                        • From a protected/private account<br>
                        • Requiring login to view<br>
                        • Deleted or unavailable<br>
                        • Using new X.com structure we haven't adapted to yet
                    </div>
                `;
            } else {
                contentDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 8px; color: #1da1f2;">
                        ${author ? `@${author}` : 'Unknown Author'}
                    </div>
                    <div style="line-height: 1.4; margin-bottom: 10px; white-space: pre-wrap;">
                        ${text || '<em style="color: #666;">No text content found</em>'}
                    </div>
                    ${imageArray.length > 0 ? `
                        <div style="margin-top: 10px;">
                            <strong>Images (${imageArray.length}):</strong><br>
                            ${imageArray.map((img, index) => `
                                <img src="${img}" 
                                     style="max-width: 150px; max-height: 150px; margin: 5px; border-radius: 8px; border: 1px solid #ddd;" 
                                     alt="Tweet image ${index + 1}"
                                     onerror="this.style.display='none';">
                            `).join('')}
                        </div>
                    ` : '<div style="color: #666; font-style: italic;">No images</div>'}
                `;
            }

            metaDiv.innerHTML = `
                <strong>Original URL:</strong> <a href="${postUrl}" target="_blank" style="color: #1da1f2;">${postUrl}</a><br>
                <strong>Date:</strong> ${postDate}<br>
                <strong>Author:</strong> @${author}<br>
                <strong>Images:</strong> ${imageArray.length}<br>
                <strong>Text Length:</strong> ${text.length} characters
            `;

            previewDiv.classList.remove('hidden');

            // Also log what we're displaying for debugging
            console.log('[X Post] Preview data:', {
                author,
                text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
                postUrl,
                postDate,
                imageCount: imageArray.length
            });
        }

        function showXPostStatus(message, type) {
            const statusDiv = document.getElementById('x-post-status');
            statusDiv.className = 'hidden';
            
            if (type === 'error') {
                statusDiv.className = 'error-message';
            } else if (type === 'success') {
                statusDiv.className = 'success-message';
            } else {
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.style.border = '1px solid #2196f3';
            }
            
            // Use innerHTML for rich content (like API setup instructions)
            if (message.includes('<')) {
                statusDiv.innerHTML = message;
            } else {
                statusDiv.textContent = message;
            }
            statusDiv.classList.remove('hidden');
        }

        // YouTube Video Archiving Functions
        async function archiveYouTubeVideo() {
            const url = document.getElementById('youtube-url').value;
            const progressDiv = document.getElementById('youtube-progress');
            const previewDiv = document.getElementById('youtube-preview');
            
            if (!url || (!url.includes('youtube.com') && !url.includes('youtu.be'))) {
                alert('Please enter a valid YouTube URL');
                return;
            }

            try {
                progressDiv.classList.remove('hidden');
                updateYouTubeProgress(10, 'Extracting video metadata...');

                const response = await fetch('/api/scrape/youtube-archive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                
                updateYouTubeProgress(30, 'Downloading video...');

                // Poll for completion
                const checkProgress = async () => {
                    try {
                        const progressResponse = await fetch(`/api/scrape/youtube-progress?taskId=${data.taskId}`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });
                        
                        const progressData = await progressResponse.json();
                        
                        if (progressData.status === 'complete') {
                            displayYouTubePreview(progressData.result);
                            updateYouTubeProgress(100, 'Video archived successfully!');
                            setTimeout(() => progressDiv.classList.add('hidden'), 2000);
                        } else if (progressData.status === 'error') {
                            updateYouTubeProgress(0, `Error: ${progressData.error}`);
                        } else {
                            updateYouTubeProgress(progressData.progress || 50, progressData.message || 'Processing...');
                            setTimeout(checkProgress, 2000);
                        }
                    } catch (error) {
                        updateYouTubeProgress(0, `Error: ${error.message}`);
                    }
                };

                setTimeout(checkProgress, 2000);

            } catch (error) {
                updateYouTubeProgress(0, `Error: ${error.message}`);
            }
        }

        function updateYouTubeProgress(percent, status) {
            document.getElementById('youtube-progress-bar').style.width = `${percent}%`;
            document.getElementById('youtube-status').textContent = status;
        }

        function extractVideoId(url) {
            const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
            return match ? match[1] : null;
        }

        function displayYouTubePreview(data) {
            const previewDiv = document.getElementById('youtube-preview');
            const thumbnailDiv = document.getElementById('youtube-thumbnail');
            const metadataDiv = document.getElementById('youtube-metadata');

            // Store data for publishing
            window.archivedYouTubeData = data;

            // Auto-populate form fields
            document.getElementById('video-title').value = data.title || '';
            document.getElementById('video-description').value = data.description || '';
            document.getElementById('video-channel').value = data.uploader || '';
            document.getElementById('video-duration').value = data.duration ? Math.ceil(data.duration / 60) : '';
            document.getElementById('video-thumbnail').value = data.thumbnail || '';
            
            // Set tags from YouTube tags
            if (data.tags && data.tags.length > 0) {
                document.getElementById('video-tags').value = data.tags.slice(0, 10).join(', ');
            }

            thumbnailDiv.innerHTML = data.thumbnail ? 
                `<img src="${data.thumbnail}" style="max-width: 200px; border-radius: 8px;">` : 
                '<div style="color: #666;">No thumbnail available</div>';

            metadataDiv.innerHTML = `
                <div><strong>Title:</strong> ${data.title || 'Unknown'}</div>
                <div><strong>Channel:</strong> ${data.uploader || 'Unknown'}</div>
                <div><strong>Duration:</strong> ${data.duration ? formatDuration(data.duration) : 'Unknown'}</div>
                <div><strong>Upload Date:</strong> ${data.upload_date || 'Unknown'}</div>
                <div><strong>Views:</strong> ${data.view_count ? data.view_count.toLocaleString() : 'Unknown'}</div>
                <div><strong>Resolution:</strong> ${data.resolution || 'Unknown'}</div>
                <div><strong>Video URL:</strong> <a href="${data.video_url}" target="_blank">Archived Video</a></div>
            `;

            previewDiv.classList.remove('hidden');
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Exercise Resolution for Workouts
        async function resolveWorkoutExercises() {
            const exerciseRows = document.querySelectorAll('.exercise-row');
            const exercises = [];
            const exerciseNames = [];

            exerciseRows.forEach(row => {
                const name = row.querySelector('.exercise-name').value.trim();
                if (name) {
                    exerciseNames.push(name.toLowerCase());
                    exercises.push({
                        name: name,
                        sets: parseInt(row.querySelector('.exercise-sets').value) || 3,
                        reps: row.querySelector('.exercise-reps').value || '12',
                        rest_seconds: parseInt(row.querySelector('.exercise-rest').value) || 60
                    });
                }
            });

            if (exerciseNames.length === 0) {
                throw new Error('Please add at least one exercise');
            }

            // Check if non-standard workout
            const isNonStandard = document.getElementById('workout-non-standard').checked;
            if (isNonStandard) {
                return { exercises, exerciseDidRefs: null };
            }

            try {
                showMessage('publish-status', '🔍 Looking up exercises in database...', 'info');

                // Look up exercises in OIP
                const response = await fetch('/api/workout/resolve-exercises', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ exerciseNames })
                });

                const data = await response.json();

                if (response.ok) {
                    // Update exercise names with DID references where available
                    const resolvedExercises = exercises.map(exercise => {
                        const didRef = data.exerciseDidRefs[exercise.name.toLowerCase()];
                        return {
                            ...exercise,
                            exerciseDidRef: didRef || exercise.name
                        };
                    });

                    const missingCount = Object.values(data.exerciseDidRefs).filter(ref => ref === null).length;
                    if (missingCount > 0) {
                        showMessage('publish-status', `✅ Found ${exerciseNames.length - missingCount} exercises, creating ${missingCount} new ones from Kaggle dataset...`, 'info');
                    } else {
                        showMessage('publish-status', '✅ All exercises found in database!', 'success');
                    }

                    return { exercises: resolvedExercises, exerciseDidRefs: data.exerciseDidRefs };
                } else {
                    throw new Error(data.error || 'Failed to resolve exercises');
                }
            } catch (error) {
                console.error('Exercise resolution error:', error);
                showMessage('publish-status', `⚠️ Exercise lookup failed, publishing with exercise names: ${error.message}`, 'warning');
                return { exercises, exerciseDidRefs: null };
            }
        }

        // ==================== EXERCISE BUNDLE FUNCTIONS ====================
        
        /**
         * Initialize Exercise Bundle Interface
         */
        async function initializeExerciseBundleInterface() {
            console.log('🎯 Initializing Exercise Bundle Interface');
            
            // Load all data in parallel
            await Promise.all([
                loadOrganizationsForBundle(),
                loadExistingEquipmentForBundle(),
                loadExistingGifsForBundle(),
                loadExistingIconsForBundle()
            ]);
            
            console.log('📊 Data loaded:', {
                orgs: bundleOrganizations.length,
                equipment: bundleExistingEquipment.length,
                gifs: bundleExistingGifs.length,
                icons: bundleExistingIcons.length
            });
            
            // Add first equipment item (creates DOM elements)
            addBundleEquipmentItem();
            
            // Wait for DOM to be fully updated before populating dropdowns
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Initialize GIF storage type handler and dropdowns (will now have orgs and GIFs available)
            updateBundleGifStorageType();
            updateBundleGifDropdown();
            updateEquipIconDropdowns();  // Make sure icon dropdowns are populated
            updateBundleEquipmentDropdowns(); // Make sure equipment dropdowns are populated
            
            console.log('✅ Exercise Bundle Interface initialized');
        }

        /**
         * Global variables to store organizations and existing records
         */
        let bundleOrganizations = [];
        let bundleExistingGifs = [];
        let bundleExistingIcons = [];

        /**
         * Load organizations for bundle dropdowns
         */
        async function loadOrganizationsForBundle() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/organizations`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    // The API returns organizationsInDB array
                    const orgs = data.organizationsInDB || [];
                    
                    // Transform to the format we need
                    bundleOrganizations = orgs.map(org => ({
                        did: org.oip?.did,
                        name: org.data?.name,
                        handle: org.data?.orgHandle
                    }));
                    
                    console.log(`✅ Loaded ${bundleOrganizations.length} organizations for bundle`, bundleOrganizations);
                }
            } catch (error) {
                console.error('Error loading organizations:', error);
            }
        }

        /**
         * Load existing GIFs for bundle
         */
        async function loadExistingGifsForBundle() {
            try {
                console.log('📋 [Bundle] Loading existing GIFs from API...');
                console.log('[Bundle] API URL:', `${API_BASE_URL}/api/records?recordType=multiResolutionGif&noDuplicates=true`);
                
                const response = await fetch(`${API_BASE_URL}/api/records?recordType=multiResolutionGif&noDuplicates=true`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[Bundle] FULL API Response:', result);
                    console.log('[Bundle] Response keys:', Object.keys(result));
                    console.log('[Bundle] result.records exists?', !!result.records);
                    console.log('[Bundle] result.records length:', result.records?.length);
                    
                    bundleExistingGifs = result.records || [];
                    console.log(`✅ [Bundle] Loaded ${bundleExistingGifs.length} GIF records`);
                    
                    if (bundleExistingGifs.length > 0) {
                        console.log('[Bundle] First GIF record (full):', JSON.stringify(bundleExistingGifs[0], null, 2));
                        console.log('[Bundle] Sample GIF oip object:', bundleExistingGifs[0].oip);
                        console.log('[Bundle] Sample GIF DID:', bundleExistingGifs[0].oip?.did || bundleExistingGifs[0].oip?.didTx);
                        console.log('[Bundle] Sample GIF name:', bundleExistingGifs[0].data?.basic?.name);
                    } else {
                        console.warn('⚠️ [Bundle] No GIF records in response!');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('❌ [Bundle] Failed to load GIFs from API:', response.status, errorText);
                }
            } catch (error) {
                console.error('❌ [Bundle] Error loading GIFs:', error);
            }
        }

        /**
         * Load existing icons for bundle
         */
        async function loadExistingIconsForBundle() {
            try {
                console.log('📋 [Bundle] Loading existing icons from API...');
                console.log('[Bundle] API URL:', `${API_BASE_URL}/api/records?recordType=image&noDuplicates=true&search=icon`);
                
                const response = await fetch(`${API_BASE_URL}/api/records?recordType=image&noDuplicates=true&search=icon`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[Bundle] FULL API Response:', result);
                    console.log('[Bundle] Response keys:', Object.keys(result));
                    console.log('[Bundle] result.records exists?', !!result.records);
                    console.log('[Bundle] result.records length:', result.records?.length);
                    
                    bundleExistingIcons = result.records || [];
                    console.log(`✅ [Bundle] Loaded ${bundleExistingIcons.length} icon records`);
                    
                    if (bundleExistingIcons.length > 0) {
                        console.log('[Bundle] First icon record (full):', JSON.stringify(bundleExistingIcons[0], null, 2));
                        console.log('[Bundle] Sample icon oip object:', bundleExistingIcons[0].oip);
                        console.log('[Bundle] Sample icon DID:', bundleExistingIcons[0].oip?.did || bundleExistingIcons[0].oip?.didTx);
                        console.log('[Bundle] Sample icon name:', bundleExistingIcons[0].data?.basic?.name);
                    } else {
                        console.warn('⚠️ [Bundle] No icon records in response!');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('❌ [Bundle] Failed to load icons from API:', response.status, errorText);
                }
            } catch (error) {
                console.error('❌ [Bundle] Error loading icons:', error);
            }
        }

        /**
         * Populate organization dropdown for a specific element
         */
        function populateBundleOrgDropdown(selectElement) {
            if (!selectElement) {
                console.warn('[Bundle] populateBundleOrgDropdown called with null selectElement');
                return;
            }
            
            console.log('[Bundle] Populating dropdown with', bundleOrganizations.length, 'organizations');
            
            selectElement.innerHTML = '<option value="">Select Organization</option>';
            
            bundleOrganizations.forEach((org, index) => {
                const option = document.createElement('option');
                option.value = org.did || '';
                // Show handle (name)
                option.textContent = org.handle ? `${org.handle} (${org.name || 'Unnamed'})` : (org.name || 'Unnamed Organization');
                selectElement.appendChild(option);
                console.log(`[Bundle] Added option ${index + 1}:`, option.textContent, '=', option.value);
            });
            
            console.log('[Bundle] Dropdown now has', selectElement.options.length, 'total options');
        }

        /**
         * Update GIF storage type to show/hide access level
         */
        /**
         * Toggle bundle GIF mode (create vs existing)
         */
        function toggleBundleGifMode() {
            const mode = document.getElementById('bundle-gif-mode')?.value;
            const existingGroup = document.getElementById('bundle-gif-existing-group');
            const createSection = document.getElementById('bundle-gif-create-section');
            
            if (mode === 'existing') {
                existingGroup?.classList.remove('hidden');
                createSection?.classList.add('hidden');
                updateBundleGifDropdown();
            } else {
                existingGroup?.classList.add('hidden');
                createSection?.classList.remove('hidden');
            }
        }

        /**
         * Update bundle GIF dropdown
         */
        function updateBundleGifDropdown() {
            const select = document.getElementById('bundle-gif-existing-select');
            if (!select) {
                console.warn('[Bundle] ❌ GIF dropdown not found in DOM');
                return;
            }
            
            console.log(`[Bundle] Populating GIF dropdown with ${bundleExistingGifs.length} items`);
            console.log(`[Bundle] GIF dropdown element:`, select);
            console.log(`[Bundle] Sample GIF data structure:`, bundleExistingGifs[0]);
            
            select.innerHTML = '';
            
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = bundleExistingGifs.length > 0 
                ? 'Select GIF Collection' 
                : 'No GIF collections found';
            select.appendChild(placeholder);
            
            bundleExistingGifs.forEach((record, idx) => {
                const option = document.createElement('option');
                const did = record.oip?.did || record.oip?.didTx || '';
                const name = record.data?.basic?.name || 'Unknown GIF';
                
                if (idx < 3) {
                    console.log(`[Bundle] GIF ${idx}: DID=${did}, name=${name}, full record:`, record);
                }
                
                if (!did) {
                    console.warn(`[Bundle] ⚠️ GIF ${idx} has no DID!`, record);
                }
                
                option.value = did;
                option.textContent = name;
                select.appendChild(option);
            });
            
            console.log(`✅ [Bundle] GIF dropdown populated with ${bundleExistingGifs.length} items, ${select.options.length} total options`);
        }

        function updateBundleGifStorageType() {
            const storageType = document.getElementById('bundle-gif-storage')?.value;
            const accessGroup = document.getElementById('bundle-gif-access-group');
            
            console.log('[Bundle GIF] Storage type:', storageType, 'Orgs loaded:', bundleOrganizations.length);
            
            if (storageType === 'gun') {
                accessGroup?.classList.remove('hidden');
                // Force populate org dropdown immediately when storage is GUN and access is Organization
                setTimeout(() => {
                    const accessLevel = document.getElementById('bundle-gif-access')?.value;
                    console.log('[Bundle GIF] Current access level after show:', accessLevel);
                    if (accessLevel === 'organization') {
                        const orgSelect = document.getElementById('bundle-gif-org');
                        const orgGroup = document.getElementById('bundle-gif-org-group');
                        if (orgGroup) orgGroup.classList.remove('hidden');
                        if (orgSelect && bundleOrganizations.length > 0) {
                            console.log('[Bundle GIF] Force populating org dropdown on init');
                            populateBundleOrgDropdown(orgSelect);
                        }
                    }
                }, 100);
            } else {
                accessGroup?.classList.add('hidden');
            }
        }

        /**
         * Update GIF access level to show/hide organization dropdown
         */
        function updateBundleGifAccess() {
            const accessLevel = document.getElementById('bundle-gif-access')?.value;
            const orgGroup = document.getElementById('bundle-gif-org-group');
            const orgSelect = document.getElementById('bundle-gif-org');
            
            console.log('[Bundle GIF] Access level changed to:', accessLevel, 'Orgs loaded:', bundleOrganizations.length);
            
            if (accessLevel === 'organization') {
                orgGroup?.classList.remove('hidden');
                // Populate organization dropdown
                if (orgSelect) {
                    console.log('[Bundle GIF] Populating org dropdown with', bundleOrganizations.length, 'orgs');
                    populateBundleOrgDropdown(orgSelect);
                }
            } else {
                orgGroup?.classList.add('hidden');
            }
        }

        /**
         * Add equipment item with icon and equipment subsections
         */
        function addBundleEquipmentItem() {
            const container = document.getElementById('bundle-equipment-container');
            if (!container) return;
            
            const itemId = `equipment-item-${Date.now()}`;
            const iconId = `${itemId}-icon`;
            const equipId = `${itemId}-equip`;
            
            const item = document.createElement('div');
            item.id = itemId;
            item.className = 'equipment-item';
            item.style.cssText = 'border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: #f9f9f9;';
            
            const equipmentNumber = container.querySelectorAll('.equipment-item').length + 1;
            
            item.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <strong style="font-size: 16px;">Equipment ${equipmentNumber}</strong>
                    <button type="button" onclick="removeBundleEquipmentItem('${itemId}')" class="btn-small" style="background: #f44336; color: white;">
                        Remove
                    </button>
                </div>
                
                <!-- Equipment Section (MOVED TO TOP) -->
                <div style="border: 1px solid #f3e5f5; border-radius: 6px; padding: 12px; margin-bottom: 12px; background: white;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                        <span style="background: #9c27b0; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">🏋️</span>
                        <strong>Equipment Details</strong>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px; font-weight: 600;">Mode:</label>
                        <select class="equip-mode" onchange="toggleEquipmentMode('${itemId}')" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="create">Create New Equipment</option>
                            <option value="existing">Select Existing Equipment</option>
                        </select>
                    </div>
                    
                    <!-- Select Existing Equipment (hidden by default) -->
                    <div class="equip-existing-section hidden" style="margin-bottom: 8px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Select Equipment:</label>
                        <select class="equip-existing-select equipment-select-bundle" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="">Loading equipment...</option>
                        </select>
                    </div>
                    
                    <!-- Create New Equipment Fields (shown by default) -->
                    <div class="equip-create-section">
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Equipment Name:</label>
                            <div style="display: flex; gap: 6px; align-items: stretch;">
                                <input type="text" class="equip-name" placeholder="e.g., Barbell" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <button type="button" class="equip-copy-btn btn-small btn-secondary" onclick="copyEquipmentFromLatest('${itemId}')" title="Copy from latest matching equipment" style="font-size: 11px; padding: 4px 8px; white-space: nowrap;">
                                    📋 Copy
                                </button>
                                <button type="button" class="equip-ai-btn btn-small" onclick="fillEquipmentWithAI('${itemId}')" title="Fill with AI" style="font-size: 11px; padding: 4px 8px; white-space: nowrap;">
                                    🤖 AI
                                </button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Description:</label>
                            <textarea class="equip-description" rows="2" placeholder="Brief description..." style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"></textarea>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Category:</label>
                            <select class="equip-category" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="Weights">Weights</option>
                                <option value="Cardio">Cardio</option>
                                <option value="Bodyweight">Bodyweight</option>
                                <option value="Flexibility">Flexibility</option>
                                <option value="Functional">Functional</option>
                                <option value="Accessories">Accessories</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Subcategory:</label>
                            <input type="text" class="equip-subcategory" placeholder="e.g., Free Weights, Resistance Bands" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Muscle Groups (comma-separated):</label>
                            <input type="text" class="equip-muscle-groups" placeholder="chest, back, shoulders, arms, legs" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <small style="font-size: 11px; color: #666;">Muscle groups this equipment can target</small>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Difficulty Level:</label>
                            <select class="equip-difficulty" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="Beginner">Beginner</option>
                                <option value="Intermediate">Intermediate</option>
                                <option value="Advanced">Advanced</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Space Required:</label>
                            <select class="equip-space" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="Minimal Space">Minimal Space</option>
                                <option value="Small Space">Small Space</option>
                                <option value="Medium Space">Medium Space</option>
                                <option value="Large Space">Large Space</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Portability:</label>
                            <select class="equip-portability" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="Portable">Portable</option>
                                <option value="Semi-Portable">Semi-Portable</option>
                                <option value="Stationary">Stationary</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Price Range:</label>
                            <select class="equip-price" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="Budget ($0-50)">Budget ($0-50)</option>
                                <option value="Mid-Range ($50-200)">Mid-Range ($50-200)</option>
                                <option value="Premium ($200-500)">Premium ($200-500)</option>
                                <option value="Professional ($500+)">Professional ($500+)</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Alternatives (comma-separated):</label>
                            <input type="text" class="equip-alternatives" placeholder="kettlebell, resistance band, medicine ball" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <small style="font-size: 11px; color: #666;">Alternative equipment that can be used</small>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Maintenance Level:</label>
                            <select class="equip-maintenance" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="No Maintenance">No Maintenance</option>
                                <option value="Low Maintenance">Low Maintenance</option>
                                <option value="Medium Maintenance">Medium Maintenance</option>
                                <option value="High Maintenance">High Maintenance</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Safety Considerations:</label>
                            <textarea class="equip-safety" rows="2" placeholder="Important safety notes..." style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"></textarea>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 13px; font-weight: 600;">Equipment Properties:</label>
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <label style="font-size: 13px; display: flex; align-items: center; gap: 6px;">
                                    <input type="checkbox" class="equip-beginner-friendly" style="cursor: pointer;">
                                    <span>Beginner Friendly</span>
                                </label>
                                <label style="font-size: 13px; display: flex; align-items: center; gap: 6px;">
                                    <input type="checkbox" class="equip-home-gym" style="cursor: pointer;">
                                    <span>Home Gym Suitable</span>
                                </label>
                                <label style="font-size: 13px; display: flex; align-items: center; gap: 6px;">
                                    <input type="checkbox" class="equip-commercial" style="cursor: pointer;">
                                    <span>Commercial Grade</span>
                                </label>
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Storage Type:</label>
                            <select class="equip-storage" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                <option value="arweave">Arweave (Permanent)</option>
                                <option value="gun">GUN + BitTorrent</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Icon Section (MOVED AFTER EQUIPMENT) -->
                <div class="equip-icon-section-wrapper" style="border: 1px solid #e3f2fd; border-radius: 6px; padding: 12px; background: white;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                        <span style="background: #2196f3; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">📁</span>
                        <strong>Equipment Icon</strong>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px; font-weight: 600;">Icon Mode:</label>
                        <select class="equip-icon-mode" onchange="toggleEquipIconMode('${itemId}')" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="create">Create New Icon</option>
                            <option value="existing">Select Existing Icon</option>
                            <option value="none">No Icon</option>
                        </select>
                    </div>
                    
                    <!-- Select Existing Icon (hidden by default) -->
                    <div class="equip-icon-existing-section hidden" style="margin-bottom: 8px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Select Icon:</label>
                        <select class="equip-icon-existing-select" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="">Loading icons...</option>
                        </select>
                    </div>
                    
                    <!-- Create New Icon Fields (shown by default) -->
                    <div class="equip-icon-create-section">
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 13px;">Icon Name:</label>
                            <input type="text" class="equip-icon-name" placeholder="e.g., Barbell Icon" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                        </div>
                    
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Icon File:</label>
                        <input type="file" class="equip-icon-file" accept="image/*" style="width: 100%; font-size: 13px;">
                    </div>
                    
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Storage Type:</label>
                        <select class="equip-icon-storage" onchange="updateEquipIconStorageType('${itemId}')" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="gun">GUN + BitTorrent</option>
                            <option value="arweave">Arweave (Permanent)</option>
                        </select>
                    </div>
                    
                    <div class="equip-icon-access-group hidden" style="margin-bottom: 8px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Access Level:</label>
                        <select class="equip-icon-access" onchange="updateEquipIconAccess('${itemId}')" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="public">Public</option>
                            <option value="organization">Organization</option>
                            <option value="private">Private</option>
                        </select>
                    </div>
                    
                    <div class="equip-icon-org-group hidden">
                        <label style="display: block; margin-bottom: 4px; font-size: 13px;">Organization:</label>
                        <select class="equip-icon-org" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="">Select Organization</option>
                        </select>
                    </div>
                    </div>
                    <!-- End of equip-icon-create-section -->
                </div>
            `;
            
            container.appendChild(item);
            
            // Initialize icon storage type
            updateEquipIconStorageType(itemId);
            
            // Populate the equipment and icon dropdowns for this item
            updateBundleEquipmentDropdowns();
            updateEquipIconDropdowns();
        }

        /**
         * Toggle equipment icon mode (create vs existing vs none)
         */
        function toggleEquipIconMode(itemId) {
            const item = document.getElementById(itemId);
            if (!item) return;
            
            const mode = item.querySelector('.equip-icon-mode')?.value;
            const existingSection = item.querySelector('.equip-icon-existing-section');
            const createSection = item.querySelector('.equip-icon-create-section');
            
            if (mode === 'existing') {
                existingSection?.classList.remove('hidden');
                createSection?.classList.add('hidden');
                updateEquipIconDropdowns();
            } else if (mode === 'create') {
                existingSection?.classList.add('hidden');
                createSection?.classList.remove('hidden');
            } else { // none
                existingSection?.classList.add('hidden');
                createSection?.classList.add('hidden');
            }
        }

        /**
         * Update all equipment icon dropdowns
         */
        function updateEquipIconDropdowns() {
            const selects = document.querySelectorAll('.equip-icon-existing-select');
            console.log(`[Bundle] Updating ${selects.length} icon dropdowns with ${bundleExistingIcons.length} icons`);
            
            if (selects.length === 0) {
                console.warn('[Bundle] ❌ No icon dropdown elements found in DOM yet');
                return;
            }
            
            if (bundleExistingIcons.length > 0) {
                console.log(`[Bundle] Sample icon data structure:`, bundleExistingIcons[0]);
            }
            
            selects.forEach((select, selectIdx) => {
                select.innerHTML = '';
                
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = bundleExistingIcons.length > 0 
                    ? 'Select Icon' 
                    : 'No icons found';
                select.appendChild(placeholder);
                
                bundleExistingIcons.forEach((record, idx) => {
                    const option = document.createElement('option');
                    const did = record.oip?.did || record.oip?.didTx || '';
                    const name = record.data?.basic?.name || 'Unknown Icon';
                    
                    if (selectIdx === 0 && idx < 3) {
                        console.log(`[Bundle] Icon ${idx}: DID=${did}, name=${name}, full record:`, record);
                    }
                    
                    if (!did) {
                        console.warn(`[Bundle] ⚠️ Icon ${idx} has no DID!`, record);
                    }
                    
                    option.value = did;
                    option.textContent = name;
                    select.appendChild(option);
                });
                
                console.log(`✅ [Bundle] Populated icon dropdown ${selectIdx + 1} with ${bundleExistingIcons.length} items, ${select.options.length} total options`);
            });
        }

        /**
         * Update equipment icon storage type
         */
        function updateEquipIconStorageType(itemId) {
            const item = document.getElementById(itemId);
            if (!item) {
                console.warn('[Bundle Equipment] updateEquipIconStorageType called with invalid itemId:', itemId);
                return;
            }
            
            const storageType = item.querySelector('.equip-icon-storage')?.value;
            const accessGroup = item.querySelector('.equip-icon-access-group');
            
            console.log('[Bundle Equipment] Storage type for', itemId, ':', storageType, 'Orgs loaded:', bundleOrganizations.length);
            
            if (storageType === 'gun') {
                accessGroup?.classList.remove('hidden');
                // Trigger access update to populate org dropdown if needed
                updateEquipIconAccess(itemId);
            } else {
                accessGroup?.classList.add('hidden');
            }
        }

        /**
         * Update equipment icon access
         */
        function updateEquipIconAccess(itemId) {
            const item = document.getElementById(itemId);
            if (!item) return;
            
            const accessLevel = item.querySelector('.equip-icon-access')?.value;
            const orgGroup = item.querySelector('.equip-icon-org-group');
            const orgSelect = item.querySelector('.equip-icon-org');
            
            console.log('[Bundle Equipment] Access level for', itemId, ':', accessLevel, 'Orgs loaded:', bundleOrganizations.length);
            
            if (accessLevel === 'organization') {
                orgGroup?.classList.remove('hidden');
                // Populate organization dropdown
                if (orgSelect) {
                    console.log('[Bundle Equipment] Populating org dropdown for', itemId);
                    populateBundleOrgDropdown(orgSelect);
                }
            } else {
                orgGroup?.classList.add('hidden');
            }
        }

        /**
         * Toggle equipment mode (create new vs select existing)
         */
        function toggleEquipmentMode(itemId) {
            const item = document.getElementById(itemId);
            if (!item) return;
            
            const mode = item.querySelector('.equip-mode')?.value;
            const existingSection = item.querySelector('.equip-existing-section');
            const createSection = item.querySelector('.equip-create-section');
            const iconSection = item.querySelector('.equip-icon-section-wrapper'); // The icon section wrapper
            
            console.log(`[Bundle] toggleEquipmentMode(${itemId}): mode=${mode}, iconSection exists=${!!iconSection}`);
            
            if (mode === 'existing') {
                existingSection?.classList.remove('hidden');
                createSection?.classList.add('hidden');
                if (iconSection) {
                    iconSection.classList.add('hidden'); // Hide icon when selecting existing equipment (icon is embedded in equipment record)
                    console.log(`[Bundle] Hiding icon section (using existing equipment)`);
                }
            } else {
                existingSection?.classList.add('hidden');
                createSection?.classList.remove('hidden');
                if (iconSection) {
                    iconSection.classList.remove('hidden'); // Show icon when creating new equipment
                    console.log(`[Bundle] Showing icon section (creating new equipment)`);
                }
            }
        }

        /**
         * Load existing equipment for bundle
         */
        let bundleExistingEquipment = [];
        
        async function loadExistingEquipmentForBundle() {
            try {
                console.log('📋 [Bundle] Loading existing equipment from API...');
                console.log('[Bundle] API URL:', `${API_BASE_URL}/api/records?recordType=fitnessEquipment&noDuplicates=true`);
                
                const response = await fetch(`${API_BASE_URL}/api/records?recordType=fitnessEquipment&noDuplicates=true`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[Bundle] FULL API Response:', result);
                    console.log('[Bundle] Response keys:', Object.keys(result));
                    console.log('[Bundle] result.records exists?', !!result.records);
                    console.log('[Bundle] result.records length:', result.records?.length);
                    
                    bundleExistingEquipment = result.records || [];
                    console.log(`✅ [Bundle] Loaded ${bundleExistingEquipment.length} equipment records`);
                    
                    if (bundleExistingEquipment.length > 0) {
                        console.log('[Bundle] First equipment record (full):', JSON.stringify(bundleExistingEquipment[0], null, 2));
                        console.log('[Bundle] Sample equipment oip object:', bundleExistingEquipment[0].oip);
                        console.log('[Bundle] Sample equipment DID:', bundleExistingEquipment[0].oip?.did || bundleExistingEquipment[0].oip?.didTx);
                        console.log('[Bundle] Sample equipment name:', bundleExistingEquipment[0].data?.basic?.name);
                    } else {
                        console.warn('⚠️ [Bundle] No equipment records in response!');
                    }
                    updateBundleEquipmentDropdowns();
                } else {
                    const errorText = await response.text();
                    console.error('❌ [Bundle] Failed to load equipment from API:', response.status, errorText);
                    updateBundleEquipmentDropdowns();
                }
            } catch (error) {
                console.error('❌ [Bundle] Error loading equipment:', error);
                updateBundleEquipmentDropdowns();
            }
        }
        
        /**
         * Update all bundle equipment dropdowns
         */
        function updateBundleEquipmentDropdowns() {
            const selects = document.querySelectorAll('.equipment-select-bundle');
            console.log(`[Bundle] Updating ${selects.length} equipment dropdowns with ${bundleExistingEquipment.length} equipment`);
            
            if (selects.length === 0) {
                console.warn('[Bundle] ❌ No equipment dropdown elements found in DOM yet');
                return;
            }
            
            if (bundleExistingEquipment.length > 0) {
                console.log(`[Bundle] Sample equipment data structure:`, bundleExistingEquipment[0]);
            }
            
            selects.forEach((select, selectIdx) => {
                // Clear all existing options
                select.innerHTML = '';
                
                // Add placeholder
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = bundleExistingEquipment.length > 0 
                    ? 'Select Equipment' 
                    : 'No equipment found';
                select.appendChild(placeholder);
                
                // Add equipment options
                bundleExistingEquipment.forEach((record, idx) => {
                    const option = document.createElement('option');
                    const did = record.oip?.did || record.oip?.didTx || '';
                    const name = record.data?.basic?.name || 'Unknown Equipment';
                    
                    if (selectIdx === 0 && idx < 3) {
                        console.log(`[Bundle] Equipment ${idx}: DID=${did}, name=${name}, full record:`, record);
                    }
                    
                    if (!did) {
                        console.warn(`[Bundle] ⚠️ Equipment ${idx} has no DID!`, record);
                    }
                    
                    option.value = did;
                    option.textContent = name;
                    select.appendChild(option);
                });
                
                console.log(`✅ [Bundle] Populated equipment dropdown ${selectIdx + 1} with ${bundleExistingEquipment.length} items, ${select.options.length} total options`);
            });
        }

        /**
         * Remove equipment item
         */
        function removeBundleEquipmentItem(itemId) {
            const item = document.getElementById(itemId);
            if (item) {
                item.remove();
                // Renumber remaining items
                const container = document.getElementById('bundle-equipment-container');
                const items = container?.querySelectorAll('.equipment-item');
                items?.forEach((item, index) => {
                    const header = item.querySelector('strong');
                    if (header) {
                        header.textContent = `Equipment ${index + 1}`;
                    }
                });
            }
        }

        /**
         * Toggle section visibility
         */
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('hidden');
            }
        }

        /**
         * Toggle bundle section enable/disable
         */
        function toggleBundleSection(section) {
            const checkbox = document.getElementById(`bundle-enable-${section}`);
            const sectionDiv = document.getElementById(`bundle-section-${section}`);
            
            if (sectionDiv) {
                if (checkbox.checked) {
                    sectionDiv.style.opacity = '1';
                    sectionDiv.style.pointerEvents = 'auto';
                } else {
                    sectionDiv.style.opacity = '0.5';
                    sectionDiv.style.pointerEvents = 'none';
                }
            }
            
            updateBundleEstimate();
        }

        /**
         * Update publish estimate
         */
        function updateBundleEstimate() {
            const iconEnabled = document.getElementById('bundle-enable-icon')?.checked;
            const equipmentEnabled = document.getElementById('bundle-enable-equipment')?.checked;
            const gifEnabled = document.getElementById('bundle-enable-gif')?.checked;
            
            let count = 1; // Exercise is always included
            if (iconEnabled) count++;
            if (equipmentEnabled) count++;
            if (gifEnabled) count++;
            
            const estimateEl = document.getElementById('bundle-publish-estimate');
            if (estimateEl) {
                estimateEl.textContent = `This will publish ${count} record${count > 1 ? 's' : ''} in sequence`;
            }
        }

        /**
         * Preview bundle icon
         */
        function previewBundleIcon(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const preview = document.getElementById('bundle-icon-preview');
                    const img = document.getElementById('bundle-icon-preview-img');
                    const info = document.getElementById('bundle-icon-preview-info');
                    
                    if (preview && img && info) {
                        img.src = e.target.result;
                        info.textContent = `${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                        preview.classList.remove('hidden');
                    }
                };
                
                reader.readAsDataURL(file);
            }
        }

        /**
         * Update icon access level
         */
        function updateBundleIconAccess() {
            const accessLevel = document.getElementById('bundle-icon-access')?.value;
            const orgGroup = document.getElementById('bundle-icon-org-group');
            
            if (orgGroup) {
                if (accessLevel === 'organization') {
                    orgGroup.classList.remove('hidden');
                } else {
                    orgGroup.classList.add('hidden');
                }
            }
        }

        /**
         * Update GIF access level
         */
        function updateBundleGifAccess() {
            const accessLevel = document.getElementById('bundle-gif-access')?.value;
            const orgGroup = document.getElementById('bundle-gif-org-group');
            
            if (orgGroup) {
                if (accessLevel === 'organization') {
                    orgGroup.classList.remove('hidden');
                } else {
                    orgGroup.classList.add('hidden');
                }
            }
        }

        /**
         * Update exercise measurement type UI
         */
        function updateBundleExerciseMeasurement() {
            const measurementType = document.getElementById('bundle-exercise-measurement')?.value;
            const setsGroup = document.getElementById('bundle-exercise-sets-group');
            const repsGroup = document.getElementById('bundle-exercise-reps-group');
            const durationGroup = document.getElementById('bundle-exercise-duration-group');
            const estDurationGroup = document.getElementById('bundle-exercise-est-duration-group');
            const setsInput = document.getElementById('bundle-exercise-sets');
            
            // Always show Estimated Duration (needed for workout time calculations)
            estDurationGroup?.classList.remove('hidden');
            
            // Show/hide fields based on measurement type
            if (measurementType === 'reps') {
                setsGroup?.classList.remove('hidden');
                repsGroup?.classList.remove('hidden');
                durationGroup?.classList.add('hidden');
            } else if (measurementType === 'timed') {
                // For timed exercises, show sets and duration fields
                setsGroup?.classList.remove('hidden');
                repsGroup?.classList.add('hidden');
                durationGroup?.classList.remove('hidden');
                // Clear the sets value so it's optional
                if (setsInput) setsInput.value = '';
            } else if (measurementType === 'hold' || measurementType === 'maxdur') {
                // For hold and maxdur, hide sets and reps
                setsGroup?.classList.add('hidden');
                repsGroup?.classList.add('hidden');
                durationGroup?.classList.remove('hidden');
            }
        }

        /**
         * Update GIF file info
         */
        function updateBundleGifFileInfo(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const row = input.closest('.gif-file-row');
                
                // Auto-detect dimensions if possible
                const img = new Image();
                img.onload = function() {
                    const widthInput = row.querySelector('.bundle-gif-width');
                    const heightInput = row.querySelector('.bundle-gif-height');
                    if (widthInput) widthInput.value = this.width;
                    if (heightInput) heightInput.value = this.height;
                };
                img.src = URL.createObjectURL(file);
            }
        }

        /**
         * Fill equipment with AI
         */
        async function fillBundleEquipmentWithAI() {
            const name = document.getElementById('bundle-equipment-name')?.value;
            if (!name) {
                alert('Please enter an equipment name first');
                return;
            }
            
            // Use existing AI fill functionality
            const descField = document.getElementById('bundle-equipment-description');
            if (descField) {
                descField.value = `A ${name.toLowerCase()} used for fitness and exercise training.`;
            }
            
            alert('🤖 AI fill complete! Review and adjust as needed.');
        }

        /**
         * Copy from latest exercise
         */
        /**
         * Copy from latest exercise (Bundle)
         */
        async function copyBundleFromLatestExercise() {
            try {
                const nameValue = document.getElementById('bundle-exercise-name')?.value.trim();
                
                if (!nameValue) {
                    alert('Please enter an exercise name first to search for matching records');
                    return;
                }

                const params = new URLSearchParams({
                    recordType: 'exercise',
                    search: nameValue,
                    noDuplicates: 'true',
                    limit: '1',
                    sortBy: 'date:desc',
                    resolveDepth: '2'
                });

                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }

                console.log(`Searching for latest exercise matching: "${nameValue}"`);

                const response = await fetch(`${API_BASE_URL}/api/records?${params}`, {
                    method: 'GET',
                    headers: headers
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch records');
                }

                const data = await response.json();
                
                if (!data.records || data.records.length === 0) {
                    alert(`No existing exercises found matching "${nameValue}"`);
                    return;
                }

                const record = data.records[0];
                const exerciseData = record.data?.exercise;
                const basicData = record.data?.basic;
                
                // Populate fields
                if (basicData?.description) {
                    document.getElementById('bundle-exercise-description').value = basicData.description;
                }
                if (exerciseData?.instructions && Array.isArray(exerciseData.instructions)) {
                    document.getElementById('bundle-exercise-instructions').value = exerciseData.instructions.join('\n');
                }
                if (exerciseData?.muscleGroups && Array.isArray(exerciseData.muscleGroups)) {
                    document.getElementById('bundle-exercise-muscle-groups').value = exerciseData.muscleGroups.join(', ');
                }
                if (exerciseData?.difficulty) {
                    // Normalize to lowercase for dropdown matching
                    const difficultySelect = document.getElementById('bundle-exercise-difficulty');
                    if (difficultySelect) {
                        difficultySelect.value = exerciseData.difficulty.toLowerCase();
                    }
                }
                if (exerciseData?.category) {
                    // Normalize to lowercase for dropdown matching
                    const categorySelect = document.getElementById('bundle-exercise-category');
                    if (categorySelect) {
                        categorySelect.value = exerciseData.category.toLowerCase();
                    }
                }
                if (exerciseData?.exercise_type) {
                    // Normalize to lowercase for dropdown matching
                    const typeSelect = document.getElementById('bundle-exercise-type');
                    if (typeSelect) {
                        typeSelect.value = exerciseData.exercise_type.toLowerCase();
                    }
                }
                if (exerciseData?.measurement_type) {
                    // Normalize to lowercase for dropdown matching
                    const measurementSelect = document.getElementById('bundle-exercise-measurement');
                    if (measurementSelect) {
                        measurementSelect.value = exerciseData.measurement_type.toLowerCase();
                        updateBundleExerciseMeasurement();
                    }
                }
                if (exerciseData?.recommended_sets) {
                    document.getElementById('bundle-exercise-sets').value = exerciseData.recommended_sets;
                }
                if (exerciseData?.recommended_reps) {
                    document.getElementById('bundle-exercise-reps').value = exerciseData.recommended_reps;
                }
                if (exerciseData?.target_duration_seconds) {
                    document.getElementById('bundle-exercise-duration').value = exerciseData.target_duration_seconds;
                }
                if (exerciseData?.est_duration_minutes) {
                    document.getElementById('bundle-exercise-est-duration').value = exerciseData.est_duration_minutes;
                }
                if (exerciseData?.isBodyweight !== undefined) {
                    document.getElementById('bundle-exercise-bodyweight').checked = exerciseData.isBodyweight;
                }
                
                alert('📋 Exercise data copied successfully!');
            } catch (error) {
                console.error('Error copying from latest:', error);
                alert('Failed to copy from latest exercise');
            }
        }

        /**
         * Fill exercise with AI (Bundle)
         */
        async function fillBundleExerciseWithAI() {
            try {
                const nameValue = document.getElementById('bundle-exercise-name')?.value.trim();
                
                if (!nameValue) {
                    alert('Please enter an exercise name first to provide context for AI');
                    return;
                }

                console.log(`[Bundle AI] Filling in exercise fields for: "${nameValue}"`);

                // Build a simple prompt for the AI
                const prompt = `You are an expert fitness assistant. Given the exercise name "${nameValue}", please provide:
1. A brief description (2-3 sentences)
2. Step-by-step instructions (3-5 steps, one per line)
3. Primary muscle groups targeted (comma-separated list)
4. Appropriate difficulty level (beginner/intermediate/advanced)
5. Exercise category (strength/cardio/flexibility)

Return ONLY a JSON object with this structure:
{
  "description": "...",
  "instructions": "step1\\nstep2\\nstep3",
  "muscleGroups": "muscle1, muscle2, muscle3",
  "difficulty": "beginner",
  "category": "strength"
}`;

                const response = await fetch(`${API_BASE_URL}/api/voice/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(authToken && { 'Authorization': `Bearer ${authToken}` })
                    },
                    body: JSON.stringify({
                        text: prompt,
                        model: 'grok-beta',
                        processing_mode: 'llm-grok-4',
                        return_audio: false,
                        conversation_history: []
                    })
                });

                const data = await response.json();
                
                if (data.response_text) {
                    // Try to parse the AI response as JSON
                    const aiData = JSON.parse(data.response_text);
                    
                    // Populate fields
                    if (aiData.description) {
                        document.getElementById('bundle-exercise-description').value = aiData.description;
                    }
                    if (aiData.instructions) {
                        document.getElementById('bundle-exercise-instructions').value = aiData.instructions;
                    }
                    if (aiData.muscleGroups) {
                        document.getElementById('bundle-exercise-muscle-groups').value = aiData.muscleGroups;
                    }
                    if (aiData.difficulty) {
                        document.getElementById('bundle-exercise-difficulty').value = aiData.difficulty;
                    }
                    if (aiData.category) {
                        document.getElementById('bundle-exercise-category').value = aiData.category;
                    }
                    
                    alert('🤖 AI successfully filled in exercise fields!');
                } else {
                    throw new Error('No response from AI');
                }
            } catch (error) {
                console.error('Error with AI fill:', error);
                alert('Failed to fill with AI. Please try again or fill manually.');
            }
        }

        /**
         * Copy equipment from latest (Bundle)
         */
        async function copyEquipmentFromLatest(itemId) {
            try {
                const item = document.getElementById(itemId);
                if (!item) return;
                
                const nameInput = item.querySelector('.equip-name');
                const nameValue = nameInput?.value.trim();
                
                if (!nameValue) {
                    alert('Please enter an equipment name first to search for matching records');
                    return;
                }

                const params = new URLSearchParams({
                    recordType: 'fitnessEquipment',
                    search: nameValue,
                    noDuplicates: 'true',
                    limit: '1',
                    sortBy: 'date:desc'
                });

                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }

                console.log(`Searching for latest equipment matching: "${nameValue}"`);

                const response = await fetch(`${API_BASE_URL}/api/records?${params}`, {
                    method: 'GET',
                    headers: headers
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch records');
                }

                const data = await response.json();
                
                if (!data.records || data.records.length === 0) {
                    alert(`No existing equipment found matching "${nameValue}"`);
                    return;
                }

                const record = data.records[0];
                const basicData = record.data?.basic;
                const equipData = record.data?.fitnessEquipment;
                
                console.log('Copying equipment data:', { basicData, equipData });
                
                // Populate description
                const descTextarea = item.querySelector('.equip-description');
                if (basicData?.description && descTextarea) {
                    descTextarea.value = basicData.description;
                }
                
                // Populate all new equipment fields
                if (equipData) {
                    // Category
                    const categorySelect = item.querySelector('.equip-category');
                    if (equipData.category && categorySelect) {
                        categorySelect.value = equipData.category;
                    }
                    
                    // Subcategory
                    const subcategoryInput = item.querySelector('.equip-subcategory');
                    if (equipData.subcategory && subcategoryInput) {
                        subcategoryInput.value = equipData.subcategory;
                    }
                    
                    // Muscle groups (array to comma-separated string)
                    const muscleGroupsInput = item.querySelector('.equip-muscle-groups');
                    if (equipData.muscle_groups && Array.isArray(equipData.muscle_groups) && muscleGroupsInput) {
                        muscleGroupsInput.value = equipData.muscle_groups.join(', ');
                    }
                    
                    // Difficulty level
                    const difficultySelect = item.querySelector('.equip-difficulty');
                    if (equipData.difficulty_level && difficultySelect) {
                        difficultySelect.value = equipData.difficulty_level;
                    }
                    
                    // Space required
                    const spaceSelect = item.querySelector('.equip-space');
                    if (equipData.space_required && spaceSelect) {
                        spaceSelect.value = equipData.space_required;
                    }
                    
                    // Portability
                    const portabilitySelect = item.querySelector('.equip-portability');
                    if (equipData.portability && portabilitySelect) {
                        portabilitySelect.value = equipData.portability;
                    }
                    
                    // Price range
                    const priceSelect = item.querySelector('.equip-price');
                    if (equipData.price_range && priceSelect) {
                        priceSelect.value = equipData.price_range;
                    }
                    
                    // Alternatives (array to comma-separated string)
                    const alternativesInput = item.querySelector('.equip-alternatives');
                    if (equipData.alternatives && Array.isArray(equipData.alternatives) && alternativesInput) {
                        alternativesInput.value = equipData.alternatives.join(', ');
                    }
                    
                    // Maintenance level
                    const maintenanceSelect = item.querySelector('.equip-maintenance');
                    if (equipData.maintenance_level && maintenanceSelect) {
                        maintenanceSelect.value = equipData.maintenance_level;
                    }
                    
                    // Safety considerations
                    const safetyTextarea = item.querySelector('.equip-safety');
                    if (equipData.safety_considerations && safetyTextarea) {
                        safetyTextarea.value = equipData.safety_considerations;
                    }
                    
                    // Boolean checkboxes
                    const beginnerCheckbox = item.querySelector('.equip-beginner-friendly');
                    if (beginnerCheckbox) {
                        beginnerCheckbox.checked = !!equipData.beginner_friendly;
                    }
                    
                    const homeGymCheckbox = item.querySelector('.equip-home-gym');
                    if (homeGymCheckbox) {
                        homeGymCheckbox.checked = !!equipData.home_gym_suitable;
                    }
                    
                    const commercialCheckbox = item.querySelector('.equip-commercial');
                    if (commercialCheckbox) {
                        commercialCheckbox.checked = !!equipData.commercial_grade;
                    }
                }
                
                alert('📋 Equipment data copied successfully!');
            } catch (error) {
                console.error('Error copying equipment:', error);
                alert('Failed to copy from latest equipment');
            }
        }

        /**
         * Fill equipment with AI (Bundle)
         */
        async function fillEquipmentWithAI(itemId) {
            try {
                const item = document.getElementById(itemId);
                if (!item) return;
                
                const nameInput = item.querySelector('.equip-name');
                const nameValue = nameInput?.value.trim();
                
                if (!nameValue) {
                    alert('Please enter an equipment name first to provide context for AI');
                    return;
                }

                console.log(`[Bundle AI] Filling in equipment fields for: "${nameValue}"`);

                // Build a comprehensive prompt for the AI
                const prompt = `You are an expert fitness equipment specialist. Given the equipment name "${nameValue}", please provide comprehensive information about this equipment.

Return ONLY a valid JSON object with this exact structure (all fields required):
{
  "description": "Brief 2-3 sentence description of the equipment",
  "category": "one of: Weights, Cardio, Bodyweight, Flexibility, Functional, Accessories",
  "subcategory": "specific subcategory like 'Free Weights', 'Resistance Bands', etc.",
  "muscle_groups": ["list", "of", "muscles"],
  "difficulty_level": "one of: Beginner, Intermediate, Advanced",
  "space_required": "one of: Minimal Space, Small Space, Medium Space, Large Space",
  "portability": "one of: Portable, Semi-Portable, Stationary",
  "price_range": "one of: Budget ($0-50), Mid-Range ($50-200), Premium ($200-500), Professional ($500+)",
  "alternatives": ["alternative", "equipment", "options"],
  "maintenance_level": "one of: No Maintenance, Low Maintenance, Medium Maintenance, High Maintenance",
  "safety_considerations": "important safety notes and precautions",
  "beginner_friendly": true or false,
  "home_gym_suitable": true or false,
  "commercial_grade": true or false
}

Ensure all enum values match EXACTLY as shown (case-sensitive).`;

                const response = await fetch(`${API_BASE_URL}/api/voice/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(authToken && { 'Authorization': `Bearer ${authToken}` })
                    },
                    body: JSON.stringify({
                        text: prompt,
                        model: 'grok-beta',
                        processing_mode: 'llm-grok-4',
                        return_audio: false,
                        conversation_history: []
                    })
                });

                const data = await response.json();
                
                if (data.response_text) {
                    // Try to parse the AI response as JSON
                    let responseText = data.response_text.trim();
                    
                    // Remove markdown code blocks if present
                    responseText = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
                    
                    const aiData = JSON.parse(responseText);
                    
                    console.log('[Bundle AI] Received data:', aiData);
                    
                    // Populate description
                    const descTextarea = item.querySelector('.equip-description');
                    if (aiData.description && descTextarea) {
                        descTextarea.value = aiData.description;
                    }
                    
                    // Populate all new equipment fields
                    
                    // Category
                    const categorySelect = item.querySelector('.equip-category');
                    if (aiData.category && categorySelect) {
                        categorySelect.value = aiData.category;
                    }
                    
                    // Subcategory
                    const subcategoryInput = item.querySelector('.equip-subcategory');
                    if (aiData.subcategory && subcategoryInput) {
                        subcategoryInput.value = aiData.subcategory;
                    }
                    
                    // Muscle groups (array to comma-separated string)
                    const muscleGroupsInput = item.querySelector('.equip-muscle-groups');
                    if (aiData.muscle_groups && Array.isArray(aiData.muscle_groups) && muscleGroupsInput) {
                        muscleGroupsInput.value = aiData.muscle_groups.join(', ');
                    }
                    
                    // Difficulty level
                    const difficultySelect = item.querySelector('.equip-difficulty');
                    if (aiData.difficulty_level && difficultySelect) {
                        difficultySelect.value = aiData.difficulty_level;
                    }
                    
                    // Space required
                    const spaceSelect = item.querySelector('.equip-space');
                    if (aiData.space_required && spaceSelect) {
                        spaceSelect.value = aiData.space_required;
                    }
                    
                    // Portability
                    const portabilitySelect = item.querySelector('.equip-portability');
                    if (aiData.portability && portabilitySelect) {
                        portabilitySelect.value = aiData.portability;
                    }
                    
                    // Price range
                    const priceSelect = item.querySelector('.equip-price');
                    if (aiData.price_range && priceSelect) {
                        priceSelect.value = aiData.price_range;
                    }
                    
                    // Alternatives (array to comma-separated string)
                    const alternativesInput = item.querySelector('.equip-alternatives');
                    if (aiData.alternatives && Array.isArray(aiData.alternatives) && alternativesInput) {
                        alternativesInput.value = aiData.alternatives.join(', ');
                    }
                    
                    // Maintenance level
                    const maintenanceSelect = item.querySelector('.equip-maintenance');
                    if (aiData.maintenance_level && maintenanceSelect) {
                        maintenanceSelect.value = aiData.maintenance_level;
                    }
                    
                    // Safety considerations
                    const safetyTextarea = item.querySelector('.equip-safety');
                    if (aiData.safety_considerations && safetyTextarea) {
                        safetyTextarea.value = aiData.safety_considerations;
                    }
                    
                    // Boolean checkboxes
                    const beginnerCheckbox = item.querySelector('.equip-beginner-friendly');
                    if (beginnerCheckbox && typeof aiData.beginner_friendly === 'boolean') {
                        beginnerCheckbox.checked = aiData.beginner_friendly;
                    }
                    
                    const homeGymCheckbox = item.querySelector('.equip-home-gym');
                    if (homeGymCheckbox && typeof aiData.home_gym_suitable === 'boolean') {
                        homeGymCheckbox.checked = aiData.home_gym_suitable;
                    }
                    
                    const commercialCheckbox = item.querySelector('.equip-commercial');
                    if (commercialCheckbox && typeof aiData.commercial_grade === 'boolean') {
                        commercialCheckbox.checked = aiData.commercial_grade;
                    }
                    
                    alert('🤖 AI successfully filled in all equipment fields!');
                } else {
                    throw new Error('No response from AI');
                }
            } catch (error) {
                console.error('Error with AI fill:', error);
                alert('Failed to fill with AI. Please try again or fill manually.');
            }
        }

        /**
         * Update progress step
         */
        function updateBundleProgress(step, status, message) {
            const stepEl = document.getElementById(`progress-step-${step}`);
            const messageEl = document.getElementById('bundle-progress-message');
            const progressContainer = document.getElementById('bundle-progress');
            
            if (progressContainer) {
                progressContainer.classList.remove('hidden');
            }
            
            if (stepEl) {
                const icon = stepEl.querySelector('div');
                if (status === 'active') {
                    icon.textContent = '⏳';
                    stepEl.style.borderColor = '#2196f3';
                    stepEl.style.background = '#e3f2fd';
                } else if (status === 'complete') {
                    icon.textContent = '✅';
                    stepEl.style.borderColor = '#4caf50';
                    stepEl.style.background = '#e8f5e9';
                } else if (status === 'error') {
                    icon.textContent = '❌';
                    stepEl.style.borderColor = '#f44336';
                    stepEl.style.background = '#ffebee';
                }
            }
            
            if (messageEl && message) {
                messageEl.textContent = message;
            }
        }

        /**
         * Main Exercise Bundle Publishing Function
         */
        async function publishExerciseBundle() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please log in first.', 'error');
                    return;
                }

                const btn = document.getElementById('bundle-publish-btn');
                if (btn) {
                    btn.disabled = true;
                    btn.textContent = '🚀 Publishing...';
                }

                let gifDID = null;
                let equipmentDIDs = [];

                // Step 1: Publish Multi-Res GIF (10% progress)
                updateBundleProgress('Publishing demo GIF collection...', 10);
                gifDID = await publishBundleGif();
                if (!gifDID) {
                    throw new Error('Failed to publish GIF collection');
                }
                console.log(`✅ GIF Collection published: ${gifDID}`);

                // Step 2: Process Equipment Items (10-80% progress)
                equipmentDIDs = await processEquipmentItems();
                console.log(`✅ Equipment processed: ${equipmentDIDs.length} items`, equipmentDIDs);

                // Step 3: Publish Exercise (90-100% progress)
                console.log(`🏋️ About to publish exercise with equipment DIDs:`, equipmentDIDs);
                const exerciseDID = await publishBundleExercise(gifDID, equipmentDIDs);
                if (!exerciseDID) {
                    throw new Error('Failed to publish exercise');
                }
                
                updateBundleProgress('✅ Exercise Bundle published successfully!', 100);
                showMessage('publish-success', `🎉 Exercise published! DID: ${exerciseDID}`, 'success');
                console.log(`✅ Final Exercise DID: ${exerciseDID}`);

            } catch (error) {
                console.error('Bundle publishing error:', error);
                updateBundleProgress(`❌ Error: ${error.message}`, 0);
                showMessage('publish-status', `Error: ${error.message}`, 'error');
            } finally {
                const btn = document.getElementById('bundle-publish-btn');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = '🚀 Publish Complete Exercise Bundle';
                }
            }
        }

        /**
         * Publish Bundle Icon (Media File)
         */
        async function publishBundleIcon() {
            try {
                const file = document.getElementById('bundle-icon-file')?.files[0];
                if (!file) {
                    throw new Error('Please select an icon file');
                }

                const name = document.getElementById('bundle-icon-name')?.value || file.name;
                const storageType = document.getElementById('bundle-icon-storage')?.value || 'gun';
                const accessLevel = document.getElementById('bundle-icon-access')?.value || 'public';
                const orgDID = document.getElementById('bundle-icon-org')?.value;

                // Create FormData
                const formData = new FormData();
                formData.append('file', file);
                formData.append('name', name);
                formData.append('description', `Icon for equipment`);
                formData.append('language', 'en');
                formData.append('storageType', storageType);
                
                if (storageType === 'gun') {
                    formData.append('accessLevel', accessLevel);
                    if (accessLevel === 'organization' && orgDID) {
                        formData.append('organizationDID', orgDID);
                    }
                }

                // Step 1: Upload file to get mediaId
                const uploadResponse = await fetch(`${API_BASE_URL}/api/media/upload`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: formData
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    console.error('Icon upload error response:', errorText);
                    throw new Error(`File upload failed: ${uploadResponse.status}: ${errorText.substring(0, 200)}`);
                }

                const uploadResult = await uploadResponse.json();

                if (!uploadResult.mediaId) {
                    throw new Error('No mediaId returned from upload');
                }

                // Step 2: Create OIP record for the image with all network addresses
                const recordData = {
                    basic: {
                        name,
                        description: `Icon for equipment`,
                        language: 'en',
                        webUrl: uploadResult.httpUrl
                    },
                    image: {
                        webUrl: uploadResult.httpUrl,
                        bittorrentAddress: uploadResult.magnetURI || '',
                        ipfsAddress: '',
                        arweaveAddress: '',
                        filename: uploadResult.originalName,
                        size: uploadResult.size,
                        contentType: uploadResult.mime
                    }
                };

                if (storageType === 'gun') {
                    recordData.storage = 'gun';
                    recordData.accessControl = {
                        access_level: accessLevel
                    };
                    if (accessLevel === 'organization' && orgDID) {
                        recordData.accessControl.shared_with = orgDID;
                    }
                } else {
                    recordData.blockchain = storageType;
                }

                const recordResponse = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=image`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recordData)
                });

                if (!recordResponse.ok) {
                    const errorText = await recordResponse.text();
                    console.error('Icon record error response:', errorText);
                    throw new Error(`Record creation failed: ${recordResponse.status}: ${errorText.substring(0, 200)}`);
                }

                const result = await recordResponse.json();
                console.log(`📥 Icon publish response:`, result);
                
                // Handle both GUN (did) and Arweave (didTx) response formats
                const did = result.did || result.didTx || result.oip?.did || result.oip?.didTx;
                
                if (did) {
                    console.log(`✅ Icon published successfully: ${did}`);
                    return did;
                } else {
                    console.error('❌ No DID in icon response:', result);
                    throw new Error(result.error || 'Failed to publish icon - no DID in response');
                }
            } catch (error) {
                console.error('Icon publishing error:', error);
                throw error;
            }
        }

        /**
         * Publish Bundle Equipment
         */
        async function publishBundleEquipment(iconDID) {
            try {
                const name = document.getElementById('bundle-equipment-name')?.value;
                if (!name) {
                    throw new Error('Please enter equipment name');
                }

                const description = document.getElementById('bundle-equipment-description')?.value;
                const storageType = document.getElementById('bundle-equipment-storage')?.value || 'arweave';

                const equipmentData = {
                    basic: {
                        name,
                        description: description || `Equipment: ${name}`,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000)
                    },
                    fitnessEquipment: {
                        category: 'General',
                        subcategory: 'Training Equipment'
                    }
                };

                // Add icon DID if available
                if (iconDID) {
                    equipmentData.basic.avatar = iconDID;
                }

                // Set storage/blockchain type
                if (storageType === 'gun') {
                    equipmentData.storage = 'gun';
                } else {
                    equipmentData.blockchain = storageType;
                }

                const response = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=fitnessEquipment`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(equipmentData)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Equipment publish error response:', errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const result = await response.json();
                console.log(`📥 Equipment publish response:`, result);
                
                // Handle both GUN (did) and Arweave (didTx) response formats
                const did = result.did || result.didTx || result.oip?.did || result.oip?.didTx;
                
                if (did) {
                    console.log(`✅ Equipment published successfully: ${did}`);
                    return did;
                } else {
                    console.error('❌ No DID in equipment response:', result);
                    throw new Error(result.error || 'Failed to publish equipment - no DID in response');
                }
            } catch (error) {
                console.error('Equipment publishing error:', error);
                throw error;
            }
        }

        /**
         * Publish Bundle Multi-Resolution GIF
         */
        async function publishBundleGif() {
            try {
                // Check if using existing GIF
                const mode = document.getElementById('bundle-gif-mode')?.value;
                if (mode === 'existing') {
                    const existingDID = document.getElementById('bundle-gif-existing-select')?.value;
                    if (!existingDID) {
                        throw new Error('Please select a GIF collection');
                    }
                    console.log(`📦 Using existing GIF collection: ${existingDID}`);
                    return existingDID;
                }
                
                // Create new GIF collection
                const name = document.getElementById('bundle-gif-name')?.value;
                if (!name) {
                    throw new Error('Please enter GIF collection name');
                }

                const storageType = document.getElementById('bundle-gif-storage')?.value || 'gun';
                const accessLevel = document.getElementById('bundle-gif-access')?.value || 'public';
                const orgDID = document.getElementById('bundle-gif-org')?.value;

                // Get all GIF files
                const gifFileInputs = document.querySelectorAll('.bundle-gif-file-input');
                const gifMediaRefs = [];
                const resolutionLabels = [];
                const resolutionWidths = [];

                for (const input of gifFileInputs) {
                    if (input.files && input.files[0]) {
                        const file = input.files[0];
                        const row = input.closest('.gif-file-row');
                        const resolution = input.dataset.resolution;
                        const width = row.querySelector('.bundle-gif-width').value;
                        const height = row.querySelector('.bundle-gif-height').value;

                        // Step 1: Upload file to get mediaId
                        const formData = new FormData();
                        formData.append('file', file);

                        const uploadResponse = await fetch(`${API_BASE_URL}/api/media/upload`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: formData
                        });

                        if (!uploadResponse.ok) {
                            const errorText = await uploadResponse.text();
                            console.error(`GIF ${resolution} upload error:`, errorText);
                            throw new Error(`Failed to upload ${resolution} GIF: ${uploadResponse.status}`);
                        }

                        const uploadResult = await uploadResponse.json();

                        if (!uploadResult.mediaId) {
                            throw new Error(`No mediaId returned for ${resolution} GIF`);
                        }

                        console.log(`✅ Step 1 complete for ${resolution} - mediaId: ${uploadResult.mediaId}`);

                        // Step 2: Upload to IPFS (optional but recommended)
                        let ipfsAddress = '';
                        try {
                            const ipfsResponse = await fetch(`${API_BASE_URL}/api/media/ipfs-upload`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ mediaId: uploadResult.mediaId })
                            });
                            
                            if (ipfsResponse.ok) {
                                const ipfsResult = await ipfsResponse.json();
                                ipfsAddress = ipfsResult.ipfsHash || '';
                                console.log(`✅ Step 2 complete for ${resolution} - IPFS: ${ipfsAddress}`);
                            } else {
                                console.warn(`⚠️ IPFS upload failed for ${resolution}, continuing without IPFS`);
                            }
                        } catch (ipfsError) {
                            console.warn(`⚠️ IPFS upload error for ${resolution}:`, ipfsError);
                        }

                        // Step 3: Setup web server access (filename-based URL)
                        let webUrl = uploadResult.httpUrl; // Fallback to mediaId-based URL
                        try {
                            const webResponse = await fetch(`${API_BASE_URL}/api/media/web-setup`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ 
                                    mediaId: uploadResult.mediaId,
                                    filename: uploadResult.originalName
                                })
                            });
                            
                            if (webResponse.ok) {
                                const webResult = await webResponse.json();
                                webUrl = webResult.webUrl || uploadResult.httpUrl;
                                console.log(`✅ Step 3 complete for ${resolution} - Web URL: ${webUrl}`);
                            } else {
                                console.warn(`⚠️ Web setup failed for ${resolution}, using fallback URL`);
                            }
                        } catch (webError) {
                            console.warn(`⚠️ Web setup error for ${resolution}:`, webError);
                        }

                        // Step 4: Create image record for this GIF with all network addresses
                        const imageData = {
                            basic: {
                                name: `${name} - ${resolution}`,
                                description: `GIF resolution: ${resolution}`,
                                language: 'en',
                                webUrl: webUrl
                            },
                            image: {
                                webUrl: webUrl,
                                bittorrentAddress: uploadResult.magnetURI || '',
                                ipfsAddress: ipfsAddress,
                                arweaveAddress: '',
                                filename: uploadResult.originalName,
                                size: uploadResult.size,
                                contentType: uploadResult.mime,
                                width: parseInt(width) || 0,
                                height: parseInt(height) || 0
                            }
                        };

                        if (storageType === 'gun') {
                            imageData.storage = 'gun';
                            imageData.accessControl = {
                                access_level: accessLevel
                            };
                            if (accessLevel === 'organization' && orgDID) {
                                imageData.accessControl.shared_with = orgDID;
                            }
                        } else {
                            imageData.blockchain = storageType;
                        }

                        const recordResponse = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=image`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify(imageData)
                        });

                        if (!recordResponse.ok) {
                            const errorText = await recordResponse.text();
                            console.error(`GIF ${resolution} record error:`, errorText);
                            throw new Error(`Failed to create ${resolution} GIF record: ${recordResponse.status}`);
                        }

                        const recordResult = await recordResponse.json();
                        console.log(`📥 GIF ${resolution} publish response:`, recordResult);
                        
                        // Handle both GUN (did) and Arweave (transactionId) response formats
                        let gifDID = recordResult.did || recordResult.didTx || recordResult.oip?.did || recordResult.oip?.didTx;
                        
                        // Handle Arweave transactionId
                        if (!gifDID && recordResult.transactionId) {
                            gifDID = `did:arweave:${recordResult.transactionId}`;
                            console.log(`🔄 Converted transactionId to DID for ${resolution}: ${gifDID}`);
                        }
                        
                        if (gifDID) {
                            gifMediaRefs.push(gifDID);
                            resolutionLabels.push(resolution);
                            resolutionWidths.push(width.toString());
                            console.log(`✅ GIF ${resolution} published: ${gifDID}`);
                        } else {
                            console.error(`❌ No DID in ${resolution} GIF response:`, recordResult);
                            throw new Error(`No DID returned for ${resolution} GIF`);
                        }
                    }
                }

                if (gifMediaRefs.length === 0) {
                    throw new Error('Please select at least one GIF file');
                }

                // Now publish the multi-resolution GIF collection
                const frameRate = parseInt(document.getElementById('bundle-gif-framerate')?.value) || 4;
                const duration = parseInt(document.getElementById('bundle-gif-duration')?.value) || 3;

                const gifCollectionData = {
                    basic: {
                        name,
                        description: document.getElementById('bundle-gif-description')?.value || `Multi-resolution GIF for ${name}`,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000)
                    },
                    multiResolutionGif: {
                        gif_media_refs: gifMediaRefs,
                        resolution_labels: resolutionLabels,
                        resolution_widths: resolutionWidths,
                        frame_rate: frameRate,
                        duration_seconds: duration,
                        primary_resolution_index: 2,
                        loop_count: 0
                    }
                };

                if (storageType === 'gun') {
                    gifCollectionData.storage = 'gun';
                    gifCollectionData.accessControl = {
                        access_level: accessLevel
                    };
                    if (accessLevel === 'organization' && orgDID) {
                        gifCollectionData.accessControl.shared_with = orgDID;
                    }
                } else {
                    gifCollectionData.blockchain = storageType;
                }

                const response = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=multiResolutionGif`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(gifCollectionData)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GIF publish error response:', errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const result = await response.json();
                console.log(`📥 GIF collection publish response:`, result);
                
                // Handle both GUN (did) and Arweave (transactionId) response formats
                let did = result.did || result.didTx || result.oip?.did || result.oip?.didTx;
                
                // Handle Arweave transactionId
                if (!did && result.transactionId) {
                    did = `did:arweave:${result.transactionId}`;
                    console.log(`🔄 Converted transactionId to DID: ${did}`);
                }
                
                if (did) {
                    console.log(`✅ GIF collection published successfully: ${did}`);
                    return did;
                } else {
                    console.error('❌ No DID in GIF collection response:', result);
                    throw new Error(result.error || 'Failed to publish GIF collection - no DID in response');
                }
            } catch (error) {
                console.error('GIF publishing error:', error);
                throw error;
            }
        }

        /**
         * Publish Bundle Exercise
         */
        async function publishBundleExercise(gifDID, equipmentDIDs) {
            try {
                console.log(`📝 publishBundleExercise called with:`, { gifDID, equipmentDIDs, equipmentCount: equipmentDIDs?.length || 0 });
                updateBundleProgress('Publishing exercise record...', 90);
                
                const name = document.getElementById('bundle-exercise-name')?.value;
                if (!name) {
                    throw new Error('Please enter exercise name');
                }

                const storageType = document.getElementById('bundle-exercise-storage')?.value || 'arweave';

                // Get instructions
                const instructionsText = document.getElementById('bundle-exercise-instructions')?.value || '';
                const instructions = instructionsText.split('\n').map(i => i.trim()).filter(i => i);

                // Get muscle groups
                const muscleGroupsText = document.getElementById('bundle-exercise-muscle-groups')?.value || '';
                const muscleGroups = muscleGroupsText.split(',').map(m => m.trim()).filter(m => m);

                const exerciseData = {
                    basic: {
                        name,
                        description: document.getElementById('bundle-exercise-description')?.value || `Exercise: ${name}`,
                        language: 'en'
                    },
                    exercise: {
                        instructions: instructions.length > 0 ? instructions : [''],
                        difficulty: document.getElementById('bundle-exercise-difficulty')?.value || 'beginner',
                        category: document.getElementById('bundle-exercise-category')?.value || 'strength',
                        exercise_type: document.getElementById('bundle-exercise-type')?.value || 'main',
                        measurement_type: document.getElementById('bundle-exercise-measurement')?.value || 'reps',
                        isBodyweight: document.getElementById('bundle-exercise-bodyweight')?.checked || false
                    }
                };

                // Add muscle groups if provided
                if (muscleGroups.length > 0) {
                    exerciseData.exercise.muscleGroups = muscleGroups;
                }

                // Add avatar (GIF) if available
                if (gifDID) {
                    exerciseData.basic.avatar = gifDID;
                }

                // Add equipment DIDs if available
                console.log(`🔍 Checking equipment DIDs:`, { has: !!equipmentDIDs, length: equipmentDIDs?.length, dids: equipmentDIDs });
                if (equipmentDIDs && equipmentDIDs.length > 0) {
                    exerciseData.exercise.equipmentRequired = equipmentDIDs;
                    console.log(`✅ Added equipmentRequired to exercise data:`, exerciseData.exercise.equipmentRequired);
                } else {
                    console.warn(`⚠️  No equipment DIDs to add (equipmentDIDs:`, equipmentDIDs, `)`);
                }

                // Add measurement-specific fields
                const measurementType = exerciseData.exercise.measurement_type;
                
                // Always include estimated duration if provided (for workout time calculations)
                const estDuration = document.getElementById('bundle-exercise-est-duration')?.value;
                if (estDuration) exerciseData.exercise.est_duration_minutes = parseInt(estDuration);
                
                if (measurementType === 'reps') {
                    const sets = document.getElementById('bundle-exercise-sets')?.value;
                    const reps = document.getElementById('bundle-exercise-reps')?.value;
                    if (sets) exerciseData.exercise.recommended_sets = parseInt(sets);
                    if (reps) exerciseData.exercise.recommended_reps = parseInt(reps);
                } else if (measurementType === 'timed') {
                    // For timed exercises, include sets (if provided) and duration
                    const sets = document.getElementById('bundle-exercise-sets')?.value;
                    const duration = document.getElementById('bundle-exercise-duration')?.value;
                    if (sets) exerciseData.exercise.recommended_sets = parseInt(sets);
                    if (duration) exerciseData.exercise.target_duration_seconds = parseInt(duration);
                } else {
                    // For hold and maxdur
                    const duration = document.getElementById('bundle-exercise-duration')?.value;
                    if (duration) exerciseData.exercise.target_duration_seconds = parseInt(duration);
                }

                // Set storage/blockchain type
                if (storageType === 'gun') {
                    exerciseData.storage = 'gun';
                } else {
                    exerciseData.blockchain = storageType;
                }

                console.log(`📤 About to POST exercise record:`, JSON.stringify(exerciseData, null, 2));

                const response = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=exercise`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(exerciseData)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Exercise publish error response:', errorText);
                    throw new Error(`Server returned ${response.status}: ${errorText.substring(0, 200)}`);
                }

                const result = await response.json();
                console.log(`📥 Exercise publish response:`, result);
                
                // Extract DID from response (handle both GUN and Arweave formats)
                // GUN returns: { did: "did:gun:..." }
                // Arweave returns: { transactionId: "..." } which needs to be converted to "did:arweave:..."
                let did = result.did || result.didTx || result.oip?.did || result.oip?.didTx;
                
                // Handle Arweave transactionId
                if (!did && result.transactionId) {
                    did = `did:arweave:${result.transactionId}`;
                    console.log(`🔄 Converted transactionId to DID: ${did}`);
                }
                
                if (did) {
                    console.log(`✅ Exercise published successfully: ${did}`);
                    return did;
                } else {
                    console.error('❌ No DID in response:', result);
                    throw new Error(result.error || 'Failed to publish exercise - no DID in response');
                }
            } catch (error) {
                console.error('Exercise publishing error:', error);
                throw error;
            }
        }

        /**
         * Process equipment items and return DIDs
         */
        async function processEquipmentItems() {
            console.log('🔧 [processEquipmentItems] Starting...');
            const equipmentDIDs = [];
            const equipmentItems = document.querySelectorAll('.equipment-item');
            console.log(`🔧 [processEquipmentItems] Found ${equipmentItems.length} equipment items`);
            
            let totalSteps = equipmentItems.length * 2; // icon + equipment for each
            let currentStep = 0;
            
            for (const item of equipmentItems) {
                const itemId = item.id;
                console.log(`\n🔧 [processEquipmentItems] Processing item: ${itemId}`);
                
                // Check mode: create new vs select existing
                const mode = item.querySelector('.equip-mode')?.value || 'create';
                console.log(`🔧 [processEquipmentItems] Mode: ${mode}`);
                
                if (mode === 'existing') {
                    // Use existing equipment
                    const existingDID = item.querySelector('.equip-existing-select')?.value;
                    console.log(`🔧 [processEquipmentItems] Existing DID selected: ${existingDID}`);
                    if (existingDID) {
                        equipmentDIDs.push(existingDID);
                        console.log(`✅ Using existing equipment: ${existingDID}`);
                        console.log(`🔧 [processEquipmentItems] equipmentDIDs now: [${equipmentDIDs.join(', ')}]`);
                    } else {
                        console.warn('⚠️ Skipping equipment item: no existing equipment selected');
                    }
                    continue; // Skip to next item
                }
                
                // Mode is "create" - get data for creating new equipment
                // Check icon mode
                const iconMode = item.querySelector('.equip-icon-mode')?.value || 'create';
                console.log(`🔧 [processEquipmentItems] Icon mode: ${iconMode}`);
                
                // Get equipment data
                const equipName = item.querySelector('.equip-name')?.value;
                const equipDesc = item.querySelector('.equip-description')?.value;
                const equipStorage = item.querySelector('.equip-storage')?.value || 'arweave';
                
                // Get all new equipment fields
                const equipCategory = item.querySelector('.equip-category')?.value || 'General';
                const equipSubcategory = item.querySelector('.equip-subcategory')?.value || '';
                const equipMuscleGroups = item.querySelector('.equip-muscle-groups')?.value || '';
                const equipDifficulty = item.querySelector('.equip-difficulty')?.value || '';
                const equipSpace = item.querySelector('.equip-space')?.value || '';
                const equipPortability = item.querySelector('.equip-portability')?.value || '';
                const equipPrice = item.querySelector('.equip-price')?.value || '';
                const equipAlternatives = item.querySelector('.equip-alternatives')?.value || '';
                const equipMaintenance = item.querySelector('.equip-maintenance')?.value || '';
                const equipSafety = item.querySelector('.equip-safety')?.value || '';
                const equipBeginnerFriendly = item.querySelector('.equip-beginner-friendly')?.checked || false;
                const equipHomeGym = item.querySelector('.equip-home-gym')?.checked || false;
                const equipCommercial = item.querySelector('.equip-commercial')?.checked || false;
                
                console.log(`🔧 [processEquipmentItems] Equipment data: name="${equipName}", category="${equipCategory}", storage="${equipStorage}"`);
                
                if (!equipName) {
                    console.warn('⚠️ Skipping equipment item with no name');
                    continue;
                }
                
                // Step 1: Handle icon based on mode
                let iconDID = null;
                
                if (iconMode === 'existing') {
                    // Use existing icon
                    iconDID = item.querySelector('.equip-icon-existing-select')?.value;
                    if (iconDID) {
                        console.log(`📦 Using existing icon: ${iconDID}`);
                    }
                } else if (iconMode === 'create') {
                    // Create new icon
                    const iconName = item.querySelector('.equip-icon-name')?.value;
                    const iconFile = item.querySelector('.equip-icon-file')?.files[0];
                    const iconStorage = item.querySelector('.equip-icon-storage')?.value || 'gun';
                    const iconAccess = item.querySelector('.equip-icon-access')?.value || 'public';
                    const iconOrg = item.querySelector('.equip-icon-org')?.value;
                    
                    if (iconFile) {
                    currentStep++;
                    updateBundleProgress(`Publishing equipment icon (${currentStep}/${totalSteps})...`, (currentStep / totalSteps) * 100);
                    
                    const iconFormData = new FormData();
                    iconFormData.append('file', iconFile);
                    iconFormData.append('name', iconName || `${equipName} Icon`);
                    iconFormData.append('description', `Icon for ${equipName}`);
                    iconFormData.append('language', 'en');
                    iconFormData.append('storageType', iconStorage);
                    
                    if (iconStorage === 'gun') {
                        iconFormData.append('accessLevel', iconAccess);
                        if (iconAccess === 'organization' && iconOrg) {
                            iconFormData.append('organizationDID', iconOrg);
                        }
                    }
                    
                    try {
                        // Step 1: Upload icon file
                        const uploadFormData = new FormData();
                        uploadFormData.append('file', iconFile);
                        
                        const uploadResponse = await fetch(`${API_BASE_URL}/api/media/upload`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: uploadFormData
                        });
                        
                        if (!uploadResponse.ok) {
                            throw new Error(`Icon upload failed: ${uploadResponse.status}`);
                        }
                        
                        const uploadResult = await uploadResponse.json();
                        
                        if (!uploadResult.mediaId) {
                            throw new Error('No mediaId returned from icon upload');
                        }
                        
                        console.log(`✅ Icon upload complete - mediaId: ${uploadResult.mediaId}`);
                        
                        // Step 2: Upload to IPFS (optional but recommended)
                        let ipfsAddress = '';
                        try {
                            const ipfsResponse = await fetch(`${API_BASE_URL}/api/media/ipfs-upload`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ mediaId: uploadResult.mediaId })
                            });
                            
                            if (ipfsResponse.ok) {
                                const ipfsResult = await ipfsResponse.json();
                                ipfsAddress = ipfsResult.ipfsHash || '';
                                console.log(`✅ Icon IPFS upload complete: ${ipfsAddress}`);
                            }
                        } catch (ipfsError) {
                            console.warn(`⚠️ Icon IPFS upload error:`, ipfsError);
                        }
                        
                        // Step 3: Setup web server access (filename-based URL)
                        let webUrl = uploadResult.httpUrl; // Fallback
                        try {
                            const webResponse = await fetch(`${API_BASE_URL}/api/media/web-setup`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify({ 
                                    mediaId: uploadResult.mediaId,
                                    filename: uploadResult.originalName
                                })
                            });
                            
                            if (webResponse.ok) {
                                const webResult = await webResponse.json();
                                webUrl = webResult.webUrl || uploadResult.httpUrl;
                                console.log(`✅ Icon web setup complete: ${webUrl}`);
                            }
                        } catch (webError) {
                            console.warn(`⚠️ Icon web setup error:`, webError);
                        }
                        
                        // Step 4: Create image record with all network addresses
                        const imageData = {
                            basic: {
                                name: iconName || `${equipName} Icon`,
                                description: `Icon for ${equipName}`,
                                language: 'en',
                                webUrl: webUrl
                            },
                            image: {
                                webUrl: webUrl,
                                bittorrentAddress: uploadResult.magnetURI || '',
                                ipfsAddress: ipfsAddress,
                                arweaveAddress: '',
                                filename: uploadResult.originalName,
                                size: uploadResult.size,
                                contentType: uploadResult.mime
                            }
                        };
                        
                        if (iconStorage === 'gun') {
                            imageData.storage = 'gun';
                            imageData.accessControl = {
                                access_level: iconAccess
                            };
                            if (iconAccess === 'organization' && iconOrg) {
                                imageData.accessControl.shared_with = iconOrg;
                            }
                        } else {
                            imageData.blockchain = iconStorage;
                        }
                        
                        const recordResponse = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=image`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify(imageData)
                        });
                        
                        if (!recordResponse.ok) {
                            throw new Error(`Icon record creation failed: ${recordResponse.status}`);
                        }
                        
                        const iconResult = await recordResponse.json();
                        console.log('🔧 [processEquipmentItems] Icon API response:', iconResult);
                        
                        // Handle both GUN (did) and Arweave (transactionId) response formats
                        iconDID = iconResult.did || iconResult.didTx || iconResult.oip?.did || iconResult.oip?.didTx;
                        
                        // Handle Arweave transactionId
                        if (!iconDID && iconResult.transactionId) {
                            iconDID = `did:arweave:${iconResult.transactionId}`;
                            console.log('🔧 [processEquipmentItems] Converted transactionId to icon DID:', iconDID);
                        }
                        
                        console.log('🔧 [processEquipmentItems] Extracted icon DID:', iconDID);
                        
                        if (iconDID) {
                            console.log(`✅ Icon published: ${iconDID}`);
                        } else {
                            console.error('❌ No DID found in icon response:', iconResult);
                        }
                    } catch (error) {
                        console.error('Error publishing icon:', error);
                    }
                    }
                }
                // icon mode 'none' or any other value: iconDID stays null
                
                // Step 2: Publish equipment
                currentStep++;
                updateBundleProgress(`Publishing equipment (${currentStep}/${totalSteps})...`, (currentStep / totalSteps) * 100);
                
                const equipmentData = {
                    basic: {
                        name: equipName,
                        description: equipDesc || `Equipment: ${equipName}`,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000)
                    },
                    fitnessEquipment: {
                        category: equipCategory,
                        subcategory: equipSubcategory || 'Training Equipment',
                        muscle_groups: equipMuscleGroups ? equipMuscleGroups.split(',').map(m => m.trim()).filter(m => m) : [],
                        difficulty_level: equipDifficulty,
                        space_required: equipSpace,
                        portability: equipPortability,
                        price_range: equipPrice,
                        alternatives: equipAlternatives ? equipAlternatives.split(',').map(a => a.trim()).filter(a => a) : [],
                        maintenance_level: equipMaintenance,
                        safety_considerations: equipSafety,
                        beginner_friendly: equipBeginnerFriendly,
                        home_gym_suitable: equipHomeGym,
                        commercial_grade: equipCommercial
                    }
                };
                
                if (iconDID) {
                    equipmentData.basic.avatar = iconDID;
                }
                
                // Set storage/blockchain type
                if (equipStorage === 'gun') {
                    equipmentData.storage = 'gun';
                } else {
                    equipmentData.blockchain = equipStorage;
                }
                
                try {
                    const equipmentResponse = await fetch(`${API_BASE_URL}/api/records/newRecord?recordType=fitnessEquipment`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(equipmentData)
                    });
                    
                    if (!equipmentResponse.ok) {
                        throw new Error(`Equipment publish failed: ${equipmentResponse.status}`);
                    }
                    
                    const equipmentResult = await equipmentResponse.json();
                    console.log('🔧 [processEquipmentItems] Equipment API response:', equipmentResult);
                    
                    // Handle both GUN (did) and Arweave (transactionId) response formats
                    let equipmentDID = equipmentResult.did || equipmentResult.didTx || equipmentResult.oip?.did || equipmentResult.oip?.didTx;
                    
                    // Handle Arweave transactionId
                    if (!equipmentDID && equipmentResult.transactionId) {
                        equipmentDID = `did:arweave:${equipmentResult.transactionId}`;
                        console.log('🔧 [processEquipmentItems] Converted transactionId to equipment DID:', equipmentDID);
                    }
                    
                    console.log('🔧 [processEquipmentItems] Extracted DID:', equipmentDID);
                    
                    if (equipmentDID) {
                        equipmentDIDs.push(equipmentDID);
                        console.log(`✅ Equipment published: ${equipmentDID}`);
                        console.log(`🔧 [processEquipmentItems] equipmentDIDs now: [${equipmentDIDs.join(', ')}]`);
                    } else {
                        console.error('❌ No DID found in equipment response:', equipmentResult);
                    }
                } catch (error) {
                    console.error('❌ Error publishing equipment:', error);
                }
            }
            
            console.log(`\n🔧 [processEquipmentItems] COMPLETE. Returning ${equipmentDIDs.length} DIDs:`, equipmentDIDs);
            return equipmentDIDs;
        }

        /**
         * Update bundle progress
         */
        function updateBundleProgress(message, percentage) {
            const progressContainer = document.getElementById('bundle-progress');
            const progressMessage = document.getElementById('bundle-progress-message');
            const progressBar = document.getElementById('bundle-progress-bar');
            
            if (progressContainer) {
                progressContainer.classList.remove('hidden');
            }
            
            if (progressMessage) {
                progressMessage.textContent = message;
            }
            
            if (progressBar) {
                progressBar.style.width = `${percentage}%`;
            }
        }

        // ==================== END EXERCISE BUNDLE FUNCTIONS ====================

        // Publishing functions for each record type
        async function publishPost() {
            try {
                const postSource = document.getElementById('post-source').value;
                let postData;

                if (postSource === 'archive-x' && window.scrapedXPostData) {
                    // Use scraped X post data
                    postData = {
                        basic: {
                            name: window.scrapedXPostData.text.substring(0, 100) + (window.scrapedXPostData.text.length > 100 ? '...' : ''),
                            description: window.scrapedXPostData.text,
                            language: 'en',
                            date: window.scrapedXPostData.date ? Math.floor(new Date(window.scrapedXPostData.date).getTime() / 1000) : Math.floor(Date.now() / 1000),
                            nsfw: false,
                            tagItems: ['twitter', 'x', 'social-media'],
                            webUrl: window.scrapedXPostData.url // Original X post URL
                        },
                        post: {
                            articleText: window.scrapedXPostData.text,
                            bylineWriter: window.scrapedXPostData.author,
                            webUrl: window.scrapedXPostData.url,
                            imageItems: window.scrapedXPostData.images || [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: [],
                            replyTo: ''
                        }
                    };
                } else if (postSource === 'archive-web' && window.scrapedWebArticleData) {
                    // Use scraped web article data
                    postData = {
                        basic: {
                            name: window.scrapedWebArticleData.title || 'Archived Web Article',
                            description: window.scrapedWebArticleData.description || '',
                            language: 'en',
                            date: window.scrapedWebArticleData.publishDate || Math.floor(Date.now() / 1000),
                            nsfw: false,
                            tagItems: window.scrapedWebArticleData.tags || ['web-article', 'archived'],
                            webUrl: window.scrapedWebArticleData.url // Original article URL
                        },
                        post: {
                            articleText: window.scrapedWebArticleData.content || '',
                            bylineWriter: window.scrapedWebArticleData.byline || '',
                            webUrl: window.scrapedWebArticleData.url,
                            featuredImage: window.scrapedWebArticleData.embeddedImageUrl || '',
                            imageItems: [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: window.scrapedWebArticleData.summaryTTS ? [{
                                audio: {
                                    webUrl: window.scrapedWebArticleData.summaryTTS,
                                    contentType: 'audio/mpeg'
                                }
                            }] : [],
                            audioCaptionItems: [],
                            replyTo: ''
                        }
                    };
                } else {
                    // Use manual form data
                    postData = {
                        basic: {
                            name: document.getElementById('post-title').value,
                            description: document.getElementById('post-description').value,
                            language: 'en',
                            date: Math.floor(Date.now() / 1000),
                            nsfw: document.getElementById('post-nsfw').checked,
                            tagItems: document.getElementById('post-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        post: {
                            articleText: document.getElementById('post-content').value,
                            bylineWriter: document.getElementById('post-author')?.value || '',
                            bylineWritersTitle: document.getElementById('post-author-title')?.value || '',
                            bylineWritersLocation: document.getElementById('post-author-location')?.value || '',
                            webUrl: document.getElementById('post-web-url')?.value || '',
                            featuredImage: document.getElementById('post-featured-image')?.value || '',
                            replyTo: document.getElementById('post-reply-to')?.value || '',
                            imageItems: [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: []
                        }
                    };
                }

                if (!postData.basic.name) {
                    showMessage('publish-status', 'Please provide a title for the post', 'error');
                    return;
                }

                // For archived content, the article may already be published, so just show success
                if (postSource === 'archive-web' && (window.scrapedWebArticleData?.did || window.scrapedWebArticleData?.didTx)) {
                    const did = window.scrapedWebArticleData.did || window.scrapedWebArticleData.didTx;
                    showMessage('publish-success', `Article already archived! DID: ${did}`, 'success');
                    return;
                }

                if (!postData.post.articleText && postSource === 'manual') {
                    showMessage('publish-status', 'Please fill in content', 'error');
                    return;
                }

                // Get storage type and GUN-specific options
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                const isPrivate = document.getElementById('gun-private')?.checked || false;

                // Build request body with storage options
                const requestBody = { ...postData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) {
                        requestBody.localId = localId;
                    }
                    if (isPrivate) {
                        requestBody.accessControl = { private: true };
                    }
                } else {
                    requestBody.blockchain = storageType;
                }

                // Determine endpoint based on storage type
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/publish/newPost';
                const queryParams = storageType === 'gun' ? '?recordType=post' : '';

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Handle different response formats for different storage types
                    let successMessage;
                    if (storageType === 'gun') {
                        successMessage = `Post saved to GUN! DID: ${result.did}${result.encrypted ? ' (Encrypted)' : ''}`;
                    } else {
                        successMessage = `Post published successfully! Transaction ID: ${result.transactionId}`;
                    }
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish post', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishVideo() {
            try {
                const videoSource = document.getElementById('video-source').value;
                let videoData;

                if (videoSource === 'youtube-archive' && window.archivedYouTubeData) {
                    // Use archived YouTube data
                    videoData = {
                        youtubeUrl: window.archivedYouTubeData.original_url || document.getElementById('youtube-url').value,
                        archivedVideoUrl: window.archivedYouTubeData.video_url,
                        thumbnailUrl: window.archivedYouTubeData.thumbnail,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t),
                            webUrl: window.archivedYouTubeData.original_url // Original YouTube URL
                        },
                        videoMetadata: {
                            duration: window.archivedYouTubeData.duration,
                            uploader: window.archivedYouTubeData.uploader,
                            upload_date: window.archivedYouTubeData.upload_date,
                            view_count: window.archivedYouTubeData.view_count,
                            resolution: window.archivedYouTubeData.resolution
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                } else {
                    // Use manual form data
                    videoData = {
                        youtubeUrl: document.getElementById('video-url')?.value,
                        thumbnailUrl: document.getElementById('video-thumbnail')?.value,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        videoMetadata: {
                            duration: document.getElementById('video-duration').value ? parseInt(document.getElementById('video-duration').value) * 60 : null,
                            uploader: document.getElementById('video-channel').value
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                }

                if (!videoData.basicMetadata.name) {
                    showMessage('publish-status', 'Please fill in video title', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newVideo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(videoData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Video published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish video', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishAudio() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for audio publishing. Please set your token first.', 'error');
                    return;
                }

                const audioType = document.getElementById('audio-type').value;
                const audioSource = document.getElementById('audio-source').value;
                
                // Get basic form data
                const audioTitle = document.getElementById('audio-title').value.trim();
                const audioDescription = document.getElementById('audio-description').value.trim();
                const audioLanguage = document.getElementById('audio-language').value;
                const audioTags = document.getElementById('audio-tags').value.split(',').map(t => t.trim()).filter(t => t);
                const audioNsfw = document.getElementById('audio-nsfw').checked;
                const audioDuration = parseInt(document.getElementById('audio-duration').value) || 0;
                const audioCreator = document.getElementById('audio-creator').value.trim();

                if (!audioTitle) {
                    showMessage('publish-status', 'Please fill in audio title', 'error');
                    return;
                }

                // Get storage type
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                
                let audioUrl = '';
                let uploadedMediaId = null;
                let fileSize = 0;
                let contentType = '';
                let filename = '';

                // Handle file upload vs URL
                if (audioSource === 'upload') {
                    const fileInput = document.getElementById('audio-file');
                    const file = fileInput.files[0];
                    
                    if (!file) {
                        showMessage('publish-status', 'Please select an audio file to upload', 'error');
                        return;
                    }

                    // Show upload progress
                    const progressDiv = document.getElementById('audio-upload-progress');
                    const progressFill = progressDiv.querySelector('.progress-fill');
                    const progressText = progressDiv.querySelector('.progress-text');
                    progressDiv.classList.remove('hidden');
                    
                    progressText.textContent = 'Uploading audio file...';
                    progressFill.style.width = '10%';

                    // Step 1: Upload file to media system
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('name', audioTitle);
                    formData.append('access_level', 'private');
                    
                    if (audioDescription) {
                        formData.append('description', audioDescription);
                    }

                    const uploadResponse = await fetch('/api/media/upload', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: formData
                    });

                    progressFill.style.width = '50%';
                    progressText.textContent = 'Creating BitTorrent...';

                    const uploadResult = await uploadResponse.json();
                    
                    if (!uploadResponse.ok) {
                        throw new Error(uploadResult.error || 'File upload failed');
                    }

                    // Use the uploaded file info
                    uploadedMediaId = uploadResult.mediaId;
                    audioUrl = uploadResult.httpUrl;
                    fileSize = uploadResult.size;
                    contentType = uploadResult.mime;
                    filename = uploadResult.originalName;

                    progressFill.style.width = '70%';
                    progressText.textContent = 'Creating audio record...';
                } else {
                    // Use provided URL
                    audioUrl = document.getElementById('audio-url').value.trim();
                    if (!audioUrl) {
                        showMessage('publish-status', 'Please provide an audio URL', 'error');
                        return;
                    }
                    
                    // Extract filename from URL
                    try {
                        const urlObj = new URL(audioUrl);
                        filename = urlObj.pathname.split('/').pop() || 'audio_file';
                        // Try to guess content type from extension
                        const ext = filename.split('.').pop()?.toLowerCase();
                        const mimeMap = {
                            'mp3': 'audio/mpeg',
                            'wav': 'audio/wav',
                            'flac': 'audio/flac',
                            'ogg': 'audio/ogg',
                            'aac': 'audio/aac',
                            'm4a': 'audio/mp4'
                        };
                        contentType = mimeMap[ext] || 'audio/mpeg';
                    } catch (error) {
                        filename = 'audio_file';
                        contentType = 'audio/mpeg';
                    }
                }

                // Build record data based on audio type
                let recordData;
                
                if (audioType === 'music') {
                    // Build music record with basic, audio, and music templates
                    recordData = {
                        basic: {
                            name: audioTitle,
                            description: audioDescription || `Music: ${audioTitle}`,
                            language: audioLanguage,
                            date: Math.floor(Date.now() / 1000),
                            nsfw: audioNsfw,
                            tagItems: audioTags,
                            webUrl: audioUrl
                        },
                        audio: {
                            webUrl: audioUrl,
                            filename: filename,
                            size: fileSize,
                            duration: audioDuration,
                            contentType: contentType,
                            creator: audioCreator
                        },
                        music: {
                            genre: document.getElementById('music-genre').value || '',
                            subGenre: document.getElementById('music-sub-genre').value || '',
                            bpm: parseInt(document.getElementById('music-bpm').value) || 0,
                            key: document.getElementById('music-key').value || '',
                            sampleRateHz: parseInt(document.getElementById('music-sample-rate').value) || 44100,
                            bitDepth: parseInt(document.getElementById('music-bit-depth').value) || 16,
                            album: document.getElementById('music-album').value || '',
                            trackNumber: parseInt(document.getElementById('music-track-number').value) || 0,
                            isrc: document.getElementById('music-isrc').value || '',
                            lyrics: document.getElementById('music-lyrics').value || '',
                            composerItems: document.getElementById('music-composers').value.split(',').map(t => t.trim()).filter(t => t),
                            performerItems: document.getElementById('music-performers').value.split(',').map(t => t.trim()).filter(t => t)
                        }
                    };

                    // Add BitTorrent address if file was uploaded
                    if (uploadedMediaId) {
                        recordData.audio.bittorrentAddress = uploadResult.magnetURI;
                    }
                } else {
                    // Regular audio record (for future podcast support)
                    recordData = {
                        basic: {
                            name: audioTitle,
                            description: audioDescription || `Audio: ${audioTitle}`,
                            language: audioLanguage,
                            date: Math.floor(Date.now() / 1000),
                            nsfw: audioNsfw,
                            tagItems: audioTags,
                            webUrl: audioUrl
                        },
                        audio: {
                            webUrl: audioUrl,
                            filename: filename,
                            size: fileSize,
                            duration: audioDuration,
                            contentType: contentType,
                            creator: audioCreator
                        }
                    };

                    // Add BitTorrent address if file was uploaded
                    if (uploadedMediaId) {
                        recordData.audio.bittorrentAddress = uploadResult.magnetURI;
                    }
                }

                // Determine endpoint and storage type
                let endpoint, queryParams;
                
                if (storageType === 'gun') {
                    endpoint = '/api/records/newRecord';
                    queryParams = `?recordType=${audioType}&storage=gun`;
                    if (uploadedMediaId) {
                        queryParams += `&localId=audio_${uploadedMediaId}`;
                    }
                } else {
                    endpoint = '/api/records/newRecord';
                    queryParams = `?recordType=${audioType}&storage=arweave`;
                }

                // Add storage info to record data
                recordData.storage = storageType;
                if (storageType !== 'gun') {
                    recordData.blockchain = storageType;
                }

                console.log('🎵 Publishing audio record:', {
                    audioType,
                    audioSource,
                    storageType,
                    endpoint: endpoint + queryParams,
                    hasUploadedFile: !!uploadedMediaId
                });

                const response = await fetch(endpoint + queryParams, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recordData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Update progress if uploading
                    if (audioSource === 'upload') {
                        const progressDiv = document.getElementById('audio-upload-progress');
                        const progressFill = progressDiv.querySelector('.progress-fill');
                        const progressText = progressDiv.querySelector('.progress-text');
                        progressFill.style.width = '100%';
                        progressText.textContent = 'Audio published successfully!';
                    }

                    const successMessage = storageType === 'gun' 
                        ? `${audioType.charAt(0).toUpperCase() + audioType.slice(1)} published to GUN! DID: ${result.did}` 
                        : `${audioType.charAt(0).toUpperCase() + audioType.slice(1)} published successfully! Transaction ID: ${result.transactionId}`;
                    
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Show audio preview if file was uploaded
                    if (uploadedMediaId && uploadResult) {
                        showAudioPreview({
                            ...uploadResult,
                            recordType: audioType,
                            recordDid: result.did
                        });
                    }
                    
                    // Clear form after delay
                    setTimeout(() => {
                        document.getElementById('publish-record-type').value = '';
                        loadPublishInterface();
                    }, 3000);
                } else {
                    showMessage('publish-status', result.error || `Failed to publish ${audioType}`, 'error');
                }
            } catch (error) {
                console.error('Audio publishing error:', error);
                showMessage('publish-status', 'Error: ' + error.message, 'error');
                
                // Reset progress bar on error
                const progressDiv = document.getElementById('audio-upload-progress');
                if (progressDiv && !progressDiv.classList.contains('hidden')) {
                    const progressFill = progressDiv.querySelector('.progress-fill');
                    const progressText = progressDiv.querySelector('.progress-text');
                    progressFill.style.width = '0%';
                    progressText.textContent = 'Upload failed';
                }
            }
        }

        function showAudioPreview(audioResult) {
            const previewDiv = document.getElementById('audio-preview');
            const previewContent = document.getElementById('audio-preview-content');
            const audioInfo = document.getElementById('audio-info');
            
            previewDiv.classList.remove('hidden');
            
            // Create audio preview
            const httpUrl = audioResult.httpUrl || (audioResult.transport && audioResult.transport.http && audioResult.transport.http[0]);
            
            previewContent.innerHTML = `
                <audio controls style="width: 100%;">
                    <source src="${httpUrl}" type="${audioResult.mime}">
                    Your browser does not support audio playback.
                </audio>
            `;
            
            // Build info display
            let infoHtml = `
                <strong>Media ID:</strong> ${audioResult.mediaId}<br>
                <strong>Size:</strong> ${(audioResult.size / 1024).toFixed(1)} KB<br>
                <strong>MIME:</strong> ${audioResult.mime}<br>
                <strong>Access:</strong> ${audioResult.access_level}<br>
                <strong>BitTorrent:</strong> ${audioResult.magnetURI ? 'Available' : 'Not available'}
            `;
            
            // Add record-specific info if available
            if (audioResult.recordType && audioResult.recordDid) {
                infoHtml += `<br><strong>Record Type:</strong> ${audioResult.recordType}`;
                infoHtml += `<br><strong>OIP DID:</strong> ${audioResult.recordDid}`;
            }
            
            audioInfo.innerHTML = infoHtml;
        }

        async function publishRecipe() {
            try {
                // Collect ingredients
                const ingredientRows = document.querySelectorAll('.ingredient-row');
                const ingredients = [];
                const ingredientAmounts = [];
                const ingredientUnits = [];

                ingredientRows.forEach(row => {
                    const amount = row.querySelector('.ingredient-amount').value;
                    const unit = row.querySelector('.ingredient-unit').value;
                    const name = row.querySelector('.ingredient-name').value;
                    
                    if (name.trim()) {
                        ingredients.push(name);
                        ingredientAmounts.push(parseFloat(amount) || 1);
                        ingredientUnits.push(unit || 'unit');
                    }
                });

                const recipeData = {
                    basic: {
                        name: document.getElementById('recipe-title').value,
                        description: document.getElementById('recipe-description').value,
                        language: 'En',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('recipe-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    recipe: [{
                        prep_time_mins: parseInt(document.getElementById('recipe-prep-time').value) || null,
                        cook_time_mins: parseInt(document.getElementById('recipe-cook-time').value) || null,
                        total_time_mins: (parseInt(document.getElementById('recipe-prep-time').value) || 0) + (parseInt(document.getElementById('recipe-cook-time').value) || 0),
                        servings: parseInt(document.getElementById('recipe-servings').value) || null,
                        ingredient_amount: ingredientAmounts,
                        ingredient_unit: ingredientUnits,
                        ingredient: ingredients,
                        instructions: document.getElementById('recipe-instructions').value,
                        notes: document.getElementById('recipe-notes').value,
                        cuisine: document.getElementById('recipe-cuisine').value,
                        course: document.getElementById('recipe-course').value
                    }],
                    image: {
                        webUrl: document.getElementById('recipe-image').value,
                        contentType: 'image/jpeg'
                    }
                };

                if (!recipeData.basic.name || !recipeData.recipe[0].instructions) {
                    showMessage('publish-status', 'Please fill in recipe name and instructions', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newRecipe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recipeData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Recipe published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish recipe', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishWorkout() {
            try {
                // Resolve exercises first
                const exerciseData = await resolveWorkoutExercises();
                
                const workoutData = {
                    basic: {
                        name: document.getElementById('workout-title').value,
                        description: document.getElementById('workout-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('workout-goals').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    workout: {
                        duration_mins: parseInt(document.getElementById('workout-duration').value) || null,
                        difficulty: document.getElementById('workout-difficulty').value,
                        category: document.getElementById('workout-category').value,
                        equipment_required: document.getElementById('workout-equipment').value.split(',').map(t => t.trim()).filter(t => t),
                        target_muscle_groups: document.getElementById('workout-muscles').value.split(',').map(t => t.trim()).filter(t => t),
                        exercise: exerciseData.exerciseDidRefs ? 
                            exerciseData.exercises.map(ex => ex.exerciseDidRef) : 
                            exerciseData.exercises.map(ex => ex.name),
                        exercise_sets: exerciseData.exercises.map(ex => ex.sets),
                        exercise_reps: exerciseData.exercises.map(ex => ex.reps),
                        exercise_rest_seconds: exerciseData.exercises.map(ex => ex.rest_seconds),
                        notes: document.getElementById('workout-notes').value,
                        non_standard: document.getElementById('workout-non-standard').checked
                    }
                };

                if (!workoutData.basic.name || exerciseData.exercises.length === 0) {
                    showMessage('publish-status', 'Please fill in workout name and add at least one exercise', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newWorkout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(workoutData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Workout published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish workout', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Exercise resolution error: ' + error.message, 'error');
            }
        }

        async function publishExercise() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                // Get storage type to determine if access control should be included
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                
                let accessLevel = 'public'; // Default for Arweave
                let selectedOrganizationDid = null;
                
                // Only get access level and organization for GUN storage
                if (storageType === 'gun') {
                    accessLevel = document.getElementById('exercise-access-level').value;
                    
                    // Get organization selection if needed
                    if (accessLevel === 'organization') {
                        selectedOrganizationDid = document.getElementById('exercise-organization').value;
                        if (!selectedOrganizationDid) {
                            showMessage('publish-status', 'Please select an organization when using Organization access level', 'error');
                            return;
                        }
                    }
                }

                const avatarValue = document.getElementById('exercise-avatar').value.trim();
                console.log('🔍 Avatar value entered:', avatarValue);
                
                // Debug equipment values before creating exercise data
                console.log('🔧 Debugging equipment values before publish:');
                const equipmentRequired = getEquipmentValues('equipment-required-container');
                const alternativeEquipment = getEquipmentValues('alternative-equipment-container');
                console.log('🔧 Equipment Required:', equipmentRequired);
                console.log('🔧 Alternative Equipment:', alternativeEquipment);

                const exerciseData = {
                    basic: {
                        name: document.getElementById('exercise-name').value,
                        description: document.getElementById('exercise-description').value,
                        language: document.getElementById('exercise-language').value,
                        nsfw: false,
                        avatar: avatarValue || undefined,
                        tagItems: document.getElementById('exercise-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    exercise: {
                        instructions: document.getElementById('exercise-instructions').value.split('\\n').map(i => i.trim()).filter(i => i),
                        muscleGroups: document.getElementById('exercise-muscle-groups').value.split(',').map(t => t.trim()).filter(t => t),
                        difficulty: document.getElementById('exercise-difficulty').value,
                        category: document.getElementById('exercise-category').value,
                        equipmentRequired: equipmentRequired,
                        alternativeEquipment: alternativeEquipment,
                        isBodyweight: document.getElementById('exercise-bodyweight').checked,
                        exercise_type: document.getElementById('exercise-type').value,
                        measurement_type: document.getElementById('exercise-measurement-type').value,
                        est_duration_minutes: parseInt(document.getElementById('exercise-duration').value) || 5,
                        recommended_sets: parseInt(document.getElementById('exercise-recommended-sets').value) || 3,
                        recommended_reps: parseInt(document.getElementById('exercise-recommended-reps').value) || 8,
                        target_duration_seconds: parseInt(document.getElementById('exercise-target-duration').value) || 30
                    }
                };

                // Only add accessControl for GUN storage (private records)
                if (storageType === 'gun') {
                    exerciseData.accessControl = {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID if selected
                    };
                }

                if (!exerciseData.basic.name || exerciseData.exercise.instructions.length === 0) {
                    showMessage('publish-status', 'Please fill in exercise name and instructions', 'error');
                    return;
                }

                // Get local ID for GUN storage
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                
                // Always use /api/records/newRecord for exercise publishing
                const endpoint = '/api/records/newRecord';
                const queryParams = `?recordType=exercise${localId ? `&localId=${localId}` : ''}`;

                const requestBody = { ...exerciseData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) requestBody.localId = localId;
                } else {
                    requestBody.blockchain = storageType;
                }

                console.log('🚀 Publishing exercise record:', JSON.stringify(requestBody, null, 2));

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    const successMessage = storageType === 'gun' 
                        ? `Exercise published to GUN! DID: ${result.did}` 
                        : `Exercise published to Arweave! Transaction ID: ${result.transactionId}`;
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish exercise', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishFitnessEquipment() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                // Get storage type to determine if access control should be included
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                
                let accessLevel = 'public'; // Default for Arweave
                let selectedOrganizationDid = null;
                
                // Only get access level and organization for GUN storage
                if (storageType === 'gun') {
                    accessLevel = document.getElementById('equipment-access-level').value;
                    
                    // Get organization selection if needed
                    if (accessLevel === 'organization') {
                        selectedOrganizationDid = document.getElementById('equipment-organization').value;
                        if (!selectedOrganizationDid) {
                            showMessage('publish-status', 'Please select an organization when using Organization access level', 'error');
                            return;
                        }
                    }
                }

                const equipmentData = {
                    basic: {
                        name: document.getElementById('equipment-name').value,
                        description: document.getElementById('equipment-description').value,
                        language: document.getElementById('equipment-language').value,
                        date: Math.floor(Date.now() / 1000),
                        tagItems: document.getElementById('equipment-tags').value.split(',').map(t => t.trim()).filter(t => t),
                        avatar: document.getElementById('equipment-avatar').value || undefined
                    },
                    fitnessEquipment: {
                        category: document.getElementById('equipment-category').value,
                        subcategory: document.getElementById('equipment-subcategory').value,
                        muscle_groups: document.getElementById('equipment-muscle-groups').value.split(',').map(t => t.trim()).filter(t => t),
                        exercise_types: document.getElementById('equipment-exercise-types').value.split(',').map(t => t.trim()).filter(t => t),
                        difficulty_level: document.getElementById('equipment-difficulty').value,
                        space_required: document.getElementById('equipment-space-required').value,
                        portability: document.getElementById('equipment-portability').value,
                        price_range: document.getElementById('equipment-price-range').value,
                        alternatives: document.getElementById('equipment-alternatives').value.split(',').map(t => t.trim()).filter(t => t),
                        maintenance_level: document.getElementById('equipment-maintenance').value,
                        safety_considerations: document.getElementById('equipment-safety').value,
                        beginner_friendly: document.getElementById('equipment-beginner-friendly').checked,
                        home_gym_suitable: document.getElementById('equipment-home-gym').checked,
                        commercial_grade: document.getElementById('equipment-commercial').checked
                    }
                };

                // Only add accessControl for GUN storage (private records)
                if (storageType === 'gun') {
                    equipmentData.accessControl = {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID if selected
                    };
                }

                if (!equipmentData.basic.name) {
                    showMessage('publish-status', 'Please fill in equipment name', 'error');
                    return;
                }
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                
                // Always use /api/records/newRecord for fitness equipment publishing
                const endpoint = '/api/records/newRecord';
                const queryParams = `?recordType=fitnessEquipment${localId ? `&localId=${localId}` : ''}`;

                const requestBody = { ...equipmentData };
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) requestBody.localId = localId;
                } else {
                    requestBody.blockchain = storageType;
                }

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    const successMessage = storageType === 'gun' 
                        ? `Equipment published to GUN! DID: ${result.did}` 
                        : `Equipment published to Arweave! Transaction ID: ${result.transactionId}`;
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish equipment', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishMedia() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for media upload. Please set your token first.', 'error');
                    return;
                }

                const fileInput = document.getElementById('media-file');
                const file = fileInput.files[0];
                
                if (!file) {
                    showMessage('publish-status', 'Please select a media file to upload', 'error');
                    return;
                }

                // Determine record type from file MIME type
                const mimeType = file.type;
                let recordType = 'unknown';
                
                if (mimeType.startsWith('image/')) {
                    recordType = 'image';
                } else if (mimeType.startsWith('video/')) {
                    recordType = 'video';
                } else if (mimeType.startsWith('audio/')) {
                    recordType = 'audio';
                } else {
                    showMessage('publish-status', 'Unsupported file type. Please select an image, video, or audio file.', 'error');
                    return;
                }

                // Show upload progress
                const progressDiv = document.getElementById('media-upload-progress');
                const progressFill = progressDiv.querySelector('.progress-fill');
                const progressText = progressDiv.querySelector('.progress-text');
                progressDiv.classList.remove('hidden');
                
                progressText.textContent = 'Uploading file...';
                progressFill.style.width = '10%';

                // Get multi-network storage options
                const enableIPFS = document.getElementById('media-enable-ipfs').checked;
                const enableWeb = document.getElementById('media-enable-web').checked;
                const enableArweave = document.getElementById('media-enable-arweave').checked;

                // Step 1: Upload file to get BitTorrent info and file metadata
                const formData = new FormData();
                formData.append('file', file);
                formData.append('name', document.getElementById('media-name').value || file.name);
                formData.append('access_level', document.getElementById('media-access-level').value);
                
                // Add multi-network storage options
                formData.append('publishTo[ipfs]', enableIPFS);
                formData.append('publishTo[web]', enableWeb);
                formData.append('publishTo[arweave]', enableArweave);
                
                // Add description if provided
                const description = document.getElementById('media-description').value;
                if (description) {
                    formData.append('description', description);
                }

                const uploadResponse = await fetch('/api/media/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: formData
                });

                progressFill.style.width = '30%';
                progressText.textContent = 'Creating BitTorrent...';

                const uploadResult = await uploadResponse.json();
                
                if (!uploadResponse.ok) {
                    throw new Error(uploadResult.error || 'File upload failed');
                }

                // Step 2: Process additional storage networks
                let ipfsAddress = '';
                let webUrl = '';
                let arweaveAddress = '';

                if (enableIPFS) {
                    progressFill.style.width = '50%';
                    progressText.textContent = 'Uploading to IPFS...';
                    
                    try {
                        const ipfsResponse = await fetch('/api/media/ipfs-upload', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify({ mediaId: uploadResult.mediaId })
                        });
                        
                        const ipfsResult = await ipfsResponse.json();
                        if (ipfsResponse.ok) {
                            ipfsAddress = ipfsResult.ipfsHash;
                        }
                    } catch (error) {
                        console.warn('IPFS upload failed:', error);
                    }
                }

                if (enableWeb) {
                    progressFill.style.width = '60%';
                    progressText.textContent = 'Setting up web access...';
                    
                    try {
                        const webResponse = await fetch('/api/media/web-setup', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify({ 
                                mediaId: uploadResult.mediaId,
                                filename: uploadResult.originalName
                            })
                        });
                        
                        const webResult = await webResponse.json();
                        if (webResponse.ok) {
                            webUrl = webResult.webUrl;
                        }
                    } catch (error) {
                        console.warn('Web setup failed:', error);
                    }
                }

                if (enableArweave) {
                    progressFill.style.width = '70%';
                    progressText.textContent = 'Uploading to Arweave...';
                    
                    try {
                        const arweaveResponse = await fetch('/api/media/arweave-upload', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify({ mediaId: uploadResult.mediaId })
                        });
                        
                        const arweaveResult = await arweaveResponse.json();
                        if (arweaveResponse.ok) {
                            arweaveAddress = arweaveResult.transactionId;
                        }
                    } catch (error) {
                        console.warn('Arweave upload failed:', error);
                    }
                }

                progressFill.style.width = '80%';
                progressText.textContent = 'Creating OIP record...';

                // Step 3: Create proper OIP record with all storage addresses
                const mediaTitle = document.getElementById('media-name').value || file.name;
                const mediaDescription = document.getElementById('media-description').value || `${recordType.charAt(0).toUpperCase() + recordType.slice(1)} file: ${file.name}`;
                const language = document.getElementById('media-language').value;
                const tags = document.getElementById('media-tags').value.split(',').map(t => t.trim()).filter(t => t);
                const nsfw = document.getElementById('media-nsfw').checked;

                // Get storage type to determine if access control should be included
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                
                let accessLevel = 'public'; // Default for Arweave
                let selectedOrganizationDid = null;
                
                // Only get access level and organization for GUN storage
                if (storageType === 'gun') {
                    accessLevel = document.getElementById('media-access-level').value;
                    
                    // Get organization selection if needed
                    if (accessLevel === 'organization') {
                        selectedOrganizationDid = document.getElementById('media-organization').value;
                        if (!selectedOrganizationDid) {
                            throw new Error('Please select an organization when using Organization access level');
                        }
                    }
                }

                // Get file dimensions for images/videos (we'll need to extract these)
                let width = 0;
                let height = 0;
                let duration = 0;

                // For images and videos, try to get dimensions
                if (recordType === 'image' || recordType === 'video') {
                    try {
                        const dimensions = await getMediaDimensions(file, recordType);
                        width = dimensions.width;
                        height = dimensions.height;
                        if (recordType === 'video') {
                            duration = dimensions.duration || 0;
                        }
                    } catch (error) {
                        console.warn('Could not extract media dimensions:', error);
                    }
                } else if (recordType === 'audio') {
                    // Try to get audio duration
                    try {
                        const dimensions = await getMediaDimensions(file, recordType);
                        duration = dimensions.duration || 0;
                    } catch (error) {
                        console.warn('Could not extract audio duration:', error);
                    }
                }

                // Build OIP record with multiple storage addresses
                const recordData = {
                    basic: {
                        name: mediaTitle,
                        description: mediaDescription,
                        language: language,
                        date: Math.floor(Date.now() / 1000),
                        nsfw: nsfw,
                        tagItems: tags,
                        webUrl: webUrl || uploadResult.httpUrl // Use web URL if available, fallback to HTTP
                    }
                };

                // Add media-specific template data based on record type
                if (recordType === 'image') {
                    recordData.image = {
                        webUrl: webUrl || uploadResult.httpUrl,
                        bittorrentAddress: uploadResult.magnetURI,
                        ipfsAddress: ipfsAddress,
                        arweaveAddress: arweaveAddress,
                        filename: uploadResult.originalName,
                        size: uploadResult.size,
                        contentType: uploadResult.mime,
                        width: width,
                        height: height
                    };
                } else if (recordType === 'video') {
                    recordData.video = {
                        webUrl: webUrl || uploadResult.httpUrl,
                        bittorrentAddress: uploadResult.magnetURI,
                        ipfsAddress: ipfsAddress,
                        arweaveAddress: arweaveAddress,
                        filename: uploadResult.originalName,
                        size: uploadResult.size,
                        duration: duration,
                        contentType: uploadResult.mime,
                        width: width,
                        height: height
                    };
                } else if (recordType === 'audio') {
                    recordData.audio = {
                        webUrl: webUrl || uploadResult.httpUrl,
                        bittorrentAddress: uploadResult.magnetURI,
                        ipfsAddress: ipfsAddress,
                        arweaveAddress: arweaveAddress,
                        filename: uploadResult.originalName,
                        size: uploadResult.size,
                        duration: duration,
                        contentType: uploadResult.mime,
                        creator: mediaTitle // Use title as creator for media files
                    };
                }

                // Add access control for GUN storage
                if (storageType === 'gun') {
                    recordData.accessControl = {
                        access_level: accessLevel,
                        owner_public_key: getUserPublicKeyFromJWT(),
                        created_by: getUserPublicKeyFromJWT()
                    };
                    
                    if (accessLevel === 'organization' && selectedOrganizationDid) {
                        recordData.accessControl.shared_with = selectedOrganizationDid;
                    }
                }

                // Use the standard record publishing endpoint
                const endpoint = '/api/records/newRecord';
                const queryParams = `?recordType=${recordType}&storage=${storageType}`;

                const recordResponse = await fetch(endpoint + queryParams, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recordData)
                });

                const recordResult = await recordResponse.json();

                if (!recordResponse.ok) {
                    throw new Error(recordResult.error || 'Failed to create OIP record');
                }

                progressFill.style.width = '100%';
                progressText.textContent = 'Upload complete!';
                
                // Build storage summary for success message
                let storageSummary = `BitTorrent: ${uploadResult.magnetURI ? 'Enabled' : 'Failed'}`;
                if (ipfsAddress) storageSummary += `\\nIPFS: ${ipfsAddress}`;
                if (webUrl) storageSummary += `\\nWeb: Available`;
                if (arweaveAddress) storageSummary += `\\nArweave: ${arweaveAddress}`;

                showMessage('publish-success', 
                    `${recordType.charAt(0).toUpperCase() + recordType.slice(1)} published successfully!\\n` +
                    `Record Type: ${recordType}\\n` +
                    `DID: ${recordResult.did}\\n` +
                    `Media ID: ${uploadResult.mediaId}\\n` +
                    `Size: ${(file.size / 1024).toFixed(1)} KB\\n` +
                    storageSummary, 'success');
                
                // Show media preview with both upload and record info
                showMediaPreview({
                    ...uploadResult,
                    recordType: recordType,
                    recordDid: recordResult.did,
                    dimensions: { width, height, duration },
                    ipfsAddress: ipfsAddress,
                    webUrl: webUrl,
                    arweaveAddress: arweaveAddress
                });
                
                // Clear form after delay
                setTimeout(() => {
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                }, 3000);

            } catch (error) {
                console.error('Media publishing error:', error);
                const progressDiv = document.getElementById('media-upload-progress');
                const progressFill = progressDiv.querySelector('.progress-fill');
                const progressText = progressDiv.querySelector('.progress-text');
                progressFill.style.width = '0%';
                progressText.textContent = 'Upload failed';
                showMessage('publish-status', 'Error: ' + error.message, 'error');
            }
        }

        // Helper function to extract media dimensions
        async function getMediaDimensions(file, recordType) {
            return new Promise((resolve) => {
                if (recordType === 'image') {
                    const img = new Image();
                    img.onload = () => {
                        resolve({ width: img.width, height: img.height });
                    };
                    img.onerror = () => {
                        resolve({ width: 0, height: 0 });
                    };
                    img.src = URL.createObjectURL(file);
                } else if (recordType === 'video') {
                    const video = document.createElement('video');
                    video.onloadedmetadata = () => {
                        resolve({ 
                            width: video.videoWidth, 
                            height: video.videoHeight,
                            duration: Math.floor(video.duration) || 0
                        });
                    };
                    video.onerror = () => {
                        resolve({ width: 0, height: 0, duration: 0 });
                    };
                    video.src = URL.createObjectURL(file);
                } else if (recordType === 'audio') {
                    const audio = document.createElement('audio');
                    audio.onloadedmetadata = () => {
                        resolve({ 
                            width: 0, 
                            height: 0,
                            duration: Math.floor(audio.duration) || 0
                        });
                    };
                    audio.onerror = () => {
                        resolve({ width: 0, height: 0, duration: 0 });
                    };
                    audio.src = URL.createObjectURL(file);
                } else {
                    resolve({ width: 0, height: 0, duration: 0 });
                }
            });
        }

        // Helper function to extract user's public key from JWT
        function getUserPublicKeyFromJWT() {
            try {
                if (authToken) {
                    const parts = authToken.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        return payload.publicKey;
                    }
                }
            } catch (error) {
                console.warn('Could not extract public key from JWT:', error);
            }
            return null;
        }

        // Organization management for media publishing
        let availableOrganizations = [];

        async function loadOrganizations() {
            try {
                console.log('📋 Loading organizations...');
                
                if (!authToken) {
                    console.log('⚠️ No auth token available for organization loading');
                    updateOrganizationDropdown();
                    updateGifOrganizationDropdown();
                    updateEquipmentOrganizationDropdown();
                    updateExerciseOrganizationDropdown();
                    return;
                }
                
                const response = await fetch('/api/organizations', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    availableOrganizations = data.organizationsInDB || [];
                    console.log(`✅ Loaded ${availableOrganizations.length} organizations`);
                    updateOrganizationDropdown();
                    updateGifOrganizationDropdown(); // Also update GIF dropdown
                    updateEquipmentOrganizationDropdown(); // Also update Equipment dropdown
                    updateExerciseOrganizationDropdown(); // Also update Exercise dropdown
                } else {
                    console.warn('⚠️ Failed to load organizations:', response.status);
                    updateOrganizationDropdown(); // Show empty state
                    updateGifOrganizationDropdown(); // Show empty state
                    updateEquipmentOrganizationDropdown(); // Show empty state
                    updateExerciseOrganizationDropdown(); // Show empty state
                }
            } catch (error) {
                console.error('❌ Error loading organizations:', error);
                updateOrganizationDropdown(); // Show error state
                updateGifOrganizationDropdown(); // Show error state
                updateEquipmentOrganizationDropdown(); // Show error state
                updateExerciseOrganizationDropdown(); // Show error state
            }
        }

        function updateOrganizationDropdown() {
            const orgSelect = document.getElementById('media-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function updateMediaAccessLevel() {
            const accessLevel = document.getElementById('media-access-level').value;
            const orgSelection = document.getElementById('media-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
            } else {
                orgSelection.style.display = 'none';
            }
        }

        // Helper function to detect file type and update UI
        function updateMediaFilePreview() {
            const fileInput = document.getElementById('media-file');
            const detectedTypeDiv = document.getElementById('detected-file-type');
            const typeDisplay = document.getElementById('detected-type-display');
            const typeDescription = document.getElementById('detected-type-description');
            
            if (fileInput.files && fileInput.files[0]) {
                const file = fileInput.files[0];
                const mimeType = file.type;
                let recordType = 'unknown';
                let description = '';
                
                if (mimeType.startsWith('image/')) {
                    recordType = 'image';
                    description = 'Will create an OIP image record with BitTorrent distribution';
                } else if (mimeType.startsWith('video/')) {
                    recordType = 'video';
                    description = 'Will create an OIP video record with BitTorrent distribution and streaming support';
                } else if (mimeType.startsWith('audio/')) {
                    recordType = 'audio';
                    description = 'Will create an OIP audio record with BitTorrent distribution and streaming support';
                } else {
                    recordType = 'unknown';
                    description = 'Unsupported file type - please select an image, video, or audio file';
                }
                
                typeDisplay.textContent = `${recordType.toUpperCase()} Record`;
                typeDescription.textContent = description;
                detectedTypeDiv.classList.remove('hidden');
                
                // Auto-populate name if empty
                const nameInput = document.getElementById('media-name');
                if (!nameInput.value) {
                    // Use filename without extension as default name
                    const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
                    nameInput.value = nameWithoutExt;
                }
            } else {
                detectedTypeDiv.classList.add('hidden');
            }
        }

        function showMediaPreview(mediaResult) {
            const previewDiv = document.getElementById('media-preview');
            const previewContent = document.getElementById('media-preview-content');
            const mediaInfo = document.getElementById('media-info');
            
            previewDiv.classList.remove('hidden');
            
            // Create preview based on MIME type
            const httpUrl = mediaResult.httpUrl || (mediaResult.transport && mediaResult.transport.http && mediaResult.transport.http[0]);
            
            if (mediaResult.mime.startsWith('image/')) {
                previewContent.innerHTML = `<img src="${httpUrl}" style="max-width: 100%; max-height: 200px; border-radius: 4px;" onerror="this.style.display='none';">`;
            } else if (mediaResult.mime.startsWith('video/')) {
                previewContent.innerHTML = `<video controls style="max-width: 100%; max-height: 200px; border-radius: 4px;">
                    <source src="${httpUrl}" type="${mediaResult.mime}">
                    Your browser does not support video playback.
                </video>`;
            } else if (mediaResult.mime.startsWith('audio/')) {
                previewContent.innerHTML = `<audio controls style="width: 100%;">
                    <source src="${httpUrl}" type="${mediaResult.mime}">
                    Your browser does not support audio playback.
                </audio>`;
            } else {
                previewContent.innerHTML = `<div style="padding: 20px; text-align: center; background: #f0f0f0; border-radius: 4px;">
                    📄 ${mediaResult.originalName}
                </div>`;
            }
            
            // Build info display with all storage addresses
            let infoHtml = `
                <strong>Media ID:</strong> ${mediaResult.mediaId}<br>
                <strong>Size:</strong> ${(mediaResult.size / 1024).toFixed(1)} KB<br>
                <strong>MIME:</strong> ${mediaResult.mime}<br>
                <strong>Access:</strong> ${mediaResult.access_level}<br>
                <strong>Storage Networks:</strong><br>
                <div style="margin-left: 15px; font-size: 11px; color: #666;">
                    🔗 BitTorrent: ${mediaResult.magnetURI ? 'Available' : 'Not available'}<br>
                    ${mediaResult.ipfsAddress ? `🌐 IPFS: ${mediaResult.ipfsAddress}<br>` : ''}
                    ${mediaResult.webUrl ? `🌍 Web: Available<br>` : ''}
                    ${mediaResult.arweaveAddress ? `⛓️ Arweave: ${mediaResult.arweaveAddress}<br>` : ''}
                </div>
            `;
            
            // Add record-specific info if available
            if (mediaResult.recordType && mediaResult.recordDid) {
                infoHtml += `<br><strong>Record Type:</strong> ${mediaResult.recordType}`;
                infoHtml += `<br><strong>OIP DID:</strong> ${mediaResult.recordDid}`;
                
                // Add dimensions if available
                if (mediaResult.dimensions) {
                    if (mediaResult.dimensions.width && mediaResult.dimensions.height) {
                        infoHtml += `<br><strong>Dimensions:</strong> ${mediaResult.dimensions.width}x${mediaResult.dimensions.height}`;
                    }
                    if (mediaResult.dimensions.duration) {
                        infoHtml += `<br><strong>Duration:</strong> ${mediaResult.dimensions.duration}s`;
                    }
                }
            }
            
            mediaInfo.innerHTML = infoHtml;
        }

        async function publishMultiResolutionGif() {
            try {
                if (!authToken) {
                    showMessage('publish-status', 'JWT token required for publishing. Please set your token first.', 'error');
                    return;
                }

                const collectionName = document.getElementById('gif-collection-name').value;
                if (!collectionName) {
                    showMessage('publish-status', 'Please fill in collection name', 'error');
                    return;
                }

                const inputMethod = document.getElementById('gif-input-method').value;
                
                // Get storage type to determine if access control should be included
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                
                let accessLevel = 'public'; // Default for Arweave
                let selectedOrganizationDid = null;
                
                // Only get access level and organization for GUN storage
                if (storageType === 'gun') {
                    accessLevel = document.getElementById('gif-access-level').value;
                    
                    // Get organization selection if needed
                    if (accessLevel === 'organization') {
                        selectedOrganizationDid = document.getElementById('gif-organization').value;
                        if (!selectedOrganizationDid) {
                            showMessage('publish-status', 'Please select an organization when using Organization access level', 'error');
                            return;
                        }
                    }
                }

                let gifRefs = [];
                let resolutionLabels = [];
                let fileSizes = [];
                let widths = [];
                let heights = [];

                // Update button text
                const publishBtn = document.getElementById('gif-publish-text');
                const originalBtnText = publishBtn.textContent;

                if (inputMethod === 'upload') {
                    // Upload mode: Upload files and create image records first
                    publishBtn.textContent = '📤 Uploading GIF Files...';
                    showMessage('publish-status', 'Uploading GIF files and creating image records...', 'info');
                    
                    const fileRows = document.querySelectorAll('.gif-file-row');
                    const uploadTasks = [];
                    
                    for (const row of fileRows) {
                        const fileInput = row.querySelector('.gif-file-input');
                        const file = fileInput.files[0];
                        const label = row.querySelector('.gif-resolution-label').value.trim();
                        const width = parseInt(row.querySelector('.gif-width').value) || 0;
                        const height = parseInt(row.querySelector('.gif-height').value) || 0;
                        
                        if (file && label) {
                            uploadTasks.push({
                                file: file,
                                label: label,
                                width: width,
                                height: height,
                                row: row
                            });
                        }
                    }

                    if (uploadTasks.length === 0) {
                        showMessage('publish-status', 'Please select at least one GIF file', 'error');
                        return;
                    }

                    // Upload each GIF file and create image records with multi-network support
                    for (let i = 0; i < uploadTasks.length; i++) {
                        const task = uploadTasks[i];
                        const progress = Math.floor((i / uploadTasks.length) * 50); // First 50% for uploads
                        
                        publishBtn.textContent = `📤 Uploading ${task.file.name} (${i + 1}/${uploadTasks.length})...`;
                        showMessage('publish-status', `Uploading ${task.file.name} (${i + 1}/${uploadTasks.length})...`, 'info');
                        
                        try {
                            // Step 1: Upload file (creates BitTorrent)
                            const formData = new FormData();
                            formData.append('file', task.file);
                            formData.append('name', `${collectionName} - ${task.label}`);
                            formData.append('access_level', 'private');
                            formData.append('description', `GIF resolution: ${task.label}`);

                            const uploadResponse = await fetch('/api/media/upload', {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: formData
                            });

                            const uploadResult = await uploadResponse.json();
                            if (!uploadResponse.ok) {
                                throw new Error(`Upload failed: ${uploadResult.error}`);
                            }

                            console.log(`✅ Step 1 complete for ${task.label} - mediaId: ${uploadResult.mediaId}`);

                            // Step 2a: Upload to IPFS (if enabled)
                            let ipfsAddress = '';
                            const enableIPFS = document.getElementById('gif-enable-ipfs')?.checked || false;
                            if (enableIPFS) {
                                try {
                                    publishBtn.textContent = `🌐 Uploading ${task.file.name} to IPFS...`;
                                    const ipfsResponse = await fetch('/api/media/ipfs-upload', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Authorization': `Bearer ${authToken}`
                                        },
                                        body: JSON.stringify({ mediaId: uploadResult.mediaId })
                                    });
                                    
                                    const ipfsResult = await ipfsResponse.json();
                                    if (ipfsResponse.ok) {
                                        ipfsAddress = ipfsResult.ipfsHash;
                                        console.log(`✅ Step 2a complete for ${task.label} - IPFS: ${ipfsAddress}`);
                                    }
                                } catch (error) {
                                    console.warn(`⚠️ IPFS upload failed for ${task.label}:`, error);
                                }
                            }

                            // Step 2b: Setup web server access (if enabled)
                            let webUrl = '';
                            const enableWeb = document.getElementById('gif-enable-web')?.checked || false;
                            if (enableWeb) {
                                try {
                                    publishBtn.textContent = `🌍 Setting up web access for ${task.file.name}...`;
                                    const webResponse = await fetch('/api/media/web-setup', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'Authorization': `Bearer ${authToken}`
                                        },
                                        body: JSON.stringify({ 
                                            mediaId: uploadResult.mediaId,
                                            filename: uploadResult.originalName
                                        })
                                    });
                                    
                                    const webResult = await webResponse.json();
                                    if (webResponse.ok) {
                                        webUrl = webResult.webUrl;
                                        console.log(`✅ Step 2b complete for ${task.label} - Web URL: ${webUrl}`);
                                    }
                                } catch (error) {
                                    console.warn(`⚠️ Web setup failed for ${task.label}:`, error);
                                }
                            }

                            // Step 3: Build complete OIP record with all network addresses
                            const recordData = {
                                basic: {
                                    name: `${collectionName} - ${task.label}`,
                                    description: `GIF resolution: ${task.label}`,
                                    language: 'en',
                                    date: Math.floor(Date.now() / 1000),
                                    nsfw: false,
                                    tagItems: ['gif', 'multi-resolution', task.label],
                                    webUrl: webUrl || uploadResult.httpUrl  // Prefer web URL, fallback to httpUrl
                                },
                                image: {
                                    webUrl: webUrl || uploadResult.httpUrl,
                                    bittorrentAddress: uploadResult.magnetURI,
                                    ipfsAddress: ipfsAddress,
                                    arweaveAddress: "",  // Not uploading to Arweave for GIFs
                                    filename: uploadResult.originalName,
                                    size: uploadResult.size,
                                    contentType: uploadResult.mime,
                                    width: task.width,
                                    height: task.height
                                },
                                accessControl: {
                                    access_level: accessLevel,
                                    owner_public_key: getUserPublicKeyFromJWT(),
                                    created_by: getUserPublicKeyFromJWT(),
                                    shared_with: selectedOrganizationDid || undefined
                                }
                            };

                            console.log(`📋 Step 3: Built record structure for ${task.label}`);

                            // Step 4: Publish complete OIP record to GUN
                            publishBtn.textContent = `📋 Creating record for ${task.file.name}...`;
                            const recordResponse = await fetch('/api/records/newRecord?recordType=image&storage=gun', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${authToken}`
                                },
                                body: JSON.stringify(recordData)
                            });

                            const recordResult = await recordResponse.json();
                            if (!recordResponse.ok) {
                                throw new Error(`Record creation failed: ${recordResult.error}`);
                            }

                            console.log(`✅ Step 4 complete for ${task.label} - OIP Record: ${recordResult.did}`);

                            // Store the results
                            gifRefs.push(recordResult.did);
                            resolutionLabels.push(task.label);
                            fileSizes.push(task.file.size);
                            widths.push(task.width);
                            heights.push(task.height);

                            console.log(`✅ Created multi-network image record for ${task.label}: ${recordResult.did}`);
                            console.log(`📊 Networks enabled: BitTorrent: ✅, IPFS: ${enableIPFS ? '✅' : '❌'}, Web: ${enableWeb ? '✅' : '❌'}`);
                            
                        } catch (error) {
                            showMessage('publish-status', `Error uploading ${task.file.name}: ${error.message}`, 'error');
                            return;
                        }
                    }
                    
                } else {
                    // Manual mode: Collect existing DIDs
                    const refRows = document.querySelectorAll('.gif-ref-row');
                    refRows.forEach(row => {
                        const did = row.querySelector('.gif-media-did').value.trim();
                        const label = row.querySelector('.gif-resolution-label').value.trim();
                        const width = parseInt(row.querySelector('.gif-width').value) || 0;
                        const height = parseInt(row.querySelector('.gif-height').value) || 0;
                        
                        if (did && label) {
                            gifRefs.push(did);
                            resolutionLabels.push(label);
                            widths.push(width);
                            heights.push(height);
                            fileSizes.push(0); // Unknown for manual DIDs
                        }
                    });

                    if (gifRefs.length === 0) {
                        showMessage('publish-status', 'Please add at least one GIF media reference', 'error');
                        return;
                    }
                }

                // Create the multiResolutionGif record
                publishBtn.textContent = '📋 Creating Collection Record...';
                const ipfsEnabled = document.getElementById('gif-enable-ipfs')?.checked || false;
                const webEnabled = document.getElementById('gif-enable-web')?.checked || false;
                showMessage('publish-status', `Creating multi-resolution GIF collection record... (Networks: BitTorrent ✅, IPFS ${ipfsEnabled ? '✅' : '❌'}, Web ${webEnabled ? '✅' : '❌'})`, 'info');

                const gifData = {
                    basic: {
                        name: collectionName,
                        description: document.getElementById('gif-collection-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        tagItems: document.getElementById('gif-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    multiResolutionGif: {
                        gif_media_refs: gifRefs,
                        resolution_labels: resolutionLabels,
                        file_sizes: fileSizes,
                        resolution_widths: widths,
                        resolution_heights: heights,
                        primary_resolution_index: parseInt(document.getElementById('gif-primary-index').value) || 1,
                        loop_count: parseInt(document.getElementById('gif-loop-count').value) || 0,
                        frame_rate: parseInt(document.getElementById('gif-frame-rate').value) || 15,
                        duration_seconds: parseFloat(document.getElementById('gif-duration').value) || 8.5
                    }
                };

                // Only add accessControl for GUN storage (private records)
                if (storageType === 'gun') {
                    gifData.accessControl = {
                        access_level: accessLevel,
                        shared_with: selectedOrganizationDid // Organization's DID if selected
                    };
                }

                // Always publish to GUN for multi-resolution GIF collections
                const localId = document.getElementById('gun-local-id')?.value?.trim() || null;
                const queryParams = `?recordType=multiResolutionGif${localId ? `&localId=${localId}` : ''}`;

                const requestBody = { ...gifData };
                requestBody.storage = 'gun';
                if (localId) requestBody.localId = localId;

                const response = await fetch(`/api/records/newRecord${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    publishBtn.textContent = '✅ Published Successfully!';
                    showMessage('publish-success', 
                        `GIF collection published successfully!\\n` +
                        `Collection DID: ${result.did}\\n` +
                        `Image Records: ${gifRefs.length}\\n` +
                        `Method: ${inputMethod === 'upload' ? 'File Upload' : 'Manual DID Entry'}`, 'success');
                    
                    // Clear form after delay
                    setTimeout(() => {
                        document.getElementById('publish-record-type').value = '';
                        loadPublishInterface();
                    }, 3000);
                } else {
                    publishBtn.textContent = originalBtnText;
                    showMessage('publish-status', result.error || 'Failed to publish GIF collection', 'error');
                }
            } catch (error) {
                publishBtn.textContent = originalBtnText;
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Multi-Resolution GIF management functions
        function updateGifInputMethod() {
            const method = document.getElementById('gif-input-method').value;
            const uploadInterface = document.getElementById('gif-upload-interface');
            const manualInterface = document.getElementById('gif-manual-interface');
            
            if (method === 'upload') {
                uploadInterface.classList.remove('hidden');
                manualInterface.classList.add('hidden');
            } else {
                uploadInterface.classList.add('hidden');
                manualInterface.classList.remove('hidden');
            }
        }

        function updateGifAccessLevel() {
            const accessLevel = document.getElementById('gif-access-level').value;
            const orgSelection = document.getElementById('gif-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
                // Update the GIF organization dropdown
                updateGifOrganizationDropdown();
            } else {
                orgSelection.style.display = 'none';
            }
        }

        function updateGifOrganizationDropdown() {
            const orgSelect = document.getElementById('gif-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function updateEquipmentAccessLevel() {
            const accessLevel = document.getElementById('equipment-access-level').value;
            const orgSelection = document.getElementById('equipment-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
                // Update the equipment organization dropdown
                updateEquipmentOrganizationDropdown();
            } else {
                orgSelection.style.display = 'none';
            }
        }

        function updateEquipmentOrganizationDropdown() {
            const orgSelect = document.getElementById('equipment-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function updateExerciseAccessLevel() {
            const accessLevel = document.getElementById('exercise-access-level').value;
            const orgSelection = document.getElementById('exercise-organization-selection');
            
            if (accessLevel === 'organization') {
                orgSelection.style.display = 'block';
                // Load organizations if not already loaded
                if (availableOrganizations.length === 0) {
                    loadOrganizations();
                }
                // Update the exercise organization dropdown
                updateExerciseOrganizationDropdown();
            } else {
                orgSelection.style.display = 'none';
            }
        }

        function updateExerciseOrganizationDropdown() {
            const orgSelect = document.getElementById('exercise-organization');
            if (!orgSelect) return;

            orgSelect.innerHTML = '';

            if (availableOrganizations.length === 0) {
                orgSelect.innerHTML = '<option value="">No organizations available</option>';
                orgSelect.disabled = true;
            } else {
                orgSelect.innerHTML = '<option value="">Select an organization...</option>';
                availableOrganizations.forEach(org => {
                    const option = document.createElement('option');
                    // Store the organization's DID as the value (from oip.did)
                    option.value = org.oip.did;
                    // Display as handle (name) format
                    option.textContent = `${org.data.orgHandle} (${org.data.name})`;
                    // Store additional data as data attributes for reference
                    option.setAttribute('data-handle', org.data.orgHandle);
                    option.setAttribute('data-name', org.data.name);
                    orgSelect.appendChild(option);
                });
                orgSelect.disabled = false;
            }
        }

        function addGifFileRow() {
            const container = document.getElementById('gif-files-container');
            const newRow = document.createElement('div');
            newRow.className = 'gif-file-row';
            newRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 40px; gap: 10px; margin-bottom: 10px; align-items: end; padding: 10px; border: 1px solid #e0e0e0; border-radius: 4px; background: #fafafa;';
            
            newRow.innerHTML = `
                <div>
                    <input type="file" class="gif-file-input" accept="image/gif" onchange="updateGifFileInfo(this)">
                </div>
                <div>
                    <input type="text" class="gif-resolution-label" placeholder="360p">
                </div>
                <div>
                    <input type="number" class="gif-width" placeholder="640">
                </div>
                <div>
                    <input type="number" class="gif-height" placeholder="360">
                </div>
                <button type="button" onclick="removeGifFileRow(this)" class="btn-small btn-secondary" title="Remove this resolution">-</button>
            `;
            
            container.appendChild(newRow);
        }

        function removeGifFileRow(button) {
            const row = button.closest('.gif-file-row');
            if (document.querySelectorAll('.gif-file-row').length > 1) {
                row.remove();
            }
        }

        async function updateGifFileInfo(fileInput) {
            const row = fileInput.closest('.gif-file-row');
            const file = fileInput.files[0];
            
            if (file && file.type === 'image/gif') {
                try {
                    // Auto-detect dimensions
                    const dimensions = await getMediaDimensions(file, 'image');
                    
                    // Auto-populate fields
                    const widthInput = row.querySelector('.gif-width');
                    const heightInput = row.querySelector('.gif-height');
                    const labelInput = row.querySelector('.gif-resolution-label');
                    
                    if (dimensions.width && dimensions.height) {
                        widthInput.value = dimensions.width;
                        heightInput.value = dimensions.height;
                        
                        // Auto-generate resolution label if empty
                        if (!labelInput.value) {
                            labelInput.value = `${dimensions.height}p`;
                        }
                    }
                    
                    console.log(`📐 Auto-detected GIF dimensions: ${dimensions.width}x${dimensions.height}`);
                } catch (error) {
                    console.warn('Could not auto-detect GIF dimensions:', error);
                }
            }
        }

        // Helper function to add GIF references dynamically
        function addGifReference() {
            const container = document.getElementById('gif-refs-container');
            const newRow = document.createElement('div');
            newRow.className = 'gif-ref-row';
            newRow.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px; align-items: end;';
            
            newRow.innerHTML = `
                <div style="flex: 2;">
                    <input type="text" class="gif-media-did" placeholder="did:gun:media:...">
                </div>
                <div style="flex: 1;">
                    <input type="text" class="gif-resolution-label" placeholder="360p">
                </div>
                <div style="flex: 1;">
                    <input type="number" class="gif-width" placeholder="640">
                </div>
                <div style="flex: 1;">
                    <input type="number" class="gif-height" placeholder="360">
                </div>
                <button type="button" onclick="removeGifReference(this)" class="btn-small btn-secondary">-</button>
            `;
            
            container.appendChild(newRow);
        }

        function removeGifReference(button) {
            const row = button.closest('.gif-ref-row');
            if (document.querySelectorAll('.gif-ref-row').length > 1) {
                row.remove();
            }
        }

        async function publishOrganization() {
            try {
                // Check for token in either location
                const token = authToken || localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
                
                if (!token) {
                    showMessage('publish-status', 'JWT token required for organization registration. Please log in first.', 'error');
                    return;
                }

                // Extract user public key from JWT token
                let userPublicKey;
                try {
                    const parts = token.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        userPublicKey = payload.publicKey;
                        
                        if (!userPublicKey) {
                            throw new Error('Public key not found in JWT token');
                        }
                        
                        // Ensure authToken is set for the API call
                        authToken = token;
                    } else {
                        throw new Error('Invalid JWT format');
                    }
                } catch (jwtError) {
                    showMessage('publish-status', 'Error reading authentication token: ' + jwtError.message, 'error');
                    return;
                }

                // Collect form data
                const orgName = document.getElementById('org-name').value.trim();
                const orgDescription = document.getElementById('org-description').value.trim();
                const orgHandle = document.getElementById('org-handle').value.trim();
                const orgLanguage = document.getElementById('org-language').value;
                const orgWebUrl = document.getElementById('org-web-url').value.trim();
                const membershipPolicy = document.getElementById('org-membership-policy').value;

                // Validation
                if (!orgName) {
                    showMessage('publish-status', 'Please fill in organization name', 'error');
                    return;
                }
                if (!orgDescription) {
                    showMessage('publish-status', 'Please fill in organization description', 'error');
                    return;
                }
                if (!orgHandle) {
                    showMessage('publish-status', 'Please fill in organization handle', 'error');
                    return;
                }
                if (!membershipPolicy) {
                    showMessage('publish-status', 'Please select a membership policy', 'error');
                    return;
                }

                // Validate handle format (lowercase, numbers, hyphens only)
                const handleRegex = /^[a-z0-9-]+$/;
                if (!handleRegex.test(orgHandle)) {
                    showMessage('publish-status', 'Organization handle must contain only lowercase letters, numbers, and hyphens', 'error');
                    return;
                }

                // Build organization record data
                const organizationData = {
                    basic: {
                        name: orgName,
                        description: orgDescription,
                        language: orgLanguage,
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        webUrl: orgWebUrl || undefined
                    },
                    organization: {
                        org_handle: orgHandle,
                        org_public_key: userPublicKey,
                        admin_public_keys: userPublicKey, // Initially, creator is the only admin
                        membership_policy: membershipPolicy
                    }
                };

                // Get storage type and GUN-specific options
                const storageType = document.getElementById('publish-storage-type')?.value || 'arweave';
                const localId = document.getElementById('gun-local-id')?.value?.trim() || orgHandle; // Use org handle as default localId
                const isPrivate = document.getElementById('gun-private')?.checked || false;

                // Build request body with storage options
                const requestBody = { ...organizationData };
                
                if (storageType === 'gun') {
                    requestBody.storage = 'gun';
                    if (localId) {
                        requestBody.localId = localId;
                    }
                    if (isPrivate) {
                        requestBody.accessControl = { 
                            access_level: 'private',
                            owner_public_key: userPublicKey,
                            created_by: userPublicKey
                        };
                    } else {
                        requestBody.accessControl = { 
                            access_level: 'organization',
                            owner_public_key: userPublicKey,
                            created_by: userPublicKey
                        };
                    }
                } else {
                    requestBody.blockchain = storageType;
                }

                // Determine endpoint based on storage type
                const endpoint = storageType === 'gun' ? '/api/records/newRecord' : '/api/organizations/newOrganization';
                const queryParams = storageType === 'gun' ? `?recordType=organization${localId ? `&localId=${localId}` : ''}` : '';

                console.log('[Organization] Publishing with data:', requestBody);
                console.log('[Organization] Using endpoint:', endpoint + queryParams);

                const response = await fetch(`${endpoint}${queryParams}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Handle different response formats for different storage types
                    let successMessage;
                    if (storageType === 'gun') {
                        successMessage = `Organization registered in GUN! DID: ${result.did}${result.encrypted ? ' (Encrypted)' : ''}`;
                    } else {
                        successMessage = `Organization registered successfully! Transaction ID: ${result.transactionId}`;
                    }
                    showMessage('publish-success', successMessage, 'success');
                    
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to register organization', 'error');
                }
            } catch (error) {
                console.error('[Organization] Publishing error:', error);
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Initialize storage type handler for GUN options and access control
        function initializeStorageTypeHandler() {
            const storageSelect = document.getElementById('publish-storage-type');
            const gunOptions = document.getElementById('gun-options');
            
            if (storageSelect) {
                // Add event listener for storage type changes
                storageSelect.addEventListener('change', function() {
                    const selectedStorage = this.value;
                    
                    // Show/hide GUN-specific options
                    if (gunOptions) {
                        gunOptions.style.display = selectedStorage === 'gun' ? 'block' : 'none';
                    }
                    
                    // Show/hide access control fields based on storage type
                    updateAccessControlVisibility(selectedStorage);
                });
                
                // Initialize visibility based on current selection
                const currentStorage = storageSelect.value;
                if (gunOptions) {
                    gunOptions.style.display = currentStorage === 'gun' ? 'block' : 'none';
                }
                updateAccessControlVisibility(currentStorage);
            }
            
            // If organization interface is loaded, populate public key fields
            populateOrganizationPublicKeys();
        }

        function updateAccessControlVisibility(storageType) {
            // Access control fields should only be visible for GUN storage
            const showAccessControl = storageType === 'gun';
            
            // Media interface access control
            const mediaAccessLevel = document.getElementById('media-access-level')?.closest('.form-group');
            const mediaOrgSelection = document.getElementById('media-organization-selection');
            
            // Exercise interface access control
            const exerciseAccessLevel = document.getElementById('exercise-access-level')?.closest('.form-group');
            const exerciseOrgSelection = document.getElementById('exercise-organization-selection');
            
            // Equipment interface access control
            const equipmentAccessLevel = document.getElementById('equipment-access-level')?.closest('.form-group');
            const equipmentOrgSelection = document.getElementById('equipment-organization-selection');
            
            // GIF interface access control
            const gifAccessLevel = document.getElementById('gif-access-level')?.closest('.form-group');
            const gifOrgSelection = document.getElementById('gif-organization-selection');
            
            // Update visibility for all interfaces
            [mediaAccessLevel, exerciseAccessLevel, equipmentAccessLevel, gifAccessLevel].forEach(element => {
                if (element) {
                    element.style.display = showAccessControl ? 'block' : 'none';
                }
            });
            
            // Don't automatically hide organization selections - let individual access level handlers manage them
            // [mediaOrgSelection, exerciseOrgSelection, equipmentOrgSelection, gifOrgSelection].forEach(element => {
            //     if (element) {
            //         element.style.display = 'none'; // Always hide organization selection when storage type changes
            //     }
            // });
            
            console.log(`🔒 Access control fields ${showAccessControl ? 'shown' : 'hidden'} for storage type: ${storageType}`);
        }

        // Populate organization public key fields from JWT token
        function populateOrganizationPublicKeys() {
            const orgPubKeyDisplay = document.getElementById('org-public-key-display');
            const orgAdminKeyDisplay = document.getElementById('org-admin-key-display');
            
            if (orgPubKeyDisplay && orgAdminKeyDisplay) {
                // Check for token in either location
                const token = authToken || localStorage.getItem('oip-jwt-token') || localStorage.getItem('oip-auth-token');
                
                if (token) {
                    try {
                        // Decode JWT to get user's public key
                        const parts = token.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            const userPublicKey = payload.publicKey;
                            
                            if (userPublicKey) {
                                orgPubKeyDisplay.textContent = userPublicKey;
                                orgAdminKeyDisplay.textContent = userPublicKey;
                                console.log('[Organization] Populated public keys from JWT:', userPublicKey.slice(0, 20) + '...');
                            } else {
                                orgPubKeyDisplay.textContent = 'Public key not found in JWT';
                                orgAdminKeyDisplay.textContent = 'Public key not found in JWT';
                                console.error('[Organization] No publicKey field in JWT payload:', payload);
                            }
                        } else {
                            orgPubKeyDisplay.textContent = 'Invalid JWT format';
                            orgAdminKeyDisplay.textContent = 'Invalid JWT format';
                        }
                    } catch (error) {
                        console.error('Error parsing JWT for organization keys:', error);
                        orgPubKeyDisplay.textContent = 'Error parsing JWT';
                        orgAdminKeyDisplay.textContent = 'Error parsing JWT';
                    }
                } else {
                    orgPubKeyDisplay.textContent = 'Please log in to see your public key';
                    orgAdminKeyDisplay.textContent = 'Please log in to see your public key';
                }
            }
        }

        // Helper functions
        function previewImage() {
            const imageUrl = document.getElementById('image-url').value;
            const previewContainer = document.getElementById('image-preview');
            const previewImg = document.getElementById('preview-img');
            
            if (imageUrl) {
                previewImg.src = imageUrl;
                previewContainer.classList.remove('hidden');
            }
        }

    </script>
</body>
</html> 