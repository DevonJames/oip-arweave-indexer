<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ΛLΞXΛNDRIΛ - A decentralized library of art, history, knowledge and memes</title>
    <link rel="icon" type="image/png" href="blue-alexandria-logo.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            min-height: 100vh;
            color: #2d3748;
            margin: 0;
            padding: 0;
        }

        .header {
            background: #1a1a1a;
            color: white;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.8rem;
            font-weight: 100;
            letter-spacing: 3px;
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            text-transform: uppercase;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
        }

        .nav-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #a0a0a0;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            position: relative;
        }

        .nav-tab:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .nav-tab.active {
            color: white;
            background: rgba(255,255,255,0.15);
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .ai-drawer-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-drawer-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .ai-drawer-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        /* Header Search Styles */
        .header-search {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            max-width: 600px;
            margin: 0 20px;
        }

        .header-search input {
            flex: 1;
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .header-search input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .header-search input:focus {
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.15);
        }

        .filters-toggle {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }

        .filters-toggle:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        .filters-toggle.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        /* Filters Drawer Styles */
        .filters-drawer {
            position: fixed;
            top: 64px;
            left: 0;
            right: 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 998;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            max-height: calc(100vh - 64px);
            overflow-y: auto;
        }

        .filters-drawer.open {
            transform: translateY(0);
        }

        .filters-drawer-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px 24px;
        }

        /* AI Drawer Styles */
        .ai-drawer {
            position: fixed;
            top: 64px;
            right: -1200px;
            width: 1160px;
            height: calc(100vh - 64px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            transition: right 0.3s ease;
            z-index: 999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ai-drawer.open {
            right: 0;
        }

        .ai-drawer-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            color: white;
            flex-shrink: 0;
        }

        .ai-drawer-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Main content with drawer */
        .main-content {
            transition: margin-right 0.3s ease;
            min-height: calc(100vh - 64px);
        }

        .main-content.drawer-open {
            margin-right: 1160px;
        }

        /* Welcome Interface Styles */
        .welcome-interface {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 164px);
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }

        .welcome-title {
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: 700;
            letter-spacing: 4px;
            color: #2d3748;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .welcome-subtitle {
            font-size: 1.2rem;
            color: #718096;
            margin-bottom: 60px;
            font-weight: 400;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 30px;
            max-width: 800px;
            width: 100%;
            margin-bottom: 40px;
        }

        .category-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: inherit;
        }

        .category-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            color: inherit;
            text-decoration: none;
        }

        .category-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .category-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #4a5568;
        }

        /* Search Bar in Welcome */
        .welcome-search {
            max-width: 600px;
            width: 100%;
            margin-bottom: 40px;
        }

        .welcome-search input {
            width: 100%;
            padding: 16px 20px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .welcome-search input:focus {
            border-color: #667eea;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .advanced-search-toggle {
            margin-top: 20px;
        }

        .advanced-search-toggle button {
            background: transparent;
            border: 1px solid #cbd5e0;
            color: #4a5568;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .advanced-search-toggle button:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: none;
            box-shadow: none;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .filters-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .filters-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }

        .filter-group.wide {
            flex: 1;
            min-width: 180px;
        }

        .filter-group.compact {
            flex: 0 0 auto;
            min-width: 140px;
        }

        .search-container {
            flex: 3;
            min-width: 300px;
        }

        .records-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 600px;
        }

        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .record-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
            transition: all 0.3s ease;
        }

        .record-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .record-type {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .record-block {
            color: #666;
            font-size: 0.9rem;
        }

        .record-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .record-content {
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .record-meta {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.8rem;
            color: #999;
        }

        .tags-container {
            margin-top: 10px;
        }

        .tag {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin: 2px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .tag:hover {
            background: #667eea;
            color: white;
        }

        /* Media content styling */
        .media-content {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .media-item {
            margin: 10px 0;
        }

        .media-item img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .media-item img:hover {
            transform: scale(1.02);
        }

        .media-item audio,
        .media-item video {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .media-item button {
            transition: all 0.2s;
        }

        .media-item button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .text-content {
            border: 1px solid #dee2e6;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .media-item label {
            color: #495057;
            font-size: 14px;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9rem;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #667eea;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .toggle-switch.active::after {
            left: 28px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .hidden {
            display: none;
        }

        .logged-in-user {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 16px;
            font-size: 14px;
        }

        .dynamic-fields {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            background: white;
        }

        .field-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .field-row > div {
            flex: 1;
        }

        .field-row button {
            margin: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .date-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-inputs input {
            width: 110px;
            min-width: 100px;
            flex: 0 0 auto;
        }

        .date-inputs span {
            color: #666;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .advanced-filters {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .toggle-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .load-more {
            text-align: center;
            margin: 20px 0;
        }

        .no-results {
            text-align: center;
            color: #999;
        }

        /* Multi-Tag Filter Styles */
        .multi-tag-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tag-mode-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-mode-selector label {
            font-size: 0.9rem;
            color: #666;
            margin: 0;
            font-weight: 500;
        }

        .tag-mode-selector select {
            padding: 4px 8px;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .tag-filters-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tag-filter-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tag-filter-select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .add-tag-btn, .remove-tag-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
        }

        .add-tag-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .remove-tag-btn {
            border-color: #dc3545;
            color: #dc3545;
        }

        .remove-tag-btn:hover {
            background: #dc3545;
            color: white;
            transform: translateY(-1px);
        }

        .tag-filter-row:first-child .remove-tag-btn {
            display: none; /* Hide remove button on first row */
        }

        /* Resolve hint styling */
        .resolve-hint {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px dashed #6c757d;
            color: #495057;
            text-align: center;
            padding: 20px;
            cursor: help;
        }

        .resolve-hint:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: none; /* Override hover transform */
        }

        /* Responsive Layout for Multi-Tag Filters */
        @media (max-width: 768px) {
            .filters-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .filter-group.compact,
            .filter-group.wide {
                min-width: 100%;
            }
            
            .date-inputs input {
                width: 120px;
            }
        }

        /* When many tag filters are present, optimize spacing */
        .tag-filters-container.has-many-tags {
            gap: 6px;
        }

        .tag-filters-container.has-many-tags .tag-filter-select {
            padding: 6px 10px;
            font-size: 13px;
        }

        .tag-filters-container.has-many-tags .add-tag-btn,
        .tag-filters-container.has-many-tags .remove-tag-btn {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }

        /* Master Audio Player */
        .master-audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .master-audio-player.visible {
            transform: translateY(0);
        }

        .audio-player-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .audio-info {
            flex: 1;
            min-width: 0;
        }

        .audio-title {
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .audio-meta {
            font-size: 12px;
            opacity: 0.8;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .audio-controls button:hover {
            background: rgba(255,255,255,0.3);
            transform: none;
            box-shadow: none;
        }

        .audio-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        .audio-progress-bar {
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .audio-time {
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .record-card .audio-play-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .record-card .audio-play-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .record-card .audio-play-btn.playing {
            background: #dc3545;
        }

        .record-card .audio-play-btn.playing:hover {
            background: #c82333;
        }

        .text-content-preview {
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .toggle-text-btn {
            background: #17a2b8;
            font-size: 12px;
            padding: 4px 8px;
        }

        .toggle-text-btn:hover {
            background: #138496;
        }

        .record-image {
            width: 100%;
            max-height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .record-image:hover {
            transform: scale(1.02);
        }

        /* Ensure body has padding for fixed audio player */
        body {
            margin-bottom: 80px;
        }

        /* AI Chat Integration Styles */
        .ai-chat-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 500px;
            max-height: 700px;
            overflow: hidden;
            contain: layout;
        }

        .chat-header {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 15px;
            flex-shrink: 0;
        }

        .chat-conversation {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            min-height: 250px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .chat-message .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .message-avatar {
            background: rgba(59, 130, 246, 0.8);
        }

        .chat-message.assistant .message-avatar {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-avatar {
            background: rgba(239, 68, 68, 0.8);
        }

        .message-content {
            flex: 1;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            position: relative;
        }

        .chat-message.user .message-content {
            background: rgba(59, 130, 246, 0.8);
            margin-left: auto;
        }

        .chat-message.assistant .message-content {
            background: rgba(34, 197, 94, 0.8);
        }

        .chat-message.system .message-content {
            background: rgba(239, 68, 68, 0.8);
            font-style: italic;
        }

        .message-text {
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.8;
        }

        .message-timestamp {
            font-size: 11px;
            opacity: 0.7;
        }

        .mic-btn {
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            padding: 16px 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 60px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .mic-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .mic-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .mic-btn.recording {
            background: rgba(239, 68, 68, 0.8);
            border-color: rgba(239, 68, 68, 1);
            animation: pulse 1.5s infinite;
        }

        .mic-btn.listening {
            background: rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 1);
            animation: pulse 2s infinite;
        }

        .mic-btn.transcribing {
            background: rgba(59, 130, 246, 0.8);
            border-color: rgba(59, 130, 246, 1);
            animation: spin 1s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .message-sources {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
        }

        .source-count {
            font-weight: bold;
        }

        .chat-input-container {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .chat-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 10px;
            position: relative;
            z-index: 10;
        }

        #ai-chat-input {
            flex: 1;
            padding: 16px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-height: 60px;
            resize: vertical;
            max-height: 200px;
            display: block !important;
            visibility: visible !important;
            font-family: inherit;
            line-height: 1.5;
        }

        #ai-chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #ai-chat-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }

        .chat-send-btn {
            padding: 16px 32px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(10px);
            min-height: 60px;
        }

        .chat-send-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-status {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            backdrop-filter: blur(10px);
            opacity: 0.9;
            font-size: 12px;
        }

        .chat-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            opacity: 0.8;
        }

        .chat-empty-state .emoji {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .chat-empty-state h3 {
            font-size: 18px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .chat-empty-state p {
            font-size: 14px;
            opacity: 0.8;
        }

        .ai-settings {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .ai-setting {
            flex: 1;
            min-width: 200px;
        }

        .ai-setting label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.9;
        }

        .ai-setting select {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .applied-filters {
            background: rgba(59, 130, 246, 0.15);
            border: 2px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .filter-chip {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 16px;
            margin: 4px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .conversation-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .conversation-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .conversation-message.user {
            background: rgba(59, 130, 246, 0.3);
            margin-left: 20px;
        }

        .conversation-message.assistant {
            background: rgba(34, 197, 94, 0.3);
            margin-right: 20px;
        }

        .conversation-message .timestamp {
            font-size: 11px;
            opacity: 0.7;
            display: block;
            margin-top: 4px;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots:after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Microphone icon styles */
        .microphone-icon {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
        }

        .pagination-info {
            text-align: center;
            color: #666;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        /* Dynamic Template Debugging Styles */
        .template-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
            color: #1976d2;
        }

        .field-type-indicator {
            background: #f3e5f5;
            color: #7b1fa2;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
        }

        .dref-resolved {
            border-left: 3px solid #4caf50;
            margin-left: 10px;
            padding-left: 10px;
            background: #f1f8e9;
            border-radius: 0 4px 4px 0;
        }

        /* ========================================================================
           MODERN MEDIA-FOCUSED CARD STYLES (YouTube/SoundCloud/Flickr Style)
           ======================================================================== */
        
        /* Media Preview Styles */
        .media-preview {
            position: relative;
            width: 100%;
            height: 200px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .media-preview:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .preview-image, .preview-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        .preview-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 48px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .audio-artwork {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .audio-icon {
            font-size: 48px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .audio-visualizer {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .audio-visualizer .bar {
            width: 4px;
            background: rgba(255,255,255,0.8);
            border-radius: 2px;
            animation: audio-bounce 1.5s infinite ease-in-out;
        }

        .audio-visualizer .bar:nth-child(1) { height: 20px; animation-delay: -0.32s; }
        .audio-visualizer .bar:nth-child(2) { height: 15px; animation-delay: -0.16s; }
        .audio-visualizer .bar:nth-child(3) { height: 25px; animation-delay: 0s; }
        .audio-visualizer .bar:nth-child(4) { height: 18px; animation-delay: -0.24s; }

        @keyframes audio-bounce {
            0%, 80%, 100% { transform: scaleY(0.6); opacity: 0.8; }
            40% { transform: scaleY(1); opacity: 1; }
        }

        .media-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }

        .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .video-preview:hover .play-overlay {
            opacity: 1;
        }

        .play-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .play-button:hover {
            transform: scale(1.1);
        }

        /* Record Content Styles */
        .record-content {
            padding: 0 5px;
        }

        .record-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.3;
            color: #2c3e50;
        }

        .record-description {
            color: #7f8c8d;
            font-size: 14px;
            line-height: 1.4;
            margin: 0 0 15px 0;
        }

        /* Media Control Styles */
        .media-controls, .article-controls, .web-controls {
            margin: 12px 0;
        }

        .play-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            font-size: 14px;
        }

        .play-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .play-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .play-btn.primary.playing {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.3);
        }

        .play-btn.secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .play-btn.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .article-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }

        .article-btn:hover {
            background: #e9ecef;
            border-color: #dee2e6;
            transform: translateY(-1px);
        }

        .web-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .web-btn:hover {
            background: #218838;
            transform: translateY(-1px);
            color: white;
        }

        .media-count {
            color: #6c757d;
            font-size: 12px;
            margin-left: 10px;
        }

        /* Record Footer Styles */
        .record-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid #e9ecef;
        }

        .show-structure-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #dee2e6;
            border-radius: 15px;
            color: #6c757d;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .show-structure-btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
            color: #495057;
        }

        .record-did {
            font-size: 10px;
            color: #adb5bd;
            font-family: monospace;
        }

        /* Record Structure (Collapsible Technical Details) */
        .record-structure {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .structure-header {
            padding: 12px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
        }

        .structure-header h4 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 14px;
        }

        /* Article Content Styles */
        .article-content {
            margin-top: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #fff;
            overflow: hidden;
        }

        .article-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .article-header h4 {
            margin: 0;
            color: #495057;
            font-size: 14px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .article-text {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap;
        }

        .article-error {
            padding: 15px;
            color: #dc3545;
            text-align: center;
        }

        /* Modal Styles */
        .video-modal, .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }

        .video-modal-content, .image-modal-content {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 90vh;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .video-modal-header, .image-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .video-modal-header h3, .image-modal-header h3 {
            margin: 0;
            color: #495057;
            font-size: 16px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Record Header Updates */
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .record-type {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .record-date {
            color: #6c757d;
            font-size: 12px;
        }

        /* Enhanced Tags */
        .tags-container {
            margin: 12px 0;
        }

        .tag-chip {
            display: inline-block;
            background: #e9ecef;
            color: #495057;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px 4px 2px 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag-chip:hover {
            background: #dee2e6;
            transform: translateY(-1px);
        }

        .field-debug {
            background: #fff3e0;
            border: 1px solid #ff9800;
            padding: 5px;
            margin: 2px 0;
            font-size: 10px;
            border-radius: 3px;
        }

        .unresolved-dref {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                height: auto;
                padding: 15px;
                gap: 15px;
            }
            
            .logo {
                font-size: 1.5rem;
                letter-spacing: 2px;
            }
            
            .logo-icon {
                width: 32px;
                height: 32px;
            }
            
            .nav-tabs {
                order: -1;
                justify-content: center;
                width: 100%;
            }
            
            .auth-section {
                justify-content: center;
                width: 100%;
            }
            
            /* Header Search Mobile */
            .header-search {
                flex: 1;
                margin: 0 10px;
                max-width: none;
            }
            
            /* AI Drawer Mobile */
            .ai-drawer {
                width: 100%;
                right: -100%;
                top: 120px;
                height: calc(100vh - 120px);
            }
            
            .main-content.drawer-open {
                margin-right: 0;
                transform: translateX(-100%);
            }
            
            /* Welcome Interface Mobile */
            .welcome-interface {
                padding: 20px 15px;
                min-height: calc(100vh - 120px);
            }
            
            .welcome-title {
                font-size: 2.5rem;
                letter-spacing: 2px;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
                margin-bottom: 40px;
            }
            
            .categories-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                max-width: 400px;
            }
            
            .category-item {
                padding: 15px 10px;
            }
            
            .category-icon {
                font-size: 2rem;
                margin-bottom: 8px;
            }
            
            .category-label {
                font-size: 0.8rem;
            }
            
            .welcome-search input {
                padding: 14px 18px;
                font-size: 16px;
            }
            
            /* Search Interface Mobile */
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group,
            .filter-group.wide,
            .search-container {
                min-width: auto;
                flex: none;
            }
            
            .records-grid {
                grid-template-columns: 1fr;
            }
            
            .field-row {
                flex-direction: column;
                gap: 5px;
            }
            
            .date-inputs {
                flex-direction: column;
            }
            
            .toggle-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            /* Mobile adjustments for AI drawer */
            .ai-drawer-header {
                padding: 15px;
            }
            
            .ai-settings {
                flex-direction: column;
                gap: 10px;
            }
            
            .ai-setting {
                display: block !important;
                margin-right: 0 !important;
            }
            
            .chat-input-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .chat-send-btn {
                width: 100%;
            }
            
            .message-content {
                max-width: 95%;
            }
        }

        /* Publishing Interface Styles */
        .publish-form {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .publish-form h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .publish-form .form-group {
            margin-bottom: 20px;
        }

        .publish-form .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .publish-form input,
        .publish-form textarea,
        .publish-form select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        .publish-form input:focus,
        .publish-form textarea:focus,
        .publish-form select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .publish-form textarea {
            resize: vertical;
            min-height: 120px;
            font-family: inherit;
            line-height: 1.5;
        }

        .publish-form small {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: none;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .media-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .media-section h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1rem;
        }

        .ingredient-row,
        .exercise-row {
            display: grid;
            gap: 10px;
            margin-bottom: 10px;
            align-items: end;
        }

        .ingredient-row {
            grid-template-columns: 80px 100px 1fr 40px;
        }

        .exercise-row {
            grid-template-columns: 1fr 80px 80px 80px 40px;
        }

        .ingredient-row input,
        .exercise-row input {
            margin-bottom: 0;
        }

        .ingredient-row button,
        .exercise-row button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid #dc3545;
            background: white;
            color: #dc3545;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ingredient-row button:hover,
        .exercise-row button:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }

        .publish-form input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            transform: scale(1.2);
        }

        .publish-form label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            font-weight: 500;
            cursor: pointer;
        }

        .publish-progress {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }

        .publish-progress h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .publish-form {
                margin: 0;
                padding: 15px;
                border-radius: 0;
            }

            .ingredient-row {
                grid-template-columns: 60px 80px 1fr 35px;
                gap: 8px;
            }

            .exercise-row {
                grid-template-columns: 1fr 60px 60px 60px 35px;
                gap: 8px;
            }

            .ingredient-row input,
            .exercise-row input {
                font-size: 13px;
                padding: 8px 10px;
            }

            .media-section {
                margin: 15px 0;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <img src="blue-alexandria-logo.png" alt="ALEXANDRIA" class="logo-icon">
                ΛLΞXΛNDRIΛ
            </div>
            
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="showWelcomeInterface()">Home</div>
                <div class="nav-tab" onclick="showSearchInterface()">Browse</div>
                <div class="nav-tab" onclick="showPublishTab()">Publish</div>
            </div>
            
            <div id="header-search" class="header-search hidden">
                <input type="text" id="header-search-input" placeholder="Search the archive..." onkeydown="handleHeaderSearch(event)">
                <button id="filters-toggle" class="filters-toggle" onclick="toggleFiltersDrawer()" title="Show filters">⋯</button>
            </div>
            
            <div class="auth-section">
                <button id="ai-drawer-toggle" class="ai-drawer-toggle" onclick="toggleAIDrawer()">
                    🤖 AI Assistant
                </button>
                <div id="user-info" class="hidden">
                    <span id="logged-in-display" class="logged-in-user"></span>
                    <button onclick="logout()" class="btn-secondary btn-small">Logout</button>
                </div>
                <div id="auth-buttons">
                    <button onclick="showAuthModal()" class="btn-small">Login / Register</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filters Drawer -->
    <div id="filters-drawer" class="filters-drawer">
        <div class="filters-drawer-content">
            <!-- This will contain the moved filters content -->
        </div>
    </div>

    <!-- AI Drawer -->
    <div id="ai-drawer" class="ai-drawer">
        <div class="ai-drawer-header">
            <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                <span>🤖</span> AI Assistant
            </h3>
            
            <div class="ai-settings" style="margin-top: 15px;">
                <div class="ai-setting" style="display: inline-block; margin-right: 15px;">
                    <label for="ai-model-select">AI Model</label>
                    <select id="ai-model-select">
                        <option value="llama3.2:3b">LLaMA 3.2 3B (Fast)</option>
                        <option value="mistral:latest">Mistral 7B (Balanced)</option>
                        <option value="llama2:latest">LLaMA 2 7B (Quality)</option>
                        <option value="tinyllama:latest">TinyLlama (Ultra Fast)</option>
                    </select>
                </div>
                <div class="ai-setting" style="display: inline-block;">
                    <label for="stt-language">Speech Language</label>
                    <select id="stt-language">
                        <option value="auto">Auto-detect</option>
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                    </select>
                </div>
            </div>

            <div id="applied-filters-display" class="applied-filters hidden" style="margin-top: 15px; background: rgba(59, 130, 246, 0.2); border: 2px solid rgba(59, 130, 246, 0.5); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <div style="margin-bottom: 8px; font-weight: bold; color: #1e40af; background: rgba(255, 255, 255, 0.8); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(30, 64, 175, 0.3);">🔍 AI Applied Filters:</div>
                <div id="filter-chips-container"></div>
                <div id="filter-rationale" style="margin-top: 8px; font-size: 12px; color: #374151; opacity: 0.9;"></div>
            </div>
        </div>
        
        <div class="ai-drawer-content">
            <div id="chat-conversation" class="chat-conversation">
                <div id="chat-empty-state" class="chat-empty-state">
                    <div class="emoji">💬</div>
                    <h3>Start a conversation</h3>
                    <p>Ask questions about your data and I'll help you find answers!</p>
                </div>
                <div id="chat-messages"></div>
            </div>

            <div class="chat-input-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div class="ai-status" id="ai-status" style="flex: 1; margin-bottom: 0; margin-right: 10px;">
                        <div id="ai-status-text">Ready to answer questions!</div>
                    </div>
                    <button onclick="clearConversation()" class="btn-secondary btn-small" style="background: #6b7280; border: 1px solid #9ca3af; color: white; margin: 0;">
                        Clear Chat
                    </button>
                </div>
                
                <div class="chat-input-row">
                    <button id="mic-btn" onclick="toggleRecording()" class="mic-btn" title="Click to record voice message">
                        🎤
                    </button>
                    <textarea id="ai-chat-input" placeholder="Ask a question about your data or click the microphone..." onkeydown="handleChatKeydown(event)" rows="1"></textarea>
                    <button id="ai-chat-send-btn" onclick="sendChatMessage()" class="chat-send-btn">
                        <span>Ask AI</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="main-content">
        <!-- Welcome Interface -->
        <div id="welcome-interface" class="welcome-interface">
            <h1 class="welcome-title">ΛLΞXΛNDRIΛ</h1>
            <p class="welcome-subtitle">A decentralized library of art, history, knowledge and memes.</p>
            
            <div class="welcome-search">
                <input type="text" id="welcome-search-input" placeholder="Search the archive..." onkeydown="handleWelcomeSearch(event)">
                <div class="advanced-search-toggle">
                    <button onclick="showAdvancedSearch()">Advanced Search</button>
                </div>
            </div>
            
            <div id="categories-grid" class="categories-grid">
                <!-- Categories will be populated dynamically from recordTypes -->
            </div>
        </div>

        <!-- Search Interface -->
        <div id="search-interface" class="container hidden">
            <!-- Filters Section (Enhanced Version) -->
            <div class="filters-section" style="position: relative; z-index: 1; background: white; border: 2px solid rgba(102, 126, 234, 0.1);">
                <!-- Hidden search input for backward compatibility -->
                <input type="hidden" id="voice-search-input" value="">
                
                <div class="filters-row">
                    <div class="filter-group">
                        <label for="voice-record-type-filter">Record Type</label>
                        <select id="voice-record-type-filter" onchange="applyVoiceFilters()">
                            <option value="">All Types</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-sort-by">Sort By</label>
                        <select id="voice-sort-by" onchange="applyVoiceFilters()">
                            <option value="inArweaveBlock:desc">Block (Newest)</option>
                            <option value="inArweaveBlock:asc">Block (Oldest)</option>
                            <option value="date:desc" selected>Date (Newest)</option>
                            <option value="date:asc">Date (Oldest)</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="voice-resolve-depth" title="Higher values resolve more linked records. Set to 1+ to see recipe images.">
                            Resolve Depth
                            <span style="opacity: 0.6; font-size: 0.8rem;">(?)</span>
                        </label>
                        <input type="number" id="voice-resolve-depth" value="2" min="0" max="5" onchange="applyVoiceFilters()" 
                               title="2 recommended for images. 0=fastest, 5=most complete">
                    </div>
                </div>
                
                <div class="filters-row">
                    <div class="filter-group compact">
                        <label>Date Range</label>
                        <div class="date-inputs">
                            <input type="date" id="voice-date-start" onchange="applyVoiceFilters()" placeholder="Start Date">
                            <span>to</span>
                            <input type="date" id="voice-date-end" onchange="applyVoiceFilters()" placeholder="End Date">
                        </div>
                    </div>
                    
                    <div class="filter-group wide">
                        <label for="multi-tag-container">Filter by Tags</label>
                        <div id="multi-tag-container" class="multi-tag-container">
                            <!-- Tag Match Mode Selector -->
                            <div class="tag-mode-selector">
                                <label for="tag-match-mode">Match:</label>
                                <select id="tag-match-mode" onchange="applyVoiceFilters()">
                                    <option value="OR">ANY tag (OR)</option>
                                    <option value="AND">ALL tags (AND)</option>
                                </select>
                            </div>
                            
                            <!-- Tag Filters Container -->
                            <div id="tag-filters-container" class="tag-filters-container">
                                <div class="tag-filter-row" data-tag-index="0">
                                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                                        <option value="">Select a tag...</option>
                                    </select>
                                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                                </div>
                            </div>
                            
                            <!-- Legacy single tag filter (hidden) for backward compatibility -->
                            <select id="voice-tag-filter" style="display: none;">
                                <option value="">All Tags</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="advanced-filters">
                    <div class="toggle-row">
                        <div class="toggle-group">
                            <label>Include Signatures:</label>
                            <div class="toggle-switch" id="voice-include-sigs-toggle" onclick="toggleVoiceSwitch('voice-include-sigs-toggle')"></div>
                        </div>
                        
                        <div class="toggle-group">
                            <label>Include Public Keys:</label>
                            <div class="toggle-switch" id="voice-include-pubkeys-toggle" onclick="toggleVoiceSwitch('voice-include-pubkeys-toggle')"></div>
                        </div>
                        

                        
                        <button onclick="clearVoiceFilters()" class="btn-secondary btn-small">Clear Filters</button>
                        <button onclick="applyVoiceFilters()" class="btn-small">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Records Display (Enhanced Version) -->
            <div class="records-container">
                <div id="voice-records-header">
                    <h2>OIP Records</h2>
                    <div id="voice-pagination-info" class="pagination-info"></div>
                </div>
                
                <div id="voice-loading-indicator" class="loading">
                    <div class="spinner"></div>
                    Loading records...
                </div>
                
                <div id="voice-records-grid" class="records-grid hidden"></div>
                
                <div id="voice-no-results" class="no-results hidden">
                    No records found matching your criteria.
                </div>
                
                <div id="voice-load-more-container" class="load-more hidden">
                    <button onclick="loadMoreVoiceRecords()" id="voice-load-more-btn">Load More Records</button>
                </div>
            </div>
        </div>
    </div>

        <!-- Publish Tab Content -->
        <div id="publish-tab" class="container hidden">
            <div class="section">
                <h2>Publishing Platform</h2>
                <p>Please log in to access publishing features.</p>
                
                <div id="publishing-content" class="hidden">
                    <div class="filters-row">
                        <button onclick="showCreatorRegistration()">Register Creator</button>
                        <button onclick="showTemplateCreation()">Create Template</button>
                        <button onclick="showRecordPublishing()">Publish Record</button>
                    </div>
                </div>
            </div>

            <!-- Creator Registration -->
            <div id="creator-section" class="section hidden">
                <h2>Creator Registration</h2>
                <div class="form-group">
                    <label for="creator-name">Creator Name:</label>
                    <input type="text" id="creator-name" required>
                </div>
                <div class="form-group">
                    <label for="creator-description">Description:</label>
                    <textarea id="creator-description"></textarea>
                </div>
                <div class="form-group">
                    <label for="creator-email">Email:</label>
                    <input type="email" id="creator-email">
                </div>
                <div class="form-group">
                    <label for="creator-website">Website:</label>
                    <input type="url" id="creator-website">
                </div>
                <button onclick="registerCreator()">Register Creator</button>
                <div id="creator-status" class="error-message hidden"></div>
                <div id="creator-success" class="success-message hidden"></div>
            </div>

            <!-- Template Creation -->
            <div id="template-section" class="section hidden">
                <h2>Template Creation</h2>
                <div class="form-group">
                    <label for="template-name">Template Name:</label>
                    <input type="text" id="template-name" required>
                </div>
                <div class="form-group">
                    <label for="template-recordtype">Record Type:</label>
                    <input type="text" id="template-recordtype" required placeholder="e.g., post, recipe, workout">
                </div>
                <div class="dynamic-fields">
                    <h3>Template Fields</h3>
                    <div id="template-fields">
                        <div class="field-row">
                            <div>
                                <label>Field Name:</label>
                                <input type="text" class="field-name" placeholder="e.g., title, content">
                            </div>
                            <div>
                                <label>Field Type:</label>
                                <select class="field-type">
                                    <option value="string">String</option>
                                    <option value="number">Number</option>
                                    <option value="boolean">Boolean</option>
                                    <option value="enum">Enum</option>
                                    <option value="array">Array</option>
                                </select>
                            </div>
                            <div>
                                <button type="button" onclick="removeField(this)">Remove</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" onclick="addTemplateField()">Add Field</button>
                </div>
                <button onclick="createTemplate()">Create Template</button>
                <div id="template-status" class="error-message hidden"></div>
                <div id="template-success" class="success-message hidden"></div>
            </div>

            <!-- Record Publishing -->
            <div id="record-section" class="section hidden">
                <h2>Publish Record</h2>
                
                <!-- Record Type Selection -->
                <div class="form-group">
                    <label for="publish-record-type">Record Type:</label>
                    <select id="publish-record-type" onchange="loadPublishInterface()">
                        <option value="">Select Record Type</option>
                        <option value="post">Post / Article</option>
                        <option value="video">Video</option>
                        <option value="audio">Audio / Podcast</option>
                        <option value="image">Image</option>
                        <option value="recipe">Recipe</option>
                        <option value="workout">Workout</option>
                        <option value="text">Text Document</option>
                    </select>
                </div>

                <!-- Dynamic Publishing Interface -->
                <div id="publish-interface" class="dynamic-fields">
                    <div class="loading">Select a record type to see publishing interface</div>
                </div>
                
                <div id="publish-status" class="error-message hidden"></div>
                <div id="publish-success" class="success-message hidden"></div>
            </div>
        </div>
    </div>

    <!-- Authentication Modal -->
    <div id="auth-modal" class="modal hidden">
        <div class="modal-content">
            <div id="login-form">
                <h2>Login</h2>
                <div class="form-group">
                    <label for="email">Email:</label>
                    <input type="email" id="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password:</label>
                    <input type="password" id="password" required>
                </div>
                <button onclick="login()">Login</button>
                <button onclick="showRegisterForm()" class="btn-secondary">Register Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="register-form" class="hidden">
                <h2>Register</h2>
                <div class="form-group">
                    <label for="register-email">Email:</label>
                    <input type="email" id="register-email" required>
                </div>
                <div class="form-group">
                    <label for="register-password">Password:</label>
                    <input type="password" id="register-password" required>
                </div>
                <button onclick="register()">Register</button>
                <button onclick="showLoginForm()" class="btn-secondary">Login Instead</button>
                <button onclick="hideAuthModal()" class="btn-secondary">Cancel</button>
            </div>
            
            <div id="auth-status" class="error-message hidden"></div>
            <div id="auth-success" class="success-message hidden"></div>
        </div>
    </div>

    <!-- Master Audio Player -->
    <div id="master-audio-player" class="master-audio-player">
        <div class="audio-player-content">
            <div class="audio-info">
                <div class="audio-title" id="audio-title">No audio selected</div>
                <div class="audio-meta" id="audio-meta">Select an audio file to play</div>
            </div>
            
            <div class="audio-controls">
                <button onclick="toggleAudioPlayback()" id="master-play-btn">▶️</button>
                <button onclick="stopAudio()">⏹️</button>
                <div class="audio-progress" onclick="seekAudio(event)">
                    <div class="audio-progress-bar" id="audio-progress-bar"></div>
                </div>
                <div class="audio-time" id="audio-time">0:00 / 0:00</div>
                <button onclick="closeMasterPlayer()">✕</button>
            </div>
        </div>
        
        <audio id="master-audio" style="display: none;" 
               ontimeupdate="updateAudioProgress()" 
               onended="onAudioEnded()"
               onloadedmetadata="onAudioLoaded()">
        </audio>
    </div>

    <script>
        // State management
        let authToken = localStorage.getItem('oip-auth-token');
        let currentUser = localStorage.getItem('oip-user-email');
        let templates = {};
        let defaultTemplates = {};
        // Enhanced template system variables
        let allTemplates = {}; // Maps template names and TxIds to template objects
        let templateFieldMap = {}; // Maps template names and TxIds to field definitions
        let showDebugInfo = false; // Controls debug information display
        let recordTypes = [];
        let currentRecords = [];
        let currentPage = 1;
        let isLoading = false;
        let hasMoreRecords = true;
        let currentFilters = {
            search: '',
            recordType: '',
            sortBy: 'date:desc',
            resolveDepth: 2,
            dateStart: '',
            dateEnd: '',
            tag: '',
            includeSigs: false,
            includePubKeys: false
        };
        let availableTags = [];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        async function initializeApp() {
            console.log('[App] Starting enhanced initialization with dynamic templates...');
            
            // Always load templates first for dynamic rendering
            await loadTemplates();
            
            // Setup authentication state
            if (authToken && currentUser) {
                showLoggedInState();
            }
            
            // Load actual record types from the index
            await loadActualRecordTypes();
            
            // Force hide the old browse tab and ensure it stays hidden
            forcehideBrowseTab();
            
            // Show welcome interface by default
            showWelcomeInterface();
            
            console.log('[App] Initialized with enhanced dynamic template system');
            
            // Set up periodic checks to ensure interface stays clean
            setInterval(() => {
                forcehideBrowseTab();
                
                // Quick check that chat input is still visible
                const chatInput = document.getElementById('ai-chat-input');
                if (chatInput && (chatInput.offsetHeight === 0 || chatInput.style.display === 'none')) {
                    console.log('[App] Detected hidden chat input, restoring...');
                    ensureChatInputReady();
                }
            }, 2000); // Check every 2 seconds
        }

        // Load actual record types from the index
        async function loadActualRecordTypes() {
            try {
                console.log('[App] Loading actual record types from index...');
                const response = await fetch('/api/records/recordTypes');
                const data = await response.json();
                
                if (response.ok && data.recordTypes) {
                    console.log('[App] Loaded record types:', data.recordTypes);
                    
                    // Store the actual record types with counts
                    recordTypes = data.recordTypes.map(rt => rt.recordType).sort();
                    
                    // Populate all record type dropdowns
                    populateAllRecordTypeDropdowns(data.recordTypes);
                    
                    console.log('[App] Populated record type dropdowns with', recordTypes.length, 'types');
                } else {
                    console.error('[App] Failed to load record types:', data.error || 'Unknown error');
                    // Fallback to basic types if API fails
                    recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                    populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
                }
            } catch (error) {
                console.error('[App] Error loading record types:', error);
                // Fallback to basic types if API fails
                recordTypes = ['post', 'video', 'image', 'recipe', 'workout'];
                populateAllRecordTypeDropdowns(recordTypes.map(type => ({ recordType: type, count: 0 })));
            }
        }

        // Populate all record type dropdowns with actual data
        function populateAllRecordTypeDropdowns(recordTypesData) {
            // Voice browse tab dropdown
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    voiceSelect.appendChild(option);
                });
                console.log('[App] Populated voice record type filter with', recordTypesData.length, 'types');
            }
            
            // Publishing record type dropdown
            const publishSelect = document.getElementById('record-type');
            if (publishSelect) {
                // Keep the first option as "Select Record Type"
                const firstOption = publishSelect.querySelector('option[value=""]');
                publishSelect.innerHTML = '';
                if (firstOption) {
                    publishSelect.appendChild(firstOption);
                } else {
                    publishSelect.innerHTML = '<option value="">Select Record Type</option>';
                }
                
                // Add actual record types
                recordTypesData.forEach(rt => {
                    const option = document.createElement('option');
                    option.value = rt.recordType;
                    option.textContent = `${rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1)} (${rt.count})`;
                    publishSelect.appendChild(option);
                });
                console.log('[App] Populated publishing record type filter with', recordTypesData.length, 'types');
            }
            
            // Populate categories grid
            populateCategoriesGrid(recordTypesData);
        }
        
        // Populate the categories grid dynamically from recordTypes
        function populateCategoriesGrid(recordTypesData) {
            const grid = document.getElementById('categories-grid');
            if (!grid) return;
            
            // Icon mapping for different record types
            const iconMap = {
                'post': '📝',
                'video': '📹', 
                'image': '📷',
                'audio': '🎵',
                'text': '📄',
                'recipe': '🍳',
                'workout': '💪',
                'podcast': '🎙️',
                'movie': '🎬',
                'music': '🎵',
                'book': '📚',
                'document': '📄',
                'software': '💻',
                'archive': '🗃️',
                'thing': '🏛️'
            };
            
            grid.innerHTML = '';
            
            // If no recordTypes data, show default categories
            if (!recordTypesData || recordTypesData.length === 0) {
                const defaultTypes = [
                    { recordType: 'post', count: 0 },
                    { recordType: 'video', count: 0 },
                    { recordType: 'image', count: 0 },
                    { recordType: 'audio', count: 0 },
                    { recordType: 'recipe', count: 0 },
                    { recordType: 'text', count: 0 }
                ];
                recordTypesData = defaultTypes;
            }
            
            // Sort by count (descending) and take top categories
            const sortedTypes = recordTypesData
                .sort((a, b) => b.count - a.count)
                .slice(0, 12); // Limit to 12 categories max
            
            sortedTypes.forEach(rt => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category-item';
                categoryDiv.onclick = () => searchByRecordType(rt.recordType);
                
                const icon = iconMap[rt.recordType] || '📋';
                const label = rt.recordType.charAt(0).toUpperCase() + rt.recordType.slice(1);
                
                categoryDiv.innerHTML = `
                    <div class="category-icon">${icon}</div>
                    <div class="category-label">${label}</div>
                `;
                
                grid.appendChild(categoryDiv);
            });
            
            console.log('[App] Populated categories grid with', sortedTypes.length, 'categories');
        }

        // Legacy function - now redirects to new implementation
        async function loadRecordTypes() {
            console.log('[App] Legacy loadRecordTypes called - redirecting to loadActualRecordTypes');
            await loadActualRecordTypes();
        }

        // Legacy function - now uses new implementation
        function populateRecordTypeFilter() {
            console.log('[App] Legacy populateRecordTypeFilter called - record types already populated');
        }

        // Legacy function - now uses new implementation
        function populateVoiceRecordTypeFilter(recordTypes) {
            console.log('[App] Legacy populateVoiceRecordTypeFilter called - record types already populated');
        }

        // Force hide the old browse tab completely
        function forcehideBrowseTab() {
            const browseTab = document.getElementById('browse-tab');
            if (browseTab) {
                browseTab.style.display = 'none !important';
                browseTab.style.visibility = 'hidden !important';
                browseTab.style.height = '0 !important';
                browseTab.style.overflow = 'hidden !important';
                browseTab.style.position = 'absolute !important';
                browseTab.style.top = '-9999px !important';
                browseTab.classList.add('hidden');
                console.log('[App] Old browse tab forcefully hidden');
            }
        }

        // Navigation functions (Updated for new interface)
        function showWelcomeInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[0].classList.add('active');
            
            document.getElementById('welcome-interface').classList.remove('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        function showSearchInterface() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[1].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.remove('hidden');
            document.getElementById('publish-tab').classList.add('hidden');
            
            // Show header search when on browse tab
            showHeaderSearch();
            
            // Sync search values
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                headerSearch.value = hiddenSearch.value;
            }
            
            // Initialize voice features when search interface is shown
            initializeVoiceFeatures();
        }

        function showPublishTab() {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab')[2].classList.add('active');
            
            document.getElementById('welcome-interface').classList.add('hidden');
            document.getElementById('search-interface').classList.add('hidden');
            document.getElementById('publish-tab').classList.remove('hidden');
            
            // Hide header search when not on browse tab
            hideHeaderSearch();
        }

        // AI Drawer Functions
        function toggleAIDrawer() {
            const drawer = document.getElementById('ai-drawer');
            const mainContent = document.getElementById('main-content');
            const toggle = document.getElementById('ai-drawer-toggle');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                mainContent.classList.remove('drawer-open');
                toggle.classList.remove('active');
            } else {
                drawer.classList.add('open');
                mainContent.classList.add('drawer-open');
                toggle.classList.add('active');
                
                // Initialize AI features when drawer is first opened
                if (!chatState.isInitialized) {
                    initializeVoiceFeatures();
                }
            }
        }

        // Welcome Interface Functions
        function handleWelcomeSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                if (searchTerm) {
                    // Set the search term in both search inputs
                    document.getElementById('voice-search-input').value = searchTerm;
                    document.getElementById('header-search-input').value = searchTerm;
                    // Switch to search interface
                    showSearchInterface();
                    // Apply the search
                    applyVoiceFilters();
                }
            }
        }

        function searchByRecordType(recordType) {
            // Clear current search field (don't put record type name in search)
            document.getElementById('voice-search-input').value = '';
            
            // Set the record type filter
            document.getElementById('voice-record-type-filter').value = recordType;
            
            // Clear other filters to get clean results for this record type
            document.getElementById('voice-sort-by').value = 'inArweaveBlock:desc';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            clearAllTagFilters();
            
            // Switch to search interface
            showSearchInterface();
            
            // Apply the search
            setTimeout(() => {
                applyVoiceFilters();
            }, 100);
        }
        
        // Legacy function for backward compatibility
        function searchByCategory(category) {
            searchByRecordType(category);
        }

        function showAdvancedSearch() {
            showSearchInterface();
        }

        // Legacy function for compatibility
        function showVoiceBrowseTab() {
            showSearchInterface();
        }

        // Authentication Modal functions
        function showAuthModal() {
            document.getElementById('auth-modal').classList.remove('hidden');
            showLoginForm();
        }

        function hideAuthModal() {
            document.getElementById('auth-modal').classList.add('hidden');
            clearAuthForms();
        }

        function showLoginForm() {
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('register-form').classList.add('hidden');
        }

        function showRegisterForm() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('register-form').classList.remove('hidden');
        }

        function clearAuthForms() {
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
            document.getElementById('register-email').value = '';
            document.getElementById('register-password').value = '';
            hideElement('auth-status');
            hideElement('auth-success');
        }

        // Authentication functions
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Login successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Login failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function register() {
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!email || !password) {
                showMessage('auth-status', 'Please fill in all fields', 'error');
                return;
            }

            try {
                const response = await fetch('/api/user/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = email;
                    localStorage.setItem('oip-auth-token', authToken);
                    localStorage.setItem('oip-user-email', currentUser);
                    showLoggedInState();
                    await loadTemplates();
                    showMessage('auth-success', 'Registration successful!', 'success');
                    setTimeout(hideAuthModal, 1500);
                } else {
                    showMessage('auth-status', data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                showMessage('auth-status', 'Network error: ' + error.message, 'error');
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            localStorage.removeItem('oip-auth-token');
            localStorage.removeItem('oip-user-email');
            showLoginState();
        }

        function showLoggedInState() {
            document.getElementById('user-info').classList.remove('hidden');
            document.getElementById('auth-buttons').classList.add('hidden');
            document.getElementById('publishing-content').classList.remove('hidden');
            document.getElementById('logged-in-display').textContent = currentUser;
        }

        function showLoginState() {
            document.getElementById('user-info').classList.add('hidden');
            document.getElementById('auth-buttons').classList.remove('hidden');
            document.getElementById('publishing-content').classList.add('hidden');
            hideAllPublishingSections();
        }

        // Core browsing functionality (DISABLED - redirected to voice version)
        async function loadRecords(reset = false) {
            console.log('[App] loadRecords called but redirected to loadVoiceRecords');
            // Redirect to the voice version instead
            return await loadVoiceRecords(reset);
        }

        // OLD loadRecords function (disabled)
        async function loadRecordsOLD(reset = false) {
            if (isLoading) return;
            
            isLoading = true;
            const loadingEl = document.getElementById('loading-indicator');
            const recordsGrid = document.getElementById('records-grid');
            const noResults = document.getElementById('no-results');
            
            if (reset) {
                currentPage = 1;
                currentRecords = [];
                recordsGrid.innerHTML = '';
                loadingEl.classList.remove('hidden');
                recordsGrid.classList.add('hidden');
                noResults.classList.add('hidden');
            }

            try {
                const params = buildApiParams();
                const response = await fetch(`https://api.oip.onl/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    displayRecords(data.records, !reset);
                    updatePaginationInfo(data);
                    
                    // Update tags if available
                    if (data.tagSummary) {
                        updateTagFilter(data.tagSummary);
                    }
                    
                    hasMoreRecords = data.records.length === 12; // Check if we got a full page
                } else {
                    if (reset) {
                        showNoResults();
                    }
                }
                
            } catch (error) {
                console.error('Error loading records:', error);
                showMessage('records-header', 'Error loading records: ' + error.message, 'error');
            } finally {
                isLoading = false;
                loadingEl.classList.add('hidden');
                updateLoadMoreButton();
            }
        }

        function buildApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            if (currentFilters.tag) {
                params.append('tags', currentFilters.tag);
            }

            return params.toString();
        }

        // Display and utility functions
        function displayRecords(records, append = false) {
            const grid = document.getElementById('records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = currentRecords.length - records.length;
            records.forEach((record, index) => {
                const card = createRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
        }

        // Media rendering functions (excluding images and audio which are handled separately)
        function renderOtherMediaContent(record, recordType, specificData) {
            let mediaHtml = '';
            
            // Handle direct media records (video, text only - images and audio handled separately)
            if (['video', 'text'].includes(recordType)) {
                mediaHtml += renderDirectMedia(specificData, recordType);
            }
            
            // Handle post records with embedded media (excluding featured image and audio)
            if (recordType === 'post' && specificData) {
                mediaHtml += renderPostVideoAndText(specificData);
            }
            
            // Handle recipe and workout records with media in ingredients/exercises
            if (['recipe', 'workout'].includes(recordType) && specificData) {
                mediaHtml += renderRecipeWorkoutNonAudioMedia(specificData, recordType);
            }
            
            return mediaHtml ? `<div class="media-content">${mediaHtml}</div>` : '';
        }

        function renderPostVideoAndText(postData) {
            let html = '';
            
            // Article text (dref resolved) - but not if it's already shown in the text toggle
            if (postData.articleText?.data?.text?.webUrl && !postData.articleText) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }

        function renderRecipeWorkoutNonAudioMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media (excluding audio/images)
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has video or text media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        function renderDirectMedia(data, type) {
            if (!data || !data.webUrl) return '';
            
            const webUrl = data.webUrl;
            const contentType = data.contentType || '';
            
            switch (type) {
                case 'image':
                    return `<div class="media-item">
                        <img src="${webUrl}" alt="Image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <audio controls style="width: 100%; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <video controls style="width: 100%; max-height: 300px; margin: 10px 0;">
                            <source src="${webUrl}" type="${contentType}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <div class="text-preview" style="margin: 10px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }
        
        function renderPostMedia(postData) {
            let html = '';
            
            // Main article web URL (external link) - this should open in new tab
            if (postData.webUrl) {
                html += `<div class="media-item">
                    <a href="${postData.webUrl}" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Read Original Article
                    </a>
                </div>`;
            }
            
            // Article text (dref resolved)
            if (postData.articleText?.data?.text?.webUrl) {
                html += renderDirectMedia(postData.articleText.data.text, 'text');
            }
            
            // Featured image (dref resolved)
            if (postData.featuredImage?.data?.image?.webUrl) {
                html += renderDirectMedia(postData.featuredImage.data.image, 'image');
            }
            
            // Audio items array
            if (postData.audioItems && Array.isArray(postData.audioItems)) {
                postData.audioItems.forEach((audioItem, index) => {
                    if (audioItem?.data?.audio?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Audio ${index + 1}:</label>
                            ${renderDirectMedia(audioItem.data.audio, 'audio')}
                        </div>`;
                    }
                });
            }
            
            // Video items array
            if (postData.videoItems && Array.isArray(postData.videoItems)) {
                postData.videoItems.forEach((videoItem, index) => {
                    if (videoItem?.data?.video?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Video ${index + 1}:</label>
                            ${renderDirectMedia(videoItem.data.video, 'video')}
                        </div>`;
                    }
                });
            }
            
            // Image items array
            if (postData.imageItems && Array.isArray(postData.imageItems)) {
                postData.imageItems.forEach((imageItem, index) => {
                    if (imageItem?.data?.image?.webUrl) {
                        html += `<div class="media-item">
                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">Image ${index + 1}:</label>
                            ${renderDirectMedia(imageItem.data.image, 'image')}
                        </div>`;
                    }
                });
            }
            
            return html;
        }
        
        function renderRecipeWorkoutMedia(data, type) {
            let html = '';
            
            // Handle ingredient/exercise references that might contain media
            const items = type === 'recipe' ? data.ingredient : data.exercise;
            if (items && Array.isArray(items)) {
                items.forEach((item, index) => {
                    if (item?.data) {
                        // Check if the referenced item has media
                        Object.keys(item.data).forEach(key => {
                            if (key !== 'basic') {
                                const itemData = item.data[key];
                                if (itemData?.webUrl) {
                                    const itemType = key;
                                    if (['image', 'audio', 'video', 'text'].includes(itemType)) {
                                        html += `<div class="media-item">
                                            <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                                                ${type === 'recipe' ? 'Ingredient' : 'Exercise'} ${index + 1} ${itemType}:
                                            </label>
                                            ${renderDirectMedia(itemData, itemType)}
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            return html;
        }
        
        // Load text content dynamically
        async function loadTextContent(url, button) {
            const contentDiv = button.nextElementSibling;
            
            if (contentDiv.style.display === 'none') {
                try {
                    button.textContent = 'Loading...';
                    button.disabled = true;
                    
                    const response = await fetch(url);
                    const text = await response.text();
                    
                    contentDiv.innerHTML = `
                        <div style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 14px;">
                            ${escapeHtml(text)}
                        </div>
                        <button onclick="this.parentElement.style.display='none'; this.parentElement.previousElementSibling.textContent='📄 View Text Content'; this.parentElement.previousElementSibling.disabled=false;" 
                                style="margin-top: 10px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Hide
                        </button>
                    `;
                    contentDiv.style.display = 'block';
                    button.textContent = '📄 Text Loaded';
                } catch (error) {
                    contentDiv.innerHTML = `<div style="color: #dc3545;">Error loading text content: ${error.message}</div>`;
                    contentDiv.style.display = 'block';
                    button.textContent = '❌ Failed to Load';
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Truncate text to specified length with ellipsis
         */
        function truncateText(text, maxLength) {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength).trim() + '...';
        }

        /**
         * Filter records by tag (called when clicking tag chips)
         */
        function filterByTag(tag) {
            document.getElementById('voice-search-input').value = tag;
            applyVoiceFilters();
        }

        // ====== ENHANCED TEMPLATE SYSTEM TEST FUNCTIONS ======
        
        /**
         * Test function to verify dynamic template system is working
         */
        function testTemplateSystem() {
            console.log('[Test] Testing Enhanced Dynamic Template System');
            console.log('[Test] Templates loaded:', Object.keys(allTemplates).length / 2);
            console.log('[Test] Field mappings available:', Object.keys(templateFieldMap).length / 2);
            console.log('[Test] Debug mode:', showDebugInfo);
            console.log('[Test] Sample template field mapping:', templateFieldMap['post'] || 'No post template found');
            
            if (currentRecords.length > 0) {
                const sampleRecord = currentRecords[0];
                const templatesUsed = analyzeRecordTemplates(sampleRecord);
                console.log('[Test] Sample record uses templates:', templatesUsed);
            }
            
            console.log('[Test] Enhanced template system is active!');
        }

        // Make test function available globally for console testing
        window.testTemplateSystem = testTemplateSystem;

        // Header Search and Filters Drawer Functions
        function handleHeaderSearch(event) {
            if (event.key === 'Enter') {
                const searchTerm = event.target.value.trim();
                // Update the hidden search input
                document.getElementById('voice-search-input').value = searchTerm;
                // Switch to browse interface and apply filters
                showSearchInterface();
                applyVoiceFilters();
            }
        }

        function toggleFiltersDrawer() {
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            const filtersSection = document.querySelector('.filters-section');
            
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                document.getElementById('search-interface').appendChild(filtersSection);
            } else {
                drawer.classList.add('open');
                toggle.classList.add('active');
                // Move filters to drawer
                document.querySelector('.filters-drawer-content').appendChild(filtersSection);
            }
        }

        function showHeaderSearch() {
            document.getElementById('header-search').classList.remove('hidden');
        }

        function hideHeaderSearch() {
            document.getElementById('header-search').classList.add('hidden');
            // Close filters drawer when hiding search
            const drawer = document.getElementById('filters-drawer');
            const toggle = document.getElementById('filters-toggle');
            if (drawer.classList.contains('open')) {
                drawer.classList.remove('open');
                toggle.classList.remove('active');
                // Move filters back to main interface
                const filtersSection = document.querySelector('.filters-section');
                document.getElementById('search-interface').appendChild(filtersSection);
            }
        }

        // ========================================================================
        // MODERN MEDIA-FOCUSED RECORD CARDS (YouTube/SoundCloud/Flickr Style)
        // ========================================================================
        
        /**
         * Create a modern, media-focused record card with collapsible technical details
         */
        function createRecordCard(record, recordIndex) {
            const card = document.createElement('div');
            card.className = 'record-card';
            
            const recordType = record.oip?.recordType || 'unknown';
            const basicData = record.data?.basic || {};
            const templatesUsed = analyzeRecordTemplates(record);
            
            // Extract media and content for modern display
            const mediaContent = extractMediaContent(record);
            const dateDisplay = basicData.dateReadable || formatDate(basicData.date) || 'Unknown Date';
            
            // Build modern media card
            card.innerHTML = `
                <div class="record-header">
                    <div class="record-type">${recordType}</div>
                    <div class="record-date">${dateDisplay}</div>
                </div>
                
                ${renderMediaPreview(mediaContent, recordIndex)}
                
                <div class="record-content">
                    <h3 class="record-title">${basicData.name || 'Unnamed Record'}</h3>
                    ${basicData.description ? `<p class="record-description">${truncateText(basicData.description, 150)}</p>` : ''}
                    
                    ${renderMediaControls(mediaContent, record, recordIndex)}
                    ${renderArticleTextButton(mediaContent, recordIndex)}
                    ${renderWebUrlButton(mediaContent)}
                </div>
                
                ${createTagsDisplay(basicData.tagItems)}
                
                <div class="record-footer">
                    <button class="show-structure-btn" onclick="toggleRecordStructure(${recordIndex})" title="Show technical record structure">
                        <span class="structure-icon">🔧</span> Show Record Structure
                    </button>
                    <div class="record-did">DID: ${truncateText(record.oip?.didTx || 'Unknown', 20)}</div>
                </div>
                
                <div id="structure-${recordIndex}" class="record-structure hidden">
                    <div class="structure-header">
                        <h4>🔧 Technical Record Structure</h4>
                        <div class="template-info">
                            <strong>Templates Used:</strong> ${templatesUsed.join(', ')}<br>
                            <strong>Record Type:</strong> ${recordType}<br>
                            <strong>Resolve Depth:</strong> ${currentFilters.resolveDepth} 
                            ${mediaContent.unresolvedImageDref ? '<br><span style="color: #dc3545;">⚠️ Images require resolve depth ≥ 1</span>' : ''}
                        </div>
                    </div>
                    ${renderAllTemplateData(record, templatesUsed)}
                </div>
            `;
            
            return card;
        }

        /**
         * Extract all media content from a record for modern display
         */
        function extractMediaContent(record) {
            const content = {
                featuredImage: null,
                audioItems: [],
                videoItems: [],
                articleText: null,
                webUrl: null
            };
            
            const recordType = record.oip?.recordType || 'unknown';
            const recordName = record.data?.basic?.name || 'Unnamed';
            
            // Extract from all data sections
            if (record.data) {
                Object.keys(record.data).forEach(sectionName => {
                    if (sectionName === 'basic') return;
                    
                    const section = record.data[sectionName];
                    extractMediaFromSection(section, content, sectionName, record);
                });
            }
            
            // Fallback: If no featured image found, search more aggressively
            if (!content.featuredImage && record.data) {
                console.log(`[Media Detection] No image found in primary extraction for ${recordType}: "${recordName}". Trying fallback search...`);
                const fallbackResult = findFirstImageInRecord(record);
                
                if (fallbackResult) {
                    if (fallbackResult.type === 'unresolved_dref') {
                        console.log(`[Media Detection] ⚠️ Found unresolved image dref for "${recordName}". Increase resolve depth to see images.`);
                        content.unresolvedImageDref = fallbackResult.dref;
                    } else {
                        content.featuredImage = fallbackResult;
                        console.log(`[Media Detection] ✅ Fallback found image for "${recordName}": ${content.featuredImage.url}`);
                    }
                } else {
                    console.log(`[Media Detection] ❌ No image found for "${recordName}" even after fallback search`);
                }
            } else if (content.featuredImage) {
                console.log(`[Media Detection] ✅ Primary extraction found image for "${recordName}": ${content.featuredImage.url}`);
            }
            
            return content;
        }

        /**
         * Aggressively search for any image URL in a record (fallback method)
         */
        function findFirstImageInRecord(record) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const basicData = record.data?.basic || {};
            
            // Priority order for field names (most likely to be main images first)
            const priorityFields = ['image', 'photo', 'picture', 'thumbnail', 'featured', 'cover', 'avatar', 'img', 'imageurl', 'photourl'];
            
            // First pass: Look for priority fields
            for (const priorityField of priorityFields) {
                const result = searchForImageInSection(record.data, priorityField);
                if (result) {
                    console.log(`[Media Detection] Found priority image in field containing "${priorityField}": ${result}`);
                    return {
                        url: result,
                        title: basicData.name || 'Image',
                        contentType: 'image/jpeg'
                    };
                }
            }
            
            // Second pass: Search all fields recursively
            const anyImageUrl = searchForImageUrl(record.data);
            if (anyImageUrl) {
                console.log(`[Media Detection] Found image URL in fallback search: ${anyImageUrl}`);
                return {
                    url: anyImageUrl,
                    title: basicData.name || 'Image',
                    contentType: 'image/jpeg'
                };
            }
            
            // Third pass: Look for unresolved image drefs
            const unresolvedImageDref = searchForUnresolvedImageDref(record.data);
            if (unresolvedImageDref) {
                console.log(`[Media Detection] Found unresolved image dref: ${unresolvedImageDref}`);
                return {
                    type: 'unresolved_dref',
                    dref: unresolvedImageDref
                };
            }
            
            return null;
            
            // Helper function to search for images in fields with priority names
            function searchForImageInSection(obj, priorityField, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl && path.toLowerCase().includes(priorityField.toLowerCase())) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageInSection(value, priorityField, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageInSection(obj[i], priorityField, `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function for general image URL search
            function searchForImageUrl(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('http')) {
                    const isImageUrl = imageExtensions.some(ext => obj.toLowerCase().includes(ext));
                    if (isImageUrl) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForImageUrl(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForImageUrl(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
            
            // Helper function to search for unresolved image drefs
            function searchForUnresolvedImageDref(obj, path = '') {
                if (typeof obj === 'string' && obj.startsWith('did:arweave:')) {
                    // Check if the field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => path.toLowerCase().includes(name.toLowerCase()));
                    
                    if (isImageField) {
                        return obj;
                    }
                } else if (typeof obj === 'object' && obj !== null && !obj.oip) {
                    for (const [key, value] of Object.entries(obj)) {
                        const result = searchForUnresolvedImageDref(value, path ? `${path}.${key}` : key);
                        if (result) return result;
                    }
                } else if (Array.isArray(obj)) {
                    for (let i = 0; i < obj.length; i++) {
                        const result = searchForUnresolvedImageDref(obj[i], `${path}[${i}]`);
                        if (result) return result;
                    }
                }
                return null;
            }
        }

        /**
         * Extract media from a specific data section
         */
        function extractMediaFromSection(section, content, sectionName, record = null) {
            if (!section || typeof section !== 'object') return;
            
            // Get basic data for image titles
            const basicData = record?.data?.basic || {};
            
            Object.keys(section).forEach(fieldName => {
                const value = section[fieldName];
                
                // Handle resolved drefs
                if (value && typeof value === 'object' && value.data && value.oip) {
                    const embedType = value.oip.recordType;
                    const embedData = value.data[embedType];
                    
                    if (embedType === 'image' && embedData?.webUrl) {
                        if (!content.featuredImage) {
                            content.featuredImage = {
                                url: embedData.webUrl,
                                title: value.data.basic?.name || 'Image',
                                contentType: embedData.contentType
                            };
                            console.log(`[Media Detection] ✅ Found resolved image dref at ${sectionName}.${fieldName}: ${embedData.webUrl}`);
                        }
                    } else if (embedType === 'audio' && embedData?.webUrl) {
                        content.audioItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Audio',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'video' && embedData?.webUrl) {
                        content.videoItems.push({
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Video',
                            contentType: embedData.contentType
                        });
                    } else if (embedType === 'text' && embedData?.webUrl && fieldName === 'articleText') {
                        content.articleText = {
                            url: embedData.webUrl,
                            title: value.data.basic?.name || 'Article Text',
                            contentType: embedData.contentType
                        };
                    }
                }
                
                // Handle arrays of resolved drefs
                else if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                    value.forEach(item => {
                        const embedType = item.oip.recordType;
                        const embedData = item.data[embedType];
                        
                        if (embedType === 'audio' && embedData?.webUrl) {
                            content.audioItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Audio',
                                contentType: embedData.contentType
                            });
                        } else if (embedType === 'video' && embedData?.webUrl) {
                            content.videoItems.push({
                                url: embedData.webUrl,
                                title: item.data.basic?.name || 'Video',
                                contentType: embedData.contentType
                            });
                        }
                    });
                }
                
                // Handle direct URLs
                else if (fieldName === 'webUrl' && typeof value === 'string') {
                    content.webUrl = value;
                }
                
                // Enhanced image URL detection for recipes and other records
                else if (typeof value === 'string' && value.startsWith('http')) {
                    // Check if it's an image URL by extension
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    // Check if field name suggests it's an image
                    const imageFieldNames = ['image', 'photo', 'picture', 'thumbnail', 'avatar', 'icon', 'cover', 'featured'];
                    const isImageField = imageFieldNames.some(name => fieldName.toLowerCase().includes(name));
                    
                                         // For recipes, be even more permissive - any URL ending in image extension
                     const isRecipeContext = sectionName === 'recipe' || sectionName === 'food';
                     
                     // Additional recipe-specific field names
                     const recipeImageFields = ['photo', 'picture', 'img', 'imageurl', 'photourl', 'pictureurl'];
                     const isRecipeImageField = recipeImageFields.some(name => fieldName.toLowerCase().includes(name));
                    
                                                              if ((isImageUrl && (isImageField || isRecipeImageField || isRecipeContext)) || 
                         ((isImageField || isRecipeImageField) && isImageUrl)) {
                        if (!content.featuredImage) content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    }
                }
                
                // Handle webUrl fields that point to images (common in recipes)
                else if (fieldName === 'webUrl' && typeof value === 'string' && value.startsWith('http')) {
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => value.toLowerCase().includes(ext));
                    
                    if (isImageUrl && !content.featuredImage) {
                        content.featuredImage = {
                            url: value,
                            title: basicData?.name || 'Image',
                            contentType: 'image/jpeg'
                        };
                    } else {
                        content.webUrl = value;
                    }
                }
            });
        }

        /**
         * Render media preview (featured image or video thumbnail)
         */
        function renderMediaPreview(mediaContent, recordIndex) {
            // Priority: Video thumbnail > Featured Image > First Video > Placeholder
            if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                return `
                    <div class="media-preview video-preview">
                        <video class="preview-video" poster="" onclick="playVideoFullscreen('${video.url}', '${video.title}')">
                            <source src="${video.url}" type="${video.contentType || 'video/mp4'}">
                        </video>
                        <div class="play-overlay" onclick="playVideoFullscreen('${video.url}', '${video.title}')">
                            <div class="play-button">▶️</div>
                        </div>
                        <div class="media-badge">📹 Video</div>
                    </div>
                `;
            } else if (mediaContent.featuredImage) {
                return `
                    <div class="media-preview image-preview">
                        <img src="${mediaContent.featuredImage.url}" 
                             alt="${mediaContent.featuredImage.title}"
                             class="preview-image"
                             onclick="openImageModal('${mediaContent.featuredImage.url}', '${mediaContent.featuredImage.title}')"
                             onerror="this.parentElement.innerHTML='<div class=\\"preview-placeholder\\">🖼️ Image</div>'">
                        <div class="media-badge">📷 Image</div>
                    </div>
                `;
            } else if (mediaContent.audioItems.length > 0) {
                return `
                    <div class="media-preview audio-preview">
                        <div class="audio-artwork">
                            <div class="audio-icon">🎵</div>
                            <div class="audio-visualizer">
                                <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
                            </div>
                        </div>
                        <div class="media-badge">🎵 Audio</div>
                    </div>
                `;
            } else if (mediaContent.unresolvedImageDref) {
                return `
                    <div class="media-preview placeholder-preview">
                        <div class="preview-placeholder resolve-hint">
                            🖼️ Image<br>
                            <small style="font-size: 0.7rem; opacity: 0.8;">Increase Resolve Depth to see image</small>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="media-preview placeholder-preview">
                        <div class="preview-placeholder">📄 Text</div>
                    </div>
                `;
            }
        }

        /**
         * Render media controls (play buttons, etc.)
         */
        function renderMediaControls(mediaContent, record, recordIndex) {
            let controls = '';
            
            // Audio controls
            if (mediaContent.audioItems.length > 0) {
                const audio = mediaContent.audioItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn primary" onclick="playAudioInMaster('${audio.url}', '${audio.title}', '${record.oip?.recordType || 'audio'}', ${recordIndex})" id="audioBtn-${recordIndex}">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Audio</span>
                        </button>
                        ${mediaContent.audioItems.length > 1 ? `<span class="media-count">+${mediaContent.audioItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            // Video controls  
            if (mediaContent.videoItems.length > 0) {
                const video = mediaContent.videoItems[0];
                controls += `
                    <div class="media-controls">
                        <button class="play-btn secondary" onclick="playVideoFullscreen('${video.url}', '${video.title}')">
                            <span class="play-icon">▶️</span>
                            <span class="play-text">Play Video</span>
                        </button>
                        ${mediaContent.videoItems.length > 1 ? `<span class="media-count">+${mediaContent.videoItems.length - 1} more</span>` : ''}
                    </div>
                `;
            }
            
            return controls;
        }

        /**
         * Render article text button for posts
         */
        function renderArticleTextButton(mediaContent, recordIndex) {
            if (mediaContent.articleText) {
                return `
                    <div class="article-controls">
                        <button class="article-btn" onclick="loadArticleText('${mediaContent.articleText.url}', ${recordIndex})">
                            📄 Full Article Text
                        </button>
                        <div id="articleText-${recordIndex}" class="article-content hidden">
                            <div class="article-loading">Loading article...</div>
                        </div>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Render web URL button
         */
        function renderWebUrlButton(mediaContent) {
            if (mediaContent.webUrl) {
                return `
                    <div class="web-controls">
                        <a href="${mediaContent.webUrl}" target="_blank" rel="noopener noreferrer" class="web-btn">
                            🌐 View Original
                        </a>
                    </div>
                `;
            }
            return '';
        }

        /**
         * Toggle record structure visibility
         */
        function toggleRecordStructure(recordIndex) {
            const structure = document.getElementById(`structure-${recordIndex}`);
            const button = structure.previousElementSibling.querySelector('.show-structure-btn');
            
            if (structure.classList.contains('hidden')) {
                structure.classList.remove('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Hide Record Structure';
            } else {
                structure.classList.add('hidden');
                button.innerHTML = '<span class="structure-icon">🔧</span> Show Record Structure';
            }
        }

        /**
         * Load article text content
         */
        async function loadArticleText(url, recordIndex) {
            const container = document.getElementById(`articleText-${recordIndex}`);
            const button = container.previousElementSibling;
            
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                button.textContent = '📄 Full Article Text';
                return;
            }
            
            try {
                button.textContent = '📄 Loading...';
                button.disabled = true;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                
                container.innerHTML = `
                    <div class="article-header">
                        <h4>📄 Full Article Text</h4>
                        <button onclick="toggleRecordStructure(${recordIndex}); document.getElementById('articleText-${recordIndex}').classList.add('hidden'); document.querySelector('[onclick*=\\"loadArticleText\\"]').textContent='📄 Full Article Text'; document.querySelector('[onclick*=\\"loadArticleText\\"]').disabled=false;" class="close-btn">✕</button>
                    </div>
                    <div class="article-text">${escapeHtml(text)}</div>
                `;
                container.classList.remove('hidden');
                button.textContent = '📄 Hide Article Text';
                
            } catch (error) {
                container.innerHTML = `<div class="article-error">Error loading article: ${error.message}</div>`;
                container.classList.remove('hidden');
                button.textContent = '❌ Failed to Load';
            } finally {
                button.disabled = false;
            }
        }

        /**
         * Play video in fullscreen modal
         */
        function playVideoFullscreen(url, title) {
            // Create simple video modal
            const modal = document.createElement('div');
            modal.className = 'video-modal';
            modal.innerHTML = `
                <div class="video-modal-content">
                    <div class="video-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.video-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <video controls autoplay style="width: 100%; max-height: 70vh;">
                        <source src="${url}">
                        Your browser doesn't support video playback.
                    </video>
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Open image in modal
         */
        function openImageModal(url, title) {
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="image-modal-content">
                    <div class="image-modal-header">
                        <h3>${escapeHtml(title)}</h3>
                        <button onclick="this.closest('.image-modal').remove()" class="close-btn">✕</button>
                    </div>
                    <img src="${url}" alt="${escapeHtml(title)}" style="max-width: 100%; max-height: 80vh;">
                </div>
            `;
            
            modal.onclick = (e) => {
                if (e.target === modal) modal.remove();
            };
            
            document.body.appendChild(modal);
        }

        /**
         * Render basic information section
         */
        function renderBasicInfo(basicData) {
            let html = '';
            
            if (basicData.description) {
                html += `<div class="record-content">${truncateText(basicData.description, 200)}</div>`;
            }
            
            return html;
        }

        /**
         * Dynamically render all template data sections
         */
        function renderAllTemplateData(record, templatesUsed) {
            let html = '';
            
            if (!record.data) return html;
            
            Object.keys(record.data).forEach(templateName => {
                if (templateName === 'basic') return; // Skip basic - handled separately
                
                const templateData = record.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `data.${templateName}`);
            });
            
            return html ? `<div class="media-content">${html}</div>` : '';
        }

        /**
         * Render data for a specific template section
         */
        function renderTemplateSectionData(templateName, data, path = '') {
            if (!data || typeof data !== 'object') return '';
            
            let html = '';
            const fieldsMap = templateFieldMap[templateName];
            
            if (showDebugInfo && fieldsMap) {
                html += `<div class="field-debug">Template: ${templateName}, Fields: ${Object.keys(fieldsMap).length}</div>`;
            }
            
            Object.keys(data).forEach(fieldName => {
                const value = data[fieldName];
                const fieldDef = getFieldDefinition(templateName, fieldName);
                const fieldPath = path ? `${path}.${fieldName}` : fieldName;
                
                html += renderFieldByType(templateName, fieldName, value, fieldDef, fieldPath);
            });
            
            return html;
        }

        /**
         * Render a field based on its type definition
         */
        function renderFieldByType(templateName, fieldName, value, fieldDef, path) {
            if (!value) return '';
            
            let html = '';
            const mediaType = getMediaType(templateName, fieldName, value);
            
            // Debug info
            if (showDebugInfo) {
                const typeInfo = fieldDef ? `${fieldDef.type} (${fieldDef.index})` : 'unknown type';
                html += `<div class="field-debug">Field: ${fieldName} <span class="field-type-indicator">${typeInfo}</span></div>`;
            }
            
            // Handle resolved drefs (embedded records)
            if (value && typeof value === 'object' && value.data && value.oip) {
                return renderResolvedDref(fieldName, value, path);
            }
            
            // Handle arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data && value[0].oip) {
                return renderResolvedDrefArray(fieldName, value, path);
            }
            
            // Handle direct media URLs based on detected type
            if (mediaType) {
                return renderMediaField(fieldName, value, mediaType);
            }
            
            // Handle simple web URLs
            if (fieldName === 'webUrl' && typeof value === 'string') {
                html += `<div class="media-item">
                    <a href="${value}" target="_blank" rel="noopener noreferrer" 
                       style="display: inline-block; padding: 8px 16px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                        🌐 Visit ${fieldName}
                    </a>
                </div>`;
            }
            
            // Handle unresolved drefs
            if (isDrefField(fieldDef, value)) {
                html += renderUnresolvedDref(fieldName, value);
            }
            
            return html;
        }

        /**
         * Render resolved dref (embedded record)
         */
        function renderResolvedDref(fieldName, resolvedRecord, path) {
            const embedTemplates = Object.keys(resolvedRecord.data).filter(k => k !== 'basic');
            const recordType = resolvedRecord.oip?.recordType || embedTemplates[0] || 'unknown';
            
            let html = `<div class="dref-resolved">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">
                    📎 ${fieldName} (${recordType}):
                </label>`;
            
            // Render basic info from embedded record
            if (resolvedRecord.data.basic) {
                const basicData = resolvedRecord.data.basic;
                if (basicData.name) {
                    html += `<div style="font-weight: 500; margin-bottom: 5px;">${basicData.name}</div>`;
                }
                if (basicData.description) {
                    html += `<div style="font-size: 13px; color: #666; margin-bottom: 8px;">${truncateText(basicData.description, 100)}</div>`;
                }
            }
            
            // Render each template section in the embedded record
            embedTemplates.forEach(templateName => {
                const templateData = resolvedRecord.data[templateName];
                html += renderTemplateSectionData(templateName, templateData, `${path}.data.${templateName}`);
            });
            
            if (showDebugInfo) {
                html += `<div class="field-debug">Resolved: ${resolvedRecord.oip?.didTx}</div>`;
            }
            
            html += '</div>';
            return html;
        }

        /**
         * Render array of resolved drefs
         */
        function renderResolvedDrefArray(fieldName, resolvedArray, path) {
            let html = `<div style="margin: 10px 0;">
                <label style="font-weight: bold; display: block; margin-bottom: 5px;">
                    📎 ${fieldName} (${resolvedArray.length} items):
                </label>`;
            
            resolvedArray.forEach((resolvedRecord, index) => {
                html += renderResolvedDref(`${fieldName}[${index}]`, resolvedRecord, `${path}[${index}]`);
            });
            
            html += '</div>';
            return html;
        }

        /**
         * Render media field based on detected type
         */
        function renderMediaField(fieldName, value, mediaType) {
            const webUrl = value.webUrl || value;
            if (!webUrl) return '';
            
            switch (mediaType) {
                case 'image':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <img src="${webUrl}" alt="${fieldName}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 5px 0;" 
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; padding: 10px; background: #f5f5f5; border-radius: 8px;">
                            <a href="${webUrl}" target="_blank">📸 View Image</a>
                        </div>
                    </div>`;
                    
                case 'audio':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <audio controls style="width: 100%; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'audio/mpeg'}">
                            <a href="${webUrl}" target="_blank">🎵 Play Audio</a>
                        </audio>
                    </div>`;
                    
                case 'video':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <video controls style="width: 100%; max-height: 300px; margin: 5px 0;">
                            <source src="${webUrl}" type="${value.contentType || 'video/mp4'}">
                            <a href="${webUrl}" target="_blank">🎥 Play Video</a>
                        </video>
                    </div>`;
                    
                case 'text':
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <div class="text-preview" style="margin: 5px 0;">
                            <button onclick="loadTextContent('${webUrl}', this)" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                📄 View Text Content
                            </button>
                            <div class="text-content" style="display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; max-height: 300px; overflow-y: auto;"></div>
                        </div>
                    </div>`;
                    
                default:
                    return `<div class="media-item">
                        <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName}:</label>
                        <a href="${webUrl}" target="_blank" style="display: inline-block; padding: 8px 16px; background: #6c757d; color: white; text-decoration: none; border-radius: 4px; margin: 5px 0;">
                            🔗 View Content
                        </a>
                    </div>`;
            }
        }

        /**
         * Render unresolved dref
         */
        function renderUnresolvedDref(fieldName, value) {
            const didValue = Array.isArray(value) ? value[0] : value;
            if (!didValue || !didValue.startsWith('did:arweave:')) return '';
            
            return `<div class="media-item">
                <label style="font-weight: bold; display: block; margin: 10px 0 5px 0;">${fieldName} (unresolved):</label>
                <div class="unresolved-dref">
                    📋 ${didValue}
                    <br><em>Increase resolve depth to see content</em>
                </div>
            </div>`;
        }

        function getRecordType(record) {
            // First, check the authoritative source: oip.recordType
            if (record.oip && record.oip.recordType) {
                return record.oip.recordType;
            }
            
            // Fallback: Try to get from data structure
            if (record.data) {
                const keys = Object.keys(record.data);
                for (const key of keys) {
                    if (key !== 'basic' && typeof record.data[key] === 'object') {
                        return key;
                    }
                }
            }
            
            return 'unknown';
        }

        function getContentPreview(data) {
            if (!data) return '';
            
            // Try common content fields
            if (data.content) return truncateText(data.content, 150);
            if (data.articleText) return truncateText(data.articleText, 150);
            if (data.description) return truncateText(data.description, 150);
            
            return '';
        }

        function createTagsDisplay(tags) {
            if (!tags || !Array.isArray(tags) || tags.length === 0) return '';
            
            const tagsHtml = tags.slice(0, 5).map(tag => 
                `<span class="tag-chip" onclick="filterByTag('${escapeHtml(tag)}')" title="Filter by ${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
            ).join('');
            
            return `<div class="tags-container">${tagsHtml}</div>`;
        }



        // ========================================================================
        // ENHANCED DYNAMIC TEMPLATE SYSTEM
        // ========================================================================
        // 
        // This system dynamically renders OIP records based on their actual 
        // template definitions from the /api/templates endpoint, eliminating 
        // the need for hardcoded field names and types.
        //
        // Key Features:
        // - Loads all templates and builds field type mappings at startup
        // - Analyzes records to identify all templates used (including nested DREFs)
        // - Renders fields based on their actual template type definitions
        // - Handles resolved and unresolved DREF fields automatically
        // - Supports unlimited nesting depth with resolveDepth parameter
        // - Includes debug mode to show template analysis information
        // - Works with any new templates/fields without code changes
        //
        // Usage: Enable "Debug Templates" checkbox to see template analysis
        // Test: Run testTemplateSystem() in browser console to verify functionality
        // ========================================================================
        
        /**
         * Load all templates and build enhanced field mapping
         */
        async function loadTemplates() {
            try {
                console.log('[Templates] Loading all templates with enhanced mapping...');
                const response = await fetch('/api/templates?limit=1000');
                const data = await response.json();
                
                if (data.templates) {
                    // Clear existing mappings
                    templates = {};
                    allTemplates = {};
                    templateFieldMap = {};
                    
                    data.templates.forEach(template => {
                        const templateName = template.data.template || template.data.recordType || 'unknown';
                        const templateTxId = template.oip.didTx;
                        const recordType = template.data.recordType || template.data.template || 'unknown';
                        
                        // Store in legacy format for compatibility
                        if (!templates[recordType]) {
                            templates[recordType] = [];
                        }
                        templates[recordType].push(template);
                        
                        // Store in enhanced format by name and TxId
                        allTemplates[templateName] = template;
                        allTemplates[templateTxId] = template;
                        
                        // Build field mapping for this template
                        if (template.data.fieldsInTemplate) {
                            templateFieldMap[templateName] = template.data.fieldsInTemplate;
                            templateFieldMap[templateTxId] = template.data.fieldsInTemplate;
                            
                            if (showDebugInfo) {
                                console.log(`[Templates] Mapped fields for ${templateName}:`, template.data.fieldsInTemplate);
                            }
                        }
                    });
                    
                    // Load default templates from config
                    defaultTemplates = {
                        basic: "did:arweave:-9DirnjVO1FlbEW1lN8jITBESrTsQKEM_BoZ1ey_0mk",
                        creatorRegistration: "did:arweave:BKVvTSXmmJni-L82irZfPFXWWJLBcdvbxS34jP1FTG8",
                        associatedUrlOnWeb: "did:arweave:_RJtiNMr1Ls9NG3G9-6rvbI5Sn0ccSnRTnrQCZi3ABE",
                        text: "did:arweave:of_eh0kGy65uYD0xsTh7Qe6JVTfJ2oFoA7xp4H7t7YI",
                        image: "did:arweave:AkZnE1VckJJlRamgNJuIGE7KrYwDcCciWOMrMh68V4o",
                        audio: "did:arweave:9MrI8kJvBJ-u7uvgngMZ-gMo5RREDwey8G7mJEUOpdo",
                        video: "did:arweave:G73WplyxpNDOgDSFO6CP3O6hZXq8kNJXxkCqx3sgd1s",
                        post: "did:arweave:op6y-d_6bqivJ2a2oWQnbylD4X_LH6eQyR6rCGqtVZ8",
                        recipe: "did:arweave:46Ui_ifw5LnrRmf_o2zWwikNxgXsXk3sswPtbcJCzlc",
                        workout: "did:arweave:T_16JOpyRKt0dmuZikHPpDcIhwh4DR1ZspHU4BKa-qE"
                    };
                    
                    console.log(`[Templates] Loaded ${Object.keys(allTemplates).length / 2} templates`);
                    console.log(`[Templates] Field mappings for:`, Object.keys(templateFieldMap));
                }
            } catch (error) {
                console.error('[Templates] Error loading templates:', error);
            }
        }

        /**
         * Analyze a record to find all templates used (including nested drefs)
         */
        function analyzeRecordTemplates(record) {
            const templatesFound = new Set();
            
            function analyzeDataSection(data, path = '') {
                if (!data || typeof data !== 'object') return;
                
                Object.keys(data).forEach(key => {
                    if (key === 'basic' || key === 'oip') return; // Skip these
                    
                    const value = data[key];
                    const currentPath = path ? `${path}.${key}` : key;
                    
                    // This is a template section (e.g., 'post', 'image', etc.)
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        // Check if this looks like a template data section
                        if (value.webUrl || value.contentType || Object.keys(value).some(k => !k.startsWith('_'))) {
                            templatesFound.add(key);
                            if (showDebugInfo) {
                                console.log(`[Templates] Found template section: ${key} at ${currentPath}`);
                            }
                        }
                        
                        // Recursively analyze nested objects
                        analyzeDataSection(value, currentPath);
                    } else if (Array.isArray(value)) {
                        // Analyze array items (might be dref resolved objects)
                        value.forEach((item, index) => {
                            if (item && typeof item === 'object' && item.data) {
                                if (showDebugInfo) {
                                    console.log(`[Templates] Found resolved dref in array at ${currentPath}[${index}]`);
                                }
                                analyzeDataSection(item.data, `${currentPath}[${index}].data`);
                            }
                        });
                    } else if (typeof value === 'object' && value !== null && value.data) {
                        // This is a resolved dref
                        if (showDebugInfo) {
                            console.log(`[Templates] Found resolved dref at ${currentPath}`);
                        }
                        analyzeDataSection(value.data, `${currentPath}.data`);
                    }
                });
            }
            
            // Analyze the main data section
            if (record.data) {
                analyzeDataSection(record.data);
            }
            
            // Always include the main record type
            if (record.oip && record.oip.recordType) {
                templatesFound.add(record.oip.recordType);
            }
            
            return Array.from(templatesFound);
        }

        /**
         * Get field definition for a specific field in a template
         */
        function getFieldDefinition(templateName, fieldName) {
            const fieldsMap = templateFieldMap[templateName];
            if (!fieldsMap) return null;
            
            return fieldsMap[fieldName] || null;
        }

        /**
         * Determine if a field is a DREF based on its type and content
         */
        function isDrefField(fieldDef, value) {
            if (!fieldDef) return false;
            
            // Check type definition
            if (fieldDef.type === 'dref' || fieldDef.type === 'repeated dref') {
                return true;
            }
            
            // Check value pattern (did:arweave:...)
            if (typeof value === 'string' && value.startsWith('did:arweave:')) {
                return true;
            }
            
            // Check if it's an array of DIDs
            if (Array.isArray(value) && value.length > 0 && 
                typeof value[0] === 'string' && value[0].startsWith('did:arweave:')) {
                return true;
            }
            
            return false;
        }

        /**
         * Determine media type from field definition and content
         */
        function getMediaType(templateName, fieldName, value) {
            const fieldDef = getFieldDefinition(templateName, fieldName);
            
            // If it's a resolved dref, look at the embedded data
            if (value && typeof value === 'object' && value.data) {
                const embedTemplates = Object.keys(value.data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0]; // Return the template type (image, audio, video, text, etc.)
                }
            }
            
            // Check for arrays of resolved drefs
            if (Array.isArray(value) && value.length > 0 && value[0].data) {
                const embedTemplates = Object.keys(value[0].data).filter(k => k !== 'basic');
                if (embedTemplates.length > 0) {
                    return embedTemplates[0];
                }
            }
            
            // Check field name patterns
            if (fieldName.toLowerCase().includes('image')) return 'image';
            if (fieldName.toLowerCase().includes('audio')) return 'audio';
            if (fieldName.toLowerCase().includes('video')) return 'video';
            if (fieldName.toLowerCase().includes('text')) return 'text';
            
            // Check content patterns
            if (value && typeof value === 'object') {
                if (value.webUrl) {
                    if (value.contentType) {
                        if (value.contentType.startsWith('image/')) return 'image';
                        if (value.contentType.startsWith('audio/')) return 'audio';
                        if (value.contentType.startsWith('video/')) return 'video';
                        if (value.contentType.startsWith('text/')) return 'text';
                    }
                }
            }
            
            return null;
        }

        async function loadRecordTypes() {
            try {
                const response = await fetch('https://api.oip.onl/api/templates?limit=25&page=1');
                const data = await response.json();
                
                if (data.templates) {
                    const typeSet = new Set();
                    data.templates.forEach(template => {
                        if (template.data?.template) {
                            typeSet.add(template.data.template);
                        }
                    });
                    
                    recordTypes = Array.from(typeSet).sort();
                    populateRecordTypeFilter();
                }
            } catch (error) {
                console.error('Error loading record types:', error);
            }
        }

        function populateRecordTypeFilter() {
            // Populate voice record type filter (Browse + AI Chat tab)
            const voiceSelect = document.getElementById('voice-record-type-filter');
            if (voiceSelect) {
                voiceSelect.innerHTML = '<option value="">All Types</option>';
                
                recordTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    voiceSelect.appendChild(option);
                });
            }
        }

        // Utility functions
        function truncateText(text, length) {
            if (!text) return '';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        function dateToUnixTime(dateString) {
            if (!dateString) return '';
            return Math.floor(new Date(dateString).getTime() / 1000).toString();
        }



        function setupInfiniteScroll() {
            window.addEventListener('scroll', () => {
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
                    loadMoreRecords();
                }
            });
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = type === 'error' ? 'error-message' : 'success-message';
            element.classList.remove('hidden');
            
            if (type === 'success') {
                setTimeout(() => element.classList.add('hidden'), 3000);
            }
        }

        function hideElement(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        // Publishing navigation functions
        function hideAllPublishingSections() {
            document.getElementById('creator-section').classList.add('hidden');
            document.getElementById('template-section').classList.add('hidden');
            document.getElementById('record-section').classList.add('hidden');
        }

        function showCreatorRegistration() {
            hideAllPublishingSections();
            document.getElementById('creator-section').classList.remove('hidden');
        }

        function showTemplateCreation() {
            hideAllPublishingSections();
            document.getElementById('template-section').classList.remove('hidden');
        }

        function showRecordPublishing() {
            hideAllPublishingSections();
            document.getElementById('record-section').classList.remove('hidden');
        }

        // Creator registration
        async function registerCreator() {
            const name = document.getElementById('creator-name').value;
            const description = document.getElementById('creator-description').value;
            const email = document.getElementById('creator-email').value;
            const website = document.getElementById('creator-website').value;

            if (!name) {
                showMessage('creator-status', 'Please enter a creator name', 'error');
                return;
            }

            const creatorData = {
                basic: {
                    name: name,
                    description: description,
                    language: 'en',
                    date: Math.floor(Date.now() / 1000),
                    nsfw: false
                },
                creatorRegistration: {
                    email: email || currentUser,
                    website: website,
                    verified: false
                }
            };

            try {
                const response = await fetch('/api/creators/newCreator', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(creatorData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('creator-success', `Creator registered successfully! Transaction ID: ${data.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('creator-name').value = '';
                    document.getElementById('creator-description').value = '';
                    document.getElementById('creator-email').value = '';
                    document.getElementById('creator-website').value = '';
                } else {
                    showMessage('creator-status', data.error || 'Failed to register creator', 'error');
                }
            } catch (error) {
                showMessage('creator-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Template creation functions
        function addTemplateField() {
            const fieldsContainer = document.getElementById('template-fields');
            const fieldRow = document.createElement('div');
            fieldRow.className = 'field-row';
            fieldRow.innerHTML = `
                <div>
                    <label>Field Name:</label>
                    <input type="text" class="field-name" placeholder="e.g., title, content">
                </div>
                <div>
                    <label>Field Type:</label>
                    <select class="field-type">
                        <option value="string">String</option>
                        <option value="number">Number</option>
                        <option value="boolean">Boolean</option>
                        <option value="enum">Enum</option>
                        <option value="array">Array</option>
                    </select>
                </div>
                <div>
                    <button type="button" onclick="removeField(this)">Remove</button>
                </div>
            `;
            fieldsContainer.appendChild(fieldRow);
        }

        function removeField(button) {
            button.closest('.field-row').remove();
        }

        async function createTemplate() {
            const templateName = document.getElementById('template-name').value;
            const recordType = document.getElementById('template-recordtype').value;

            if (!templateName || !recordType) {
                showMessage('template-status', 'Please fill in template name and record type', 'error');
                return;
            }

            const fieldRows = document.querySelectorAll('#template-fields .field-row');
            const templateFields = {};

            fieldRows.forEach(row => {
                const fieldName = row.querySelector('.field-name').value;
                const fieldType = row.querySelector('.field-type').value;
                
                if (fieldName && fieldType) {
                    templateFields[fieldName] = fieldType;
                }
            });

            if (Object.keys(templateFields).length === 0) {
                showMessage('template-status', 'Please add at least one field', 'error');
                return;
            }

            const templateData = {
                template: templateName,
                recordType: recordType,
                fields: JSON.stringify(templateFields)
            };

            try {
                const response = await fetch('/api/templates/newTemplate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(templateData)
                });

                const data = await response.json();
                
                if (response.ok) {
                    showMessage('template-success', `Template created successfully! Transaction ID: ${data.newTemplate.transactionId}`, 'success');
                    // Clear form and reload templates
                    document.getElementById('template-name').value = '';
                    document.getElementById('template-recordtype').value = '';
                    await loadTemplates();
                } else {
                    showMessage('template-status', data.error || 'Failed to create template', 'error');
                }
            } catch (error) {
                showMessage('template-status', 'Network error: ' + error.message, 'error');
            }
        }

        // Enhanced Record Publishing Functions
        function loadPublishInterface() {
            const recordType = document.getElementById('publish-record-type').value;
            const interfaceContainer = document.getElementById('publish-interface');
            
            if (!recordType) {
                interfaceContainer.innerHTML = '<div class="loading">Select a record type to see publishing interface</div>';
                return;
            }

            // Create tailored interface based on record type
            switch (recordType) {
                case 'post':
                    interfaceContainer.innerHTML = createPostInterface();
                    break;
                case 'video':
                    interfaceContainer.innerHTML = createVideoInterface();
                    break;
                case 'audio':
                    interfaceContainer.innerHTML = createAudioInterface();
                    break;
                case 'image':
                    interfaceContainer.innerHTML = createImageInterface();
                    break;
                case 'recipe':
                    interfaceContainer.innerHTML = createRecipeInterface();
                    break;
                case 'workout':
                    interfaceContainer.innerHTML = createWorkoutInterface();
                    break;
                case 'text':
                    interfaceContainer.innerHTML = createTextInterface();
                    break;
                default:
                    interfaceContainer.innerHTML = '<div class="loading">Unknown record type</div>';
            }
        }

        function createPostInterface() {
            return `
                <div class="publish-form">
                    <h3>📝 Post / Article Publishing</h3>
                    
                    <!-- Post Source Selection -->
                    <div class="form-group">
                        <label for="post-source">Post Source:</label>
                        <select id="post-source" onchange="updatePostSource()">
                            <option value="manual">Create New Post</option>
                            <option value="archive-x">Archive X/Twitter Post</option>
                        </select>
                    </div>

                    <!-- Manual Post Creation Interface -->
                    <div id="manual-post-interface">
                        <!-- Post Type Selection -->
                        <div class="form-group">
                            <label for="post-type">Post Type:</label>
                            <select id="post-type" onchange="updatePostInterface()">
                                <option value="microblog">Microblog Post (Twitter-style)</option>
                                <option value="article">News Article</option>
                                <option value="blog">Blog Post</option>
                            </select>
                        </div>

                        <!-- Basic Information -->
                        <div class="form-group">
                            <label for="post-title">Title:</label>
                            <input type="text" id="post-title" required placeholder="Enter post title...">
                        </div>

                        <div class="form-group">
                            <label for="post-description">Description:</label>
                            <textarea id="post-description" placeholder="Brief description of the post..." rows="2"></textarea>
                        </div>

                        <!-- Article Content -->
                        <div class="form-group">
                            <label for="post-content">Content:</label>
                            <textarea id="post-content" required placeholder="Write your post content here..." rows="8"></textarea>
                            <small>Supports markdown formatting</small>
                        </div>

                        <!-- Author Information (for articles) -->
                        <div id="author-section">
                            <div class="form-group">
                                <label for="post-author">Author:</label>
                                <input type="text" id="post-author" placeholder="Author name">
                            </div>
                            <div class="form-group">
                                <label for="post-author-title">Author Title:</label>
                                <input type="text" id="post-author-title" placeholder="e.g., Senior Reporter">
                            </div>
                            <div class="form-group">
                                <label for="post-author-location">Author Location:</label>
                                <input type="text" id="post-author-location" placeholder="e.g., New York">
                            </div>
                        </div>

                        <!-- Media Attachments -->
                        <div class="media-section">
                            <h4>📎 Media Attachments</h4>
                            
                            <div class="form-group">
                                <label for="post-featured-image">Featured Image URL:</label>
                                <input type="url" id="post-featured-image" placeholder="https://example.com/image.jpg">
                            </div>

                            <div class="form-group">
                                <label for="post-web-url">Source URL:</label>
                                <input type="url" id="post-web-url" placeholder="Original article URL (if reposting)">
                            </div>

                            <div class="form-group">
                                <label for="post-reply-to">Reply To (DID):</label>
                                <input type="text" id="post-reply-to" placeholder="did:arweave:... (if replying to another post)">
                            </div>
                        </div>

                        <!-- Tags -->
                        <div class="form-group">
                            <label for="post-tags">Tags:</label>
                            <input type="text" id="post-tags" placeholder="tag1, tag2, tag3">
                            <small>Comma-separated tags</small>
                        </div>

                        <!-- NSFW Toggle -->
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="post-nsfw"> NSFW Content
                            </label>
                        </div>
                    </div>

                    <!-- X Post Archival Interface -->
                    <div id="x-post-interface" class="hidden">
                        <div class="form-group">
                            <label for="x-post-url">X/Twitter Post URL:</label>
                            <input type="url" id="x-post-url" placeholder="https://x.com/username/status/1234567890" required>
                            <button type="button" onclick="scrapeXPost()" style="margin-top: 10px; width: 100%;">
                                🔍 Fetch Post Data
                            </button>
                        </div>

                        <div id="x-post-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #1da1f2;">
                            <h4>📱 Post Preview</h4>
                            <div id="x-post-content"></div>
                            <div id="x-post-meta" style="margin-top: 10px; font-size: 0.9rem; color: #666;"></div>
                        </div>

                        <div id="x-post-status" class="hidden" style="margin-top: 15px; padding: 10px; border-radius: 6px;"></div>
                    </div>

                    <button onclick="publishPost()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="post-publish-text">📤 Publish Post</span>
                    </button>
                </div>
            `;
        }

        function createVideoInterface() {
            return `
                <div class="publish-form">
                    <h3>🎥 Video Publishing</h3>
                    
                    <!-- Video Source -->
                    <div class="form-group">
                        <label for="video-source">Video Source:</label>
                        <select id="video-source" onchange="updateVideoInterface()">
                            <option value="manual">Manual Entry</option>
                            <option value="youtube-archive">Archive YouTube Video</option>
                            <option value="direct">Direct Video URL</option>
                            <option value="upload">Upload Video File</option>
                        </select>
                    </div>

                    <div id="video-input-section">
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    </div>

                    <!-- Video Information -->
                    <div class="form-group">
                        <label for="video-title">Title:</label>
                        <input type="text" id="video-title" required placeholder="Video title">
                    </div>

                    <div class="form-group">
                        <label for="video-description">Description:</label>
                        <textarea id="video-description" placeholder="Video description..." rows="4"></textarea>
                    </div>

                    <!-- Video Metadata -->
                    <div class="form-group">
                        <label for="video-duration">Duration (minutes):</label>
                        <input type="number" id="video-duration" placeholder="e.g., 15">
                    </div>

                    <div class="form-group">
                        <label for="video-channel">Channel/Creator:</label>
                        <input type="text" id="video-channel" placeholder="Channel or creator name">
                    </div>

                    <div class="form-group">
                        <label for="video-thumbnail">Thumbnail URL:</label>
                        <input type="url" id="video-thumbnail" placeholder="https://example.com/thumbnail.jpg">
                    </div>

                    <!-- Tags and Categories -->
                    <div class="form-group">
                        <label for="video-category">Category:</label>
                        <select id="video-category">
                            <option value="">Select category</option>
                            <option value="education">Education</option>
                            <option value="entertainment">Entertainment</option>
                            <option value="music">Music</option>
                            <option value="news">News</option>
                            <option value="sports">Sports</option>
                            <option value="technology">Technology</option>
                            <option value="gaming">Gaming</option>
                            <option value="howto">How-to & Style</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="video-tags">Tags:</label>
                        <input type="text" id="video-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="video-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="video-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="video-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishVideo()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        <span id="video-publish-text">🎥 Publish Video</span>
                    </button>
                </div>
            `;
        }

        function createAudioInterface() {
            return `
                <div class="publish-form">
                    <h3>🎵 Audio / Podcast Publishing</h3>
                    
                    <!-- Audio Source -->
                    <div class="form-group">
                        <label for="audio-source">Audio Source:</label>
                        <select id="audio-source" onchange="updateAudioInterface()">
                            <option value="url">Audio URL</option>
                            <option value="upload">Upload Audio File</option>
                        </select>
                    </div>

                    <div id="audio-input-section">
                        <div class="form-group">
                            <label for="audio-url">Audio URL:</label>
                            <input type="url" id="audio-url" placeholder="https://example.com/audio.mp3">
                        </div>
                    </div>

                    <!-- Audio Information -->
                    <div class="form-group">
                        <label for="audio-title">Title:</label>
                        <input type="text" id="audio-title" required placeholder="Audio title">
                    </div>

                    <div class="form-group">
                        <label for="audio-description">Description:</label>
                        <textarea id="audio-description" placeholder="Audio description..." rows="4"></textarea>
                    </div>

                    <!-- Audio Metadata -->
                    <div class="form-group">
                        <label for="audio-duration">Duration (minutes):</label>
                        <input type="number" id="audio-duration" placeholder="e.g., 45">
                    </div>

                    <div class="form-group">
                        <label for="audio-artist">Artist/Creator:</label>
                        <input type="text" id="audio-artist" placeholder="Artist or creator name">
                    </div>

                    <div class="form-group">
                        <label for="audio-album">Album/Series:</label>
                        <input type="text" id="audio-album" placeholder="Album or podcast series name">
                    </div>

                    <!-- Cover Art -->
                    <div class="form-group">
                        <label for="audio-cover">Cover Art URL:</label>
                        <input type="url" id="audio-cover" placeholder="https://example.com/cover.jpg">
                    </div>

                    <!-- Genre and Tags -->
                    <div class="form-group">
                        <label for="audio-genre">Genre:</label>
                        <select id="audio-genre">
                            <option value="">Select genre</option>
                            <option value="podcast">Podcast</option>
                            <option value="music">Music</option>
                            <option value="audiobook">Audiobook</option>
                            <option value="interview">Interview</option>
                            <option value="education">Education</option>
                            <option value="comedy">Comedy</option>
                            <option value="news">News</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="audio-tags">Tags:</label>
                        <input type="text" id="audio-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="audio-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="audio-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="audio-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishAudio()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🎵 Publish Audio
                    </button>
                </div>
            `;
        }

        function createImageInterface() {
            return `
                <div class="publish-form">
                    <h3>📷 Image Publishing</h3>
                    
                    <!-- Image Source -->
                    <div class="form-group">
                        <label for="image-source">Image Source:</label>
                        <select id="image-source" onchange="updateImageInterface()">
                            <option value="url">Image URL</option>
                            <option value="upload">Upload Image File</option>
                        </select>
                    </div>

                    <div id="image-input-section">
                        <div class="form-group">
                            <label for="image-url">Image URL:</label>
                            <input type="url" id="image-url" placeholder="https://example.com/image.jpg">
                            <button type="button" onclick="previewImage()" style="margin-top: 5px;">Preview</button>
                        </div>
                    </div>

                    <!-- Image Preview -->
                    <div id="image-preview" class="hidden" style="margin: 15px 0;">
                        <img id="preview-img" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
                    </div>

                    <!-- Image Information -->
                    <div class="form-group">
                        <label for="image-title">Title:</label>
                        <input type="text" id="image-title" required placeholder="Image title">
                    </div>

                    <div class="form-group">
                        <label for="image-description">Description:</label>
                        <textarea id="image-description" placeholder="Image description..." rows="3"></textarea>
                    </div>

                    <!-- Image Metadata -->
                    <div class="form-group">
                        <label for="image-alt-text">Alt Text:</label>
                        <input type="text" id="image-alt-text" placeholder="Accessibility description">
                    </div>

                    <div class="form-group">
                        <label for="image-photographer">Photographer/Creator:</label>
                        <input type="text" id="image-photographer" placeholder="Creator name">
                    </div>

                    <div class="form-group">
                        <label for="image-location">Location:</label>
                        <input type="text" id="image-location" placeholder="Where the image was taken">
                    </div>

                    <!-- Categories and Tags -->
                    <div class="form-group">
                        <label for="image-category">Category:</label>
                        <select id="image-category">
                            <option value="">Select category</option>
                            <option value="photography">Photography</option>
                            <option value="art">Art</option>
                            <option value="nature">Nature</option>
                            <option value="architecture">Architecture</option>
                            <option value="portrait">Portrait</option>
                            <option value="landscape">Landscape</option>
                            <option value="abstract">Abstract</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="image-tags">Tags:</label>
                        <input type="text" id="image-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="image-arweave" checked> Store on Arweave</label><br>
                            <label><input type="checkbox" id="image-ipfs"> Store on IPFS</label><br>
                            <label><input type="checkbox" id="image-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishImage()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📷 Publish Image
                    </button>
                </div>
            `;
        }

        function createRecipeInterface() {
            return `
                <div class="publish-form">
                    <h3>🍳 Recipe Publishing</h3>
                    
                    <!-- Recipe Basic Info -->
                    <div class="form-group">
                        <label for="recipe-title">Recipe Name:</label>
                        <input type="text" id="recipe-title" required placeholder="e.g., Mediterranean Grilled Chicken">
                    </div>

                    <div class="form-group">
                        <label for="recipe-description">Description:</label>
                        <textarea id="recipe-description" placeholder="Brief description of the recipe..." rows="3"></textarea>
                    </div>

                    <!-- Recipe Image -->
                    <div class="form-group">
                        <label for="recipe-image">Recipe Image URL:</label>
                        <input type="url" id="recipe-image" placeholder="https://example.com/recipe-image.jpg">
                    </div>

                    <!-- Recipe Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-prep-time">Prep Time (minutes):</label>
                            <input type="number" id="recipe-prep-time" placeholder="e.g., 15">
                        </div>
                        <div class="form-group">
                            <label for="recipe-cook-time">Cook Time (minutes):</label>
                            <input type="number" id="recipe-cook-time" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="recipe-servings">Servings:</label>
                            <input type="number" id="recipe-servings" placeholder="e.g., 4">
                        </div>
                        <div class="form-group">
                            <label for="recipe-difficulty">Difficulty:</label>
                            <select id="recipe-difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                    </div>

                    <!-- Cuisine and Course -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="recipe-cuisine">Cuisine:</label>
                            <input type="text" id="recipe-cuisine" placeholder="e.g., Mediterranean, Italian">
                        </div>
                        <div class="form-group">
                            <label for="recipe-course">Course:</label>
                            <select id="recipe-course">
                                <option value="">Select course</option>
                                <option value="appetizer">Appetizer</option>
                                <option value="main">Main Course</option>
                                <option value="side">Side Dish</option>
                                <option value="dessert">Dessert</option>
                                <option value="drink">Drink</option>
                                <option value="snack">Snack</option>
                            </select>
                        </div>
                    </div>

                    <!-- Ingredients -->
                    <div class="form-group">
                        <label>Ingredients:</label>
                        <div id="ingredients-container">
                            <div class="ingredient-row" style="display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Amount" class="ingredient-amount">
                                <input type="text" placeholder="Unit" class="ingredient-unit">
                                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                                <button type="button" onclick="removeIngredient(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addIngredient()" style="margin-top: 10px;">+ Add Ingredient</button>
                    </div>

                    <!-- Instructions -->
                    <div class="form-group">
                        <label for="recipe-instructions">Instructions:</label>
                        <textarea id="recipe-instructions" required placeholder="1. First step...
2. Second step...
3. Third step..." rows="8"></textarea>
                        <small>Write each step on a new line</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="recipe-notes">Notes:</label>
                        <textarea id="recipe-notes" placeholder="Additional notes, tips, or variations..." rows="3"></textarea>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="recipe-tags">Tags:</label>
                        <input type="text" id="recipe-tags" placeholder="vegetarian, quick, healthy">
                    </div>

                    <button onclick="publishRecipe()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        🍳 Publish Recipe
                    </button>
                </div>
            `;
        }

        function createWorkoutInterface() {
            return `
                <div class="publish-form">
                    <h3>💪 Workout Publishing</h3>
                    
                    <!-- Workout Basic Info -->
                    <div class="form-group">
                        <label for="workout-title">Workout Name:</label>
                        <input type="text" id="workout-title" required placeholder="e.g., Full Body HIIT Workout">
                    </div>

                    <div class="form-group">
                        <label for="workout-description">Description:</label>
                        <textarea id="workout-description" placeholder="Brief description of the workout..." rows="3"></textarea>
                    </div>

                    <!-- Workout Details -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-duration">Duration (minutes):</label>
                            <input type="number" id="workout-duration" placeholder="e.g., 30">
                        </div>
                        <div class="form-group">
                            <label for="workout-difficulty">Difficulty:</label>
                            <select id="workout-difficulty">
                                <option value="beginner">Beginner</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="advanced">Advanced</option>
                            </select>
                        </div>
                    </div>

                    <!-- Workout Type and Equipment -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div class="form-group">
                            <label for="workout-category">Category:</label>
                            <select id="workout-category">
                                <option value="">Select category</option>
                                <option value="strength">Strength Training</option>
                                <option value="cardio">Cardio</option>
                                <option value="hiit">HIIT</option>
                                <option value="yoga">Yoga</option>
                                <option value="pilates">Pilates</option>
                                <option value="flexibility">Flexibility</option>
                                <option value="sports">Sports</option>
                                <option value="mixed">Mixed</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="workout-equipment">Equipment Required:</label>
                            <input type="text" id="workout-equipment" placeholder="dumbbells, resistance bands">
                        </div>
                    </div>

                    <!-- Target Muscle Groups -->
                    <div class="form-group">
                        <label for="workout-muscles">Target Muscle Groups:</label>
                        <input type="text" id="workout-muscles" placeholder="chest, shoulders, legs">
                    </div>

                    <!-- Exercises -->
                    <div class="form-group">
                        <label>Exercises:</label>
                        <div id="exercises-container">
                            <div class="exercise-row" style="display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;">
                                <input type="text" placeholder="Exercise name" class="exercise-name">
                                <input type="text" placeholder="Sets" class="exercise-sets">
                                <input type="text" placeholder="Reps" class="exercise-reps">
                                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                                <button type="button" onclick="removeExercise(this)">✕</button>
                            </div>
                        </div>
                        <button type="button" onclick="addExercise()" style="margin-top: 10px;">+ Add Exercise</button>
                    </div>

                    <!-- Workout Type Toggle -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="workout-non-standard"> Non-standard workout (custom exercises)
                        </label>
                        <small>Check this if your exercises are not in our database</small>
                    </div>

                    <!-- Notes -->
                    <div class="form-group">
                        <label for="workout-notes">Notes:</label>
                        <textarea id="workout-notes" placeholder="Additional notes, tips, or modifications..." rows="3"></textarea>
                    </div>

                    <!-- Goal Tags -->
                    <div class="form-group">
                        <label for="workout-goals">Goal Tags:</label>
                        <input type="text" id="workout-goals" placeholder="weight loss, muscle gain, endurance">
                    </div>

                    <button onclick="publishWorkout()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        💪 Publish Workout
                    </button>
                </div>
            `;
        }

        function createTextInterface() {
            return `
                <div class="publish-form">
                    <h3>📄 Text Document Publishing</h3>
                    
                    <!-- Text Document Info -->
                    <div class="form-group">
                        <label for="text-title">Document Title:</label>
                        <input type="text" id="text-title" required placeholder="Document title">
                    </div>

                    <div class="form-group">
                        <label for="text-description">Description:</label>
                        <textarea id="text-description" placeholder="Brief description..." rows="2"></textarea>
                    </div>

                    <!-- Content -->
                    <div class="form-group">
                        <label for="text-content">Content:</label>
                        <textarea id="text-content" required placeholder="Enter your text content here..." rows="15"></textarea>
                        <small>Supports plain text and markdown</small>
                    </div>

                    <!-- Document Type -->
                    <div class="form-group">
                        <label for="text-type">Document Type:</label>
                        <select id="text-type">
                            <option value="document">Document</option>
                            <option value="article">Article</option>
                            <option value="essay">Essay</option>
                            <option value="story">Story</option>
                            <option value="poem">Poem</option>
                            <option value="tutorial">Tutorial</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Author Information -->
                    <div class="form-group">
                        <label for="text-author">Author:</label>
                        <input type="text" id="text-author" placeholder="Author name">
                    </div>

                    <!-- Language -->
                    <div class="form-group">
                        <label for="text-language">Language:</label>
                        <select id="text-language">
                            <option value="en">English</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="text-tags">Tags:</label>
                        <input type="text" id="text-tags" placeholder="tag1, tag2, tag3">
                    </div>

                    <!-- Publishing Options -->
                    <div class="form-group">
                        <label>Publishing Options:</label>
                        <div style="margin-top: 10px;">
                            <label><input type="checkbox" id="text-nsfw"> NSFW Content</label>
                        </div>
                    </div>

                    <button onclick="publishText()" class="btn-primary" style="width: 100%; margin-top: 20px;">
                        📄 Publish Text
                    </button>
                </div>
            `;
        }

        // Master Audio Player functions
        let currentAudioUrl = null;
        let currentAudioTitle = null;
        let currentAudioType = null;
        let currentPlayingIndex = null;

        function playAudioInMaster(audioUrl, title, recordType, recordIndex) {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            const audioTitle = document.getElementById('audio-title');
            const audioMeta = document.getElementById('audio-meta');
            const playBtn = document.getElementById('master-play-btn');
            
            // Update all audio buttons
            document.querySelectorAll('.audio-play-btn').forEach(btn => {
                btn.classList.remove('playing');
                btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
            });
            
            // If same audio is playing, toggle it
            if (currentAudioUrl === audioUrl && !masterAudio.paused) {
                masterAudio.pause();
                return;
            }
            
            // Set new audio
            currentAudioUrl = audioUrl;
            currentAudioTitle = title;
            currentAudioType = recordType;
            currentPlayingIndex = recordIndex;
            
            masterAudio.src = audioUrl;
            audioTitle.textContent = title;
            audioMeta.textContent = `${recordType} • Loading...`;
            
            // Show master player
            masterPlayer.classList.add('visible');
            
            // Update button states
            const currentBtn = document.getElementById(`audioBtn-${recordIndex}`);
            if (currentBtn) {
                currentBtn.classList.add('playing');
                currentBtn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
            }
            
            // Play audio
            masterAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                audioMeta.textContent = `${recordType} • Error loading audio`;
            });
            
            playBtn.textContent = '⏸️';
        }

        function toggleAudioPlayback() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            
            if (masterAudio.paused) {
                masterAudio.play();
                playBtn.textContent = '⏸️';
                updateCurrentPlayingButton(true);
            } else {
                masterAudio.pause();
                playBtn.textContent = '▶️';
                updateCurrentPlayingButton(false);
            }
        }

        function stopAudio() {
            const masterAudio = document.getElementById('master-audio');
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            masterAudio.pause();
            masterAudio.currentTime = 0;
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Stopped`;
            updateCurrentPlayingButton(false);
        }

        function closeMasterPlayer() {
            const masterPlayer = document.getElementById('master-audio-player');
            const masterAudio = document.getElementById('master-audio');
            
            masterAudio.pause();
            masterPlayer.classList.remove('visible');
            updateCurrentPlayingButton(false);
            
            currentAudioUrl = null;
            currentAudioTitle = null;
            currentAudioType = null;
            currentPlayingIndex = null;
        }

        function updateCurrentPlayingButton(isPlaying) {
            if (currentPlayingIndex !== null) {
                const btn = document.getElementById(`audioBtn-${currentPlayingIndex}`);
                if (btn) {
                    if (isPlaying) {
                        btn.classList.add('playing');
                        btn.innerHTML = '<span>⏸️</span><span>Playing...</span>';
                    } else {
                        btn.classList.remove('playing');
                        btn.innerHTML = '<span>▶️</span><span>Play Audio</span>';
                    }
                }
            }
        }

        function updateAudioProgress() {
            const masterAudio = document.getElementById('master-audio');
            const progressBar = document.getElementById('audio-progress-bar');
            const timeDisplay = document.getElementById('audio-time');
            
            if (masterAudio.duration) {
                const progress = (masterAudio.currentTime / masterAudio.duration) * 100;
                progressBar.style.width = progress + '%';
                
                const currentTime = formatTime(masterAudio.currentTime);
                const totalTime = formatTime(masterAudio.duration);
                timeDisplay.textContent = `${currentTime} / ${totalTime}`;
            }
        }

        function seekAudio(event) {
            const masterAudio = document.getElementById('master-audio');
            const progressContainer = event.currentTarget;
            const rect = progressContainer.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            
            if (masterAudio.duration) {
                masterAudio.currentTime = percent * masterAudio.duration;
            }
        }

        function onAudioLoaded() {
            const audioMeta = document.getElementById('audio-meta');
            const masterAudio = document.getElementById('master-audio');
            
            if (masterAudio.duration) {
                const duration = formatTime(masterAudio.duration);
                audioMeta.textContent = `${currentAudioType} • Duration: ${duration}`;
            }
        }

        function onAudioEnded() {
            const playBtn = document.getElementById('master-play-btn');
            const audioMeta = document.getElementById('audio-meta');
            
            playBtn.textContent = '▶️';
            audioMeta.textContent = `${currentAudioType} • Finished`;
            updateCurrentPlayingButton(false);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // AI Chat State Management
        let chatState = {
            isInitialized: false,
            isProcessing: false,
            conversation: [],
            selectedModel: 'llama3.2:3b',
            selectedLanguage: 'auto',
            lastQuery: '',
            appliedFilters: {},
            // Follow-up question tracking
            lastSearchResults: [],
            lastSearchSubject: '',
            lastSearchKeywords: [],
            // Voice recording state
            isRecording: false,
            isTranscribing: false,
            isListening: false,
            mediaStream: null,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            vadInterval: null,
            silenceTimeout: null,
            lastSpeechTime: 0
        };

        // Voice variables removed - now using unified enhanced system with currentFilters, currentRecords, etc.

        // AI Chat Feature Initialization
        async function initializeVoiceFeatures() {
            if (chatState.isInitialized) return;
            
            console.log('[Chat] Initializing AI chat features...');
            updateAIStatus('Initializing...');
            
            try {
                // Initialize multi-tag filtering system
                clearAllTagFilters();
                
                // Initialize STT features
                
                updateAIStatus('Ready to answer questions!');
                
                chatState.isInitialized = true;
                
                // Load initial records for voice tab
                await loadVoiceRecords(true);
                
                console.log('[Chat] AI chat features initialized successfully with multi-tag system');
                
            } catch (error) {
                console.error('[Chat] Initialization failed:', error);
                updateAIStatus('AI chat unavailable');
            }
        }


        async function loadVoiceSettings() {
            try {
                // Load available voices from backend
                const response = await fetch('/api/voice/voices');
                const data = await response.json();
                
                if (data.voices) {
                    voiceState.availableVoices = data.voices;
                    populateVoiceSelect();
                }
                
                // NOTE: Record types are now loaded by loadActualRecordTypes() in main app initialization
                
            } catch (error) {
                console.warn('[Voice] Could not load voice settings:', error);
                // Set default voices if API fails
                voiceState.availableVoices = [
                    { id: 'female_1', name: 'Female Voice 1', engine: 'TTS' },
                    { id: 'male_1', name: 'Male Voice 1', engine: 'TTS' }
                ];
                populateVoiceSelect();
            }
        }

        function populateVoiceSelect() {
            const select = document.getElementById('voice-style-select');
            
            // Keep existing options if populated (since we set them manually)
            if (select.children.length > 0) {
                // Just set the correct default value
                select.value = voiceState.selectedVoice;
                return;
            }
            
            // Fallback: populate from API if no options exist
            voiceState.availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = `${voice.name} (${voice.engine})`;
                select.appendChild(option);
            });
            
            // Set default voice to Edge if available
            select.value = voiceState.selectedVoice;
        }

        // DEPRECATED: loadVoiceRecordTypes() - now handled by loadActualRecordTypes() in main app init
        // async function loadVoiceRecordTypes() { ... }

        // DEPRECATED: populateVoiceRecordTypeFilter() - now handled by populateAllRecordTypeDropdowns()
        // function populateVoiceRecordTypeFilter(recordTypes) { ... }

        function updateAIStatus(main) {
            document.getElementById('ai-status-text').textContent = main;
        }

        // Chat Input Functions
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize textarea
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('ai-chat-input');
            if (textarea) {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 200) + 'px';
                });
            }
        });

        async function sendChatMessage() {
            const input = document.getElementById('ai-chat-input');
            const question = input.value.trim();
            
            if (!question || chatState.isProcessing) {
                return;
            }
            
            // Clear input and disable send button temporarily
            input.value = '';
            input.style.height = '60px'; // Reset textarea height
            const sendBtn = document.getElementById('ai-chat-send-btn');
            sendBtn.disabled = true;
            
            try {
                // Add user message to conversation immediately
                addToConversation('user', question);
                
                // Update selected model and voice
                chatState.selectedModel = document.getElementById('ai-model-select').value;
                chatState.selectedLanguage = document.getElementById('stt-language').value;
                
                await processTextWithAI(question);
            } catch (error) {
                console.error('[Chat] Error processing message:', error);
                updateAIStatus('Error occurred');
                addToConversation('system', `Error: ${error.message}`);
            } finally {
                // Re-enable send button and ensure input is ready
                sendBtn.disabled = false;
                ensureChatInputReady();
            }
        }

        // AI Processing Functions

        async function processTextWithAI(text) {
            try {
                updateAIStatus('Analyzing question...');
                chatState.isProcessing = true;
                
                // Determine if this is a follow-up question or new subject
                const isFollowUp = await detectFollowUpQuestion(text);
                
                if (isFollowUp && chatState.lastSearchResults.length > 0) {
                    updateAIStatus('Processing follow-up with existing data...');
                    await processFollowUpQuestion(text);
                } else {
                    updateAIStatus('Searching for new information...');
                    await processNewQuestion(text);
                }
                
                updateAIStatus('Ready to answer questions!');
                
            } catch (error) {
                console.error('[Chat] AI processing error:', error);
                updateAIStatus('AI processing failed');
                addToConversation('system', `AI Error: ${error.message}`);
            } finally {
                chatState.isProcessing = false;
            }
        }

        async function detectFollowUpQuestion(text) {
            // If no previous conversation, definitely not a follow-up
            if (chatState.conversation.length === 0 || !chatState.lastSearchSubject) {
                return false;
            }

            const lowerText = text.toLowerCase();
            
            // Obvious new subject indicators
            const newSubjectPatterns = [
                /^(find|search|show|get|tell me about|what is|who is|where is|when is|how is)/,
                /recipe for/,
                /workout for/,
                /video about/,
                /image of/,
                /post about/,
                /information about/,
                /data on/
            ];
            
            if (newSubjectPatterns.some(pattern => pattern.test(lowerText))) {
                // Check if it mentions the same subject as before
                const lastSubjectWords = chatState.lastSearchSubject.toLowerCase().split(' ');
                const hasCommonSubject = lastSubjectWords.some(word => 
                    word.length > 3 && lowerText.includes(word)
                );
                
                if (!hasCommonSubject) {
                    return false; // Definitely new subject
                }
            }
            
            // Follow-up indicators
            const followUpPatterns = [
                /^(how many|how much|what about|what else|also|and|more|any other|tell me more)/,
                /^(where|when|why|who|which|whose)/,
                /(more|additional|other|else|further|next)/,
                /^(can you|could you|please)/
            ];
            
            if (followUpPatterns.some(pattern => pattern.test(lowerText))) {
                return true;
            }
            
            // Check for context continuity
            const lastSearchWords = chatState.lastSearchKeywords;
            if (lastSearchWords.length > 0) {
                const hasContextOverlap = lastSearchWords.some(keyword => 
                    lowerText.includes(keyword.toLowerCase())
                );
                
                if (hasContextOverlap) {
                    return true;
                }
            }
            
            return false;
        }

        async function processFollowUpQuestion(text) {
            console.log('[Chat] Processing follow-up question with existing data');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 20000);
            
            try {
                // Send the question with context and existing search results
                const response = await fetch('/api/voice/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: false, // Don't perform new search
                        is_follow_up: true,
                        conversation_context: chatState.conversation.slice(-4), // Last 4 messages for context
                        existing_search_results: chatState.lastSearchResults
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`Follow-up processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] Follow-up Response:', aiData);
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: chatState.lastSearchResults,
                    searchResults: chatState.lastSearchResults.length,
                    isFollowUp: true
                });
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                throw fetchError;
            }
        }

        async function processNewQuestion(text) {
            console.log('[Chat] Processing new question with fresh search');
            
            // Create AbortController for timeout management
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                console.log('[Chat] Request aborted due to timeout');
            }, 25000);
            
            try {
                // Send to chat endpoint for new search
                const response = await fetch('/api/voice/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: chatState.selectedModel,
                        return_audio: false,
                        include_filter_analysis: true,
                        is_follow_up: false
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    if (response.status === 408 || response.status === 504) {
                        throw new Error('Request timeout - service may be busy, please try again');
                    }
                    throw new Error(`AI processing failed: ${response.status}`);
                }
                
                const aiData = await response.json();
                
                if (!aiData.response_text) {
                    throw new Error('No response generated');
                }
                
                console.log('[Chat] New Question Response:', aiData);
                
                // Store search results and subject for future follow-ups
                chatState.lastSearchResults = aiData.search_results || [];
                chatState.lastSearchSubject = aiData.extracted_subject || text;
                chatState.lastSearchKeywords = aiData.extracted_keywords || [];
                
                // Use applied filters from backend (enhanced RAG service)
                const appliedFilters = aiData.applied_filters || {};
                
                console.log('[Chat] AI found search results:', aiData.search_results?.length || 0);
                console.log('[Chat] AI applied filters:', appliedFilters);
                
                // If AI found specific search results, display them directly
                if (aiData.search_results && aiData.search_results.length > 0) {
                    console.log('[Chat] 🎯 Displaying AI search results directly');
                    displayAISearchResults(aiData.search_results, appliedFilters);
                    // Update filters display but don't reload records (use AI results instead)
                    displayAppliedFilters(appliedFilters, aiData.sources);
                } else {
                    console.log('[Chat] 📋 No AI search results, using filter-based search');
                    // Apply the filters to the UI and reload records
                    await applyAIFilters(appliedFilters, aiData.sources);
                }
                
                // Add AI response to conversation
                addToConversation('assistant', aiData.response_text, {
                    sources: aiData.sources,
                    searchResults: aiData.search_results_count,
                    filtersApplied: appliedFilters,
                    isFollowUp: false
                });
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                
                if (fetchError.name === 'AbortError') {
                    throw new Error('Request timeout - please try again in a moment');
                }
                
                if (fetchError.message.includes('Failed to fetch')) {
                    throw new Error('Connection failed - please check your connection and try again');
                }
                
                throw fetchError;
            }
        }



        function displayAISearchResults(searchResults, appliedFilters) {
            console.log(`[Chat AI] 🎯 Displaying ${searchResults.length} exact AI search results`);
            
            // Update global state to match AI results
            currentRecords = searchResults;
            currentPage = 1;
            hasMoreRecords = false; // AI results are finite
            
            // Update the interface with AI filters
            Object.assign(currentFilters, appliedFilters);
            
            // Update UI elements
            if (appliedFilters.search) {
                document.getElementById('voice-search-input').value = appliedFilters.search;
            }
            if (appliedFilters.recordType) {
                document.getElementById('voice-record-type-filter').value = appliedFilters.recordType;
            }
            if (appliedFilters.sortBy) {
                document.getElementById('voice-sort-by').value = appliedFilters.sortBy;
            }
            
            // Handle AI multi-tag filters
            if (appliedFilters.tags && appliedFilters.tagsMatchMode) {
                currentFilters.aiTags = appliedFilters.tags;
                currentFilters.aiTagsMatchMode = appliedFilters.tagsMatchMode;
            }
            
            // Display the exact results the AI found
            displayVoiceRecords(searchResults, false);
            
            // Update pagination info
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${searchResults.length} AI search results • Page 1`;
            
            // Hide load more button since AI results are finite
            document.getElementById('voice-load-more-container').classList.add('hidden');
            
            // Extract and update tag summary if available
            const allTags = [];
            searchResults.forEach(record => {
                const tags = record.data?.basic?.tagItems || [];
                tags.forEach(tag => {
                    const existing = allTags.find(t => t.tag === tag);
                    if (existing) {
                        existing.count++;
                    } else {
                        allTags.push({ tag, count: 1 });
                    }
                });
            });
            
            if (allTags.length > 0) {
                updateVoiceTagFilter(allTags);
            }
            
            console.log(`[Chat AI] ✅ Successfully displayed ${searchResults.length} AI search results`);
        }

        async function applyAIFilters(filters, sources = []) {
            // Update the enhanced unified filters state
            Object.assign(currentFilters, filters);
            
            // Update the UI elements for basic filters
            if (filters.search) {
                document.getElementById('voice-search-input').value = filters.search;
            }
            if (filters.recordType) {
                document.getElementById('voice-record-type-filter').value = filters.recordType;
            }
            if (filters.sortBy) {
                document.getElementById('voice-sort-by').value = filters.sortBy;
            }
            
            // Handle enhanced multi-tag filtering from AI
            if (filters.tags && filters.tagsMatchMode) {
                console.log(`[Enhanced AI] Applying multi-tag filter: ${filters.tags} (${filters.tagsMatchMode} mode)`);
                // Store the AI-applied tag filters separately since UI doesn't support multi-tag
                currentFilters.aiTags = filters.tags;
                currentFilters.aiTagsMatchMode = filters.tagsMatchMode;
                
                // Clear the single tag filter since we're using AI multi-tag
                currentFilters.tag = '';
                document.getElementById('voice-tag-filter').value = '';
            } else if (filters.tag) {
                // Handle single tag from regular filtering
                currentFilters.tag = filters.tag;
                if (document.getElementById('voice-tag-filter')) {
                    document.getElementById('voice-tag-filter').value = filters.tag;
                }
            }
            
            // Update applied filters display
            displayAppliedFilters(filters, sources);
            
            // Reload records with new filters using enhanced system
            await loadVoiceRecords(true);
            
            console.log('[Enhanced AI] Applied AI filters:', filters);
        }

        function displayAppliedFilters(filters, sources) {
            const display = document.getElementById('applied-filters-display');
            const container = document.getElementById('filter-chips-container');
            const rationale = document.getElementById('filter-rationale');
            
            // Clear existing chips
            container.innerHTML = '';
            
            // Create filter chips
            let hasFilters = false;
            if (filters.search) {
                addFilterChip(container, 'Search', filters.search);
                hasFilters = true;
            }
            if (filters.recordType) {
                addFilterChip(container, 'Type', filters.recordType);
                hasFilters = true;
            }
            if (filters.sortBy && filters.sortBy !== 'inArweaveBlock:desc') {
                addFilterChip(container, 'Sort', filters.sortBy.replace(':', ' '));
                hasFilters = true;
            }
            // Show manual multi-tag filters first (highest priority)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                const tagMode = currentFilters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `Tags (${tagMode})`, currentFilters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show AI-applied filters if no manual filters
            else if (filters.tags && filters.tagsMatchMode) {
                const tagMode = filters.tagsMatchMode === 'AND' ? 'ALL' : 'ANY';
                addFilterChip(container, `AI Tags (${tagMode})`, filters.tags.replace(/,/g, ', '));
                hasFilters = true;
            } 
            // Show legacy single tag filter (fallback)
            else if (filters.tag) {
                addFilterChip(container, 'Tag', filters.tag);
                hasFilters = true;
            }
            
            if (hasFilters) {
                display.classList.remove('hidden');
                
                // Use rationale from backend or generate fallback
                const rationaleText = filters.rationale || `AI applied these filters automatically based on your query.`;
                rationale.textContent = rationaleText;
            } else {
                display.classList.add('hidden');
            }
        }

        function addFilterChip(container, label, value) {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';
            chip.textContent = `${label}: ${value}`;
            container.appendChild(chip);
        }

        // No audio playback needed for text chat

        // Conversation Management
        function addToConversation(role, content, metadata = {}) {
            const message = {
                role,
                content,
                timestamp: new Date().toISOString(),
                ...metadata
            };
            
            chatState.conversation.push(message);
            updateConversationDisplay();
        }

        function updateConversationDisplay() {
            const container = document.getElementById('chat-messages');
            const emptyState = document.getElementById('chat-empty-state');
            
            if (chatState.conversation.length === 0) {
                emptyState.style.display = 'flex';
                container.innerHTML = '';
                return;
            }
            
            emptyState.style.display = 'none';
            container.innerHTML = '';
            
            // Show all messages
            chatState.conversation.forEach((message, index) => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}`;
                
                const avatar = getMessageAvatar(message.role);
                const timestamp = new Date(message.timestamp).toLocaleTimeString();
                
                let sourcesHtml = '';
                if (message.role === 'assistant' && message.sources && message.sources.length > 0) {
                    sourcesHtml = `
                        <div class="message-sources">
                            <span class="source-count">📚 ${message.sources.length} sources found</span>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-content">
                        <div class="message-text">${escapeHtml(message.content)}</div>
                        ${sourcesHtml}
                        <div class="message-meta">
                            <span class="message-timestamp">${timestamp}</span>
                        </div>
                    </div>
                `;
                
                container.appendChild(messageDiv);
            });
            
            // Scroll to bottom
            const chatConversation = document.getElementById('chat-conversation');
            setTimeout(() => {
                chatConversation.scrollTop = chatConversation.scrollHeight;
            }, 10);
        }

        function ensureChatInputReady() {
            const chatInput = document.getElementById('ai-chat-input');
            const sendBtn = document.getElementById('ai-chat-send-btn');
            
            if (chatInput) {
                chatInput.disabled = false;
                chatInput.removeAttribute('readonly');
                chatInput.removeAttribute('hidden');
                chatInput.classList.remove('hidden');
                
                // Only reset dimensions if they're problematic
                if (chatInput.offsetHeight === 0) {
                    chatInput.style.height = '60px';
                }
            }
            
            if (sendBtn) {
                sendBtn.disabled = chatState.isProcessing;
                sendBtn.removeAttribute('hidden');
                sendBtn.classList.remove('hidden');
            }
        }

        function getMessageAvatar(role) {
            switch (role) {
                case 'user': return '👤';
                case 'assistant': return '🤖';
                case 'system': return '⚠️';
                default: return '💬';
            }
        }

        // STT (Speech-to-Text) Functions
        
        // Voice Activity Detection configuration
        const VAD_CONFIG = {
            silenceThreshold: 0.01,
            silenceTimeoutMs: 2000,
            minRecordingMs: 1500,
            volumeThreshold: 0.12,
        };

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator?.mediaDevices?.getUserMedia);
            const hasMediaRecorder = typeof MediaRecorder !== 'undefined';
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            
            return hasMediaDevices && hasMediaRecorder && hasAudioContext;
        }

        async function toggleRecording() {
            if (chatState.isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }

        async function startRecording() {
            if (!checkBrowserSupport()) {
                updateAIStatus('Browser does not support voice recording');
                return;
            }

            try {
                chatState.mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                await setupVAD(chatState.mediaStream);

                chatState.mediaRecorder = new MediaRecorder(chatState.mediaStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                chatState.audioChunks = [];

                chatState.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chatState.audioChunks.push(event.data);
                    }
                };

                chatState.mediaRecorder.onstop = async () => {
                    if (chatState.audioChunks.length > 0) {
                        const audioBlob = new Blob(chatState.audioChunks, { type: 'audio/webm' });
                        await processAudioBlob(audioBlob);
                    }
                };

                chatState.mediaRecorder.start();
                chatState.isRecording = true;
                updateMicrophoneButton();
                updateAIStatus('Recording... Speak now');

            } catch (error) {
                console.error('Error starting recording:', error);
                updateAIStatus('Microphone access denied');
                cleanupRecording();
            }
        }

        async function setupVAD(stream) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            chatState.audioContext = new AudioContext();

            if (chatState.audioContext.state === 'suspended') {
                await chatState.audioContext.resume();
            }

            chatState.analyser = chatState.audioContext.createAnalyser();
            chatState.analyser.fftSize = 512;

            const source = chatState.audioContext.createMediaStreamSource(stream);
            source.connect(chatState.analyser);

            const bufferLength = chatState.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const monitorAudio = () => {
                if (!chatState.analyser || !chatState.isRecording) return;

                chatState.analyser.getByteFrequencyData(dataArray);

                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / bufferLength) / 255;

                const now = Date.now();

                if (rms > VAD_CONFIG.volumeThreshold) {
                    chatState.lastSpeechTime = now;
                    chatState.isListening = true;
                    updateMicrophoneButton();

                    if (chatState.silenceTimeout) {
                        clearTimeout(chatState.silenceTimeout);
                        chatState.silenceTimeout = null;
                    }
                } else {
                    const recordingDuration = now - (chatState.lastSpeechTime || now);

                    if (recordingDuration > VAD_CONFIG.minRecordingMs && chatState.lastSpeechTime > 0) {
                        if (!chatState.silenceTimeout) {
                            chatState.silenceTimeout = setTimeout(() => {
                                stopRecording();
                            }, VAD_CONFIG.silenceTimeoutMs);
                        }
                    }

                    chatState.isListening = false;
                    updateMicrophoneButton();
                }
            };

            chatState.vadInterval = setInterval(monitorAudio, 100);
        }

        function stopRecording() {
            if (chatState.mediaRecorder && chatState.isRecording) {
                chatState.mediaRecorder.stop();
            }
            
            chatState.isRecording = false;
            chatState.isListening = false;
            updateMicrophoneButton();
            cleanupVAD();

            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            updateAIStatus('Processing speech...');
        }

        function cleanupVAD() {
            if (chatState.vadInterval) {
                clearInterval(chatState.vadInterval);
                chatState.vadInterval = null;
            }

            if (chatState.silenceTimeout) {
                clearTimeout(chatState.silenceTimeout);
                chatState.silenceTimeout = null;
            }

            if (chatState.analyser) {
                chatState.analyser = null;
            }
        }

        function cleanupRecording() {
            cleanupVAD();
            
            if (chatState.mediaStream) {
                chatState.mediaStream.getTracks().forEach(track => track.stop());
                chatState.mediaStream = null;
            }

            if (chatState.audioContext && chatState.audioContext.state !== 'closed') {
                chatState.audioContext.close();
                chatState.audioContext = null;
            }

            chatState.isRecording = false;
            chatState.isTranscribing = false;
            chatState.isListening = false;
            updateMicrophoneButton();
        }

        async function processAudioBlob(audioBlob) {
            try {
                chatState.isTranscribing = true;
                updateMicrophoneButton();
                updateAIStatus('Transcribing speech...');

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                
                // Add language if specified
                const language = document.getElementById('stt-language').value;
                if (language && language !== 'auto') {
                    formData.append('language', language);
                }

                const response = await fetch('/api/voice/transcribe', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Speech transcription failed');
                }

                const data = await response.json();
                const transcribedText = data.text?.trim();

                if (!transcribedText) {
                    updateAIStatus('No speech detected. Try again.');
                    return;
                }

                console.log('[STT] Transcribed:', transcribedText);

                // Put transcribed text in the input field
                const input = document.getElementById('ai-chat-input');
                input.value = transcribedText;
                input.style.height = 'auto';
                input.style.height = Math.min(input.scrollHeight, 200) + 'px';

                updateAIStatus('Speech transcribed! Click "Ask AI" or press Enter');

            } catch (error) {
                console.error('Transcription error:', error);
                updateAIStatus('Speech transcription failed');
            } finally {
                chatState.isTranscribing = false;
                updateMicrophoneButton();
            }
        }

        function updateMicrophoneButton() {
            const micBtn = document.getElementById('mic-btn');
            
            // Reset all classes
            micBtn.classList.remove('recording', 'listening', 'transcribing');
            
            if (chatState.isTranscribing) {
                micBtn.classList.add('transcribing');
                micBtn.innerHTML = '🔄';
                micBtn.title = 'Processing speech...';
            } else if (chatState.isRecording) {
                if (chatState.isListening) {
                    micBtn.classList.add('listening');
                    micBtn.innerHTML = '🎤';
                    micBtn.title = 'Listening... (click to stop)';
                } else {
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = '🔴';
                    micBtn.title = 'Recording... (click to stop)';
                }
            } else {
                micBtn.innerHTML = '🎤';
                micBtn.title = 'Click to record voice message';
            }
        }

        function clearConversation() {
            // Stop any current recording
            if (chatState.isRecording) {
                stopRecording();
            }
            
            // Clear conversation array
            chatState.conversation = [];
            
            // Clear follow-up tracking state
            chatState.lastSearchResults = [];
            chatState.lastSearchSubject = '';
            chatState.lastSearchKeywords = [];
            
            // Update display
            updateConversationDisplay();
            
            // Clear any applied filters
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            // Ensure input is ready
            ensureChatInputReady();
            
            updateAIStatus('Ready to answer questions!');
        }

        // No conversation mode needed for text chat

        // Voice Filtering Functions
        // ====== ENHANCED VOICE FILTER FUNCTIONS ======
        
        // Multi-Tag Filter Management
        let tagFilterIndex = 0;
        
        function addTagFilter() {
            tagFilterIndex++;
            const container = document.getElementById('tag-filters-container');
            
            const newRow = document.createElement('div');
            newRow.className = 'tag-filter-row';
            newRow.setAttribute('data-tag-index', tagFilterIndex);
            
            newRow.innerHTML = `
                <select class="tag-filter-select" onchange="onTagFilterChange(${tagFilterIndex})" data-tag-index="${tagFilterIndex}">
                    <option value="">Select a tag...</option>
                </select>
                <button type="button" class="remove-tag-btn" onclick="removeTagFilter(${tagFilterIndex})" title="Remove this tag filter">×</button>
            `;
            
            container.appendChild(newRow);
            updateAllTagDropdowns(); // This will handle compact styling
            console.log('[Multi-Tag] Added tag filter', tagFilterIndex, 'Total filters:', document.querySelectorAll('.tag-filter-select').length);
        }
        
        function removeTagFilter(index) {
            const row = document.querySelector(`[data-tag-index="${index}"]`);
            if (row) {
                row.remove();
                updateAllTagDropdowns(); // This will handle compact styling
                applyVoiceFilters();
                console.log('[Multi-Tag] Removed tag filter', index, 'Remaining filters:', document.querySelectorAll('.tag-filter-select').length);
            }
        }
        
        function onTagFilterChange(index) {
            const select = document.querySelector(`[data-tag-index="${index}"] .tag-filter-select`);
            const selectedValue = select ? select.value : 'NOT_FOUND';
            console.log(`[Multi-Tag] Tag filter ${index} changed to: "${selectedValue}"`);
            
            // Debug: show all current selections before update
            const currentSelections = getSelectedTags();
            console.log(`[Multi-Tag] All current selections before update:`, currentSelections);
            
            updateAllTagDropdowns();
            
            // Debug: show all selections after update
            const updatedSelections = getSelectedTags();
            console.log(`[Multi-Tag] All selections after update:`, updatedSelections);
            
            applyVoiceFilters();
        }
        
        function getSelectedTags() {
            const selects = document.querySelectorAll('.tag-filter-select');
            const selectedTags = [];
            
            selects.forEach(select => {
                if (select.value && select.value.trim()) {
                    selectedTags.push(select.value.trim());
                }
            });
            
            return selectedTags;
        }
        
        function updateAllTagDropdowns() {
            const selects = document.querySelectorAll('.tag-filter-select');
            const container = document.getElementById('tag-filters-container');
            
            // Store current values before clearing dropdowns
            const currentValues = [];
            selects.forEach(select => {
                currentValues.push({
                    index: parseInt(select.getAttribute('data-tag-index')),
                    value: select.value
                });
            });
            
            // Add compact styling when there are many tag filters
            if (selects.length >= 3) {
                container.classList.add('has-many-tags');
            } else {
                container.classList.remove('has-many-tags');
            }
            
            // Get all currently selected tags (exclude empty values)
            const allSelectedTags = currentValues
                .filter(item => item.value && item.value.trim())
                .map(item => item.value.trim());
            
            selects.forEach((select, selectIndex) => {
                const selectTagIndex = parseInt(select.getAttribute('data-tag-index'));
                const currentValue = currentValues.find(item => item.index === selectTagIndex)?.value || '';
                
                // Clear and repopulate options
                select.innerHTML = '<option value="">Select a tag...</option>';
                
                if (availableTags && availableTags.length > 0) {
                    availableTags.forEach(tag => {
                        // Add this tag if:
                        // 1. It's not selected by any other dropdown, OR
                        // 2. It's the current value of THIS dropdown
                        const isSelectedByOthers = allSelectedTags.some(selectedTag => 
                            selectedTag === tag.tag && selectedTag !== currentValue
                        );
                        
                        if (!isSelectedByOthers) {
                            const option = document.createElement('option');
                            option.value = tag.tag;
                            option.textContent = `${tag.tag} (${tag.count})`;
                            select.appendChild(option);
                        }
                    });
                }
                
                // Restore the current value (this will work now because we rebuilt the options)
                if (currentValue && currentValue.trim()) {
                    select.value = currentValue;
                    console.log(`[Multi-Tag] Restored value "${currentValue}" for select ${selectTagIndex}`);
                }
            });
            
            // Get final selected tags for logging
            const finalSelectedTags = getSelectedTags();
            console.log('[Multi-Tag] Updated dropdowns. Selected tags:', finalSelectedTags, 'Compact mode:', selects.length >= 3);
        }
        
        function clearAllTagFilters() {
            // Reset to single empty tag filter
            const container = document.getElementById('tag-filters-container');
            
            // Remove compact styling
            container.classList.remove('has-many-tags');
            
            container.innerHTML = `
                <div class="tag-filter-row" data-tag-index="0">
                    <select class="tag-filter-select" onchange="onTagFilterChange(0)" data-tag-index="0">
                        <option value="">Select a tag...</option>
                    </select>
                    <button type="button" class="add-tag-btn" onclick="addTagFilter()" title="Add another tag filter">+</button>
                </div>
            `;
            
            // Reset the match mode
            document.getElementById('tag-match-mode').value = 'OR';
            
            tagFilterIndex = 0;
            updateAllTagDropdowns(); // This will ensure compact styling stays off
            console.log('[Multi-Tag] Cleared all tag filters');
        }
        
        function applyVoiceFilters() {
            collectVoiceFilters();
            loadVoiceRecords(true);
        }

        function collectVoiceFilters() {
            // Sync header search to hidden search input
            const headerSearch = document.getElementById('header-search-input');
            const hiddenSearch = document.getElementById('voice-search-input');
            if (headerSearch && hiddenSearch) {
                hiddenSearch.value = headerSearch.value;
            }
            
            // Update the main currentFilters object to work with enhanced system
            currentFilters.search = document.getElementById('voice-search-input').value.trim();
            currentFilters.recordType = document.getElementById('voice-record-type-filter').value;
            currentFilters.sortBy = document.getElementById('voice-sort-by').value;
            currentFilters.resolveDepth = parseInt(document.getElementById('voice-resolve-depth').value) || 2;
            currentFilters.dateStart = document.getElementById('voice-date-start').value;
            currentFilters.dateEnd = document.getElementById('voice-date-end').value;
            currentFilters.includeSigs = document.getElementById('voice-include-sigs-toggle').classList.contains('active');
            currentFilters.includePubKeys = document.getElementById('voice-include-pubkeys-toggle').classList.contains('active');
            
            // Collect multi-tag filters (prioritize user manual selection over AI)
            const selectedTags = getSelectedTags();
            const tagMatchMode = document.getElementById('tag-match-mode').value;
            
            console.log(`[Filters] DEBUG: getSelectedTags() returned:`, selectedTags);
            console.log(`[Filters] DEBUG: tagMatchMode is:`, tagMatchMode);
            
            if (selectedTags.length > 0) {
                // Use manual multi-tag selection
                currentFilters.tags = selectedTags.join(',');
                currentFilters.tagsMatchMode = tagMatchMode;
                currentFilters.tag = ''; // Clear legacy single tag
                
                // Clear AI tags since user is manually filtering
                delete currentFilters.aiTags;
                delete currentFilters.aiTagsMatchMode;
                
                console.log('[Filters] ✅ Using manual multi-tag filters:', selectedTags, 'mode:', tagMatchMode);
                console.log('[Filters] ✅ Final tags parameter:', currentFilters.tags);
            } else {
                // No manual tags selected, keep AI tags if they exist
                if (!currentFilters.aiTags) {
                    currentFilters.tags = '';
                    currentFilters.tagsMatchMode = '';
                    currentFilters.tag = '';
                }
                console.log('[Filters] ❌ No manual tags, keeping AI tags:', currentFilters.aiTags);
            }
            
            // Update debug setting
            showDebugInfo = document.getElementById('show-template-debug')?.checked || false;
            
            console.log('[Filters] Updated filters:', currentFilters);
        }

        function handleVoiceSearchKeyup(event) {
            if (event.key === 'Enter') {
                applyVoiceFilters();
            }
        }

        function clearVoiceFilters() {
            document.getElementById('voice-search-input').value = '';
            document.getElementById('voice-record-type-filter').value = '';
            document.getElementById('voice-sort-by').value = 'date:desc';
            document.getElementById('voice-resolve-depth').value = '2';
            document.getElementById('voice-date-start').value = '';
            document.getElementById('voice-date-end').value = '';
            document.getElementById('voice-include-sigs-toggle').classList.remove('active');
            document.getElementById('voice-include-pubkeys-toggle').classList.remove('active');
            
            // Clear multi-tag filters
            clearAllTagFilters();
            
            // Clear AI-applied multi-tag filters
            delete currentFilters.aiTags;
            delete currentFilters.aiTagsMatchMode;
            delete currentFilters.tags;
            delete currentFilters.tagsMatchMode;
            delete currentFilters.tag;
            
            // Clear applied filters display
            document.getElementById('applied-filters-display').classList.add('hidden');
            
            applyVoiceFilters();
        }

        function toggleVoiceSwitch(elementId) {
            document.getElementById(elementId).classList.toggle('active');
        }

        // ====== ENHANCED VOICE RECORDS LOADING WITH DYNAMIC TEMPLATES ======
        
        async function loadVoiceRecords(reset = false) {
            if (isLoading) return;
            
            try {
                isLoading = true;
                
                if (reset) {
                    currentPage = 1;
                    currentRecords = [];
                    document.getElementById('voice-records-grid').innerHTML = '';
                }
                
                document.getElementById('voice-loading-indicator').classList.remove('hidden');
                
                const params = buildVoiceApiParams();
                console.log(`[Enhanced Records] Loading with resolveDepth=${currentFilters.resolveDepth}, debug=${showDebugInfo}`);
                
                const response = await fetch(`/api/records?${params}`);
                const data = await response.json();
                
                if (data.records) {
                    if (reset) {
                        currentRecords = data.records;
                    } else {
                        currentRecords = [...currentRecords, ...data.records];
                    }
                    
                    hasMoreRecords = data.totalPages > currentPage;
                    displayVoiceRecords(data.records, !reset);
                    updateVoicePaginationInfo(data);
                    updateVoiceTagFilter(data.tagSummary);
                    
                    // Log template analysis for first record if debug is on
                    if (showDebugInfo && data.records.length > 0) {
                        const firstRecord = data.records[0];
                        const templates = analyzeRecordTemplates(firstRecord);
                        console.log(`[Enhanced Records] First record uses templates:`, templates);
                    }
                } else {
                    showVoiceNoResults();
                }
                
                updateVoiceLoadMoreButton();
                
            } catch (error) {
                console.error('[Enhanced Records] Error loading records:', error);
                showVoiceNoResults();
            } finally {
                isLoading = false;
                document.getElementById('voice-loading-indicator').classList.add('hidden');
            }
        }

        function buildVoiceApiParams() {
            const params = new URLSearchParams({
                limit: '12',
                page: currentPage.toString(),
                sortBy: currentFilters.sortBy,
                resolveDepth: currentFilters.resolveDepth.toString(),
                summarizeTags: 'true',
                tagCount: '100',
                includeSigs: currentFilters.includeSigs.toString(),
                includePubKeys: currentFilters.includePubKeys.toString()
            });

            if (currentFilters.search) {
                params.append('search', currentFilters.search.trim());
            }
            
            if (currentFilters.recordType) {
                params.append('recordType', currentFilters.recordType);
            }
            
            if (currentFilters.dateStart) {
                params.append('dateStart', dateToUnixTime(currentFilters.dateStart));
            }
            
            if (currentFilters.dateEnd) {
                params.append('dateEnd', dateToUnixTime(currentFilters.dateEnd));
            }
            
            // Handle tag filters (prioritize manual selection over AI)
            if (currentFilters.tags && currentFilters.tagsMatchMode) {
                // Use manual multi-tag selection (highest priority)
                params.append('tags', currentFilters.tags);
                params.append('tagsMatchMode', currentFilters.tagsMatchMode);
                console.log(`[Enhanced API] Using manual multi-tag filter: ${currentFilters.tags} (${currentFilters.tagsMatchMode})`);
            } else if (currentFilters.aiTags && currentFilters.aiTagsMatchMode) {
                // Use AI-applied multi-tag filters (fallback)
                params.append('tags', currentFilters.aiTags);
                params.append('tagsMatchMode', currentFilters.aiTagsMatchMode);
                console.log(`[Enhanced API] Using AI multi-tag filter: ${currentFilters.aiTags} (${currentFilters.aiTagsMatchMode})`);
            } else if (currentFilters.tag) {
                // Fallback to legacy single tag
                params.append('tags', currentFilters.tag);
                console.log(`[Enhanced API] Using legacy single tag: ${currentFilters.tag}`);
            }

            console.log('[API] Building request with resolveDepth:', currentFilters.resolveDepth);
            return params.toString();
        }

        /**
         * Display voice records using enhanced dynamic template rendering
         */
        function displayVoiceRecords(records, append = false) {
            const grid = document.getElementById('voice-records-grid');
            
            if (!append) {
                grid.innerHTML = '';
            }
            
            const startIndex = currentRecords.length - records.length;
            records.forEach((record, index) => {
                // Use the enhanced createRecordCard function directly
                const card = createRecordCard(record, startIndex + index);
                grid.appendChild(card);
            });
            
            grid.classList.remove('hidden');
            document.getElementById('voice-no-results').classList.add('hidden');
            
            console.log(`[Enhanced Display] Rendered ${records.length} records with dynamic templates`);
        }

        function showVoiceNoResults() {
            document.getElementById('voice-records-grid').classList.add('hidden');
            document.getElementById('voice-no-results').classList.remove('hidden');
        }

        function updateVoicePaginationInfo(data) {
            const info = document.getElementById('voice-pagination-info');
            info.textContent = `Showing ${currentRecords.length} of ${data.totalRecords || 'many'} records • Page ${currentPage}`;
        }

        function updateVoiceTagFilter(tagSummary) {
            if (!tagSummary) return;
            
            // Store available tags globally for multi-tag system
            availableTags = tagSummary;
            
            // Update legacy single tag filter (hidden, for backward compatibility)
            const legacySelect = document.getElementById('voice-tag-filter');
            if (legacySelect) {
                const currentValue = legacySelect.value;
                legacySelect.innerHTML = '<option value="">All Tags</option>';
                
                tagSummary.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.tag;
                    option.textContent = `${tag.tag} (${tag.count})`;
                    legacySelect.appendChild(option);
                });
                
                legacySelect.value = currentValue;
            }
            
            // Update all multi-tag dropdowns
            updateAllTagDropdowns();
            
            console.log('[Multi-Tag] Updated tag filter with', tagSummary.length, 'available tags');
        }

        function updateVoiceLoadMoreButton() {
            const container = document.getElementById('voice-load-more-container');
            const button = document.getElementById('voice-load-more-btn');
            
            if (hasMoreRecords && currentRecords.length > 0) {
                container.classList.remove('hidden');
                button.disabled = isLoading;
                button.textContent = isLoading ? 'Loading...' : 'Load More Records';
            } else {
                container.classList.add('hidden');
            }
        }

        function loadMoreVoiceRecords() {
            if (!hasMoreRecords || isLoading) return;
            currentPage++;
            loadVoiceRecords(false);
        }

                 // Voice-specific text content toggle (for embedded text content)
         async function toggleVoiceTextContent(recordIndex, sourceType, sourceUrl) {
             const textContent = document.getElementById(`voice-textContent-${recordIndex}`);
             const toggleBtn = document.getElementById(`voice-textBtn-${recordIndex}`);
             
             if (textContent.classList.contains('hidden')) {
                 // Show content
                 textContent.classList.remove('hidden');
                 
                 if (sourceType === 'fetch' && sourceUrl) {
                     // Check if we already fetched the content
                     if (!textContent.dataset.fetched) {
                         try {
                             toggleBtn.textContent = '📄 Loading...';
                             toggleBtn.disabled = true;
                             
                             const response = await fetch(sourceUrl);
                             if (!response.ok) {
                                 throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                             }
                             const text = await response.text();
                             
                             textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                             textContent.dataset.fetched = 'true';
                             toggleBtn.textContent = '📄 Hide Full Text';
                             toggleBtn.disabled = false;
                         } catch (error) {
                             console.error('Error fetching text content:', error);
                             textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                 <strong>Error loading text:</strong><br>
                                 ${escapeHtml(error.message)}<br>
                                 <small>URL: ${escapeHtml(sourceUrl)}</small>
                             </div>`;
                             toggleBtn.textContent = '❌ Failed to Load';
                             toggleBtn.disabled = false;
                         }
                     } else {
                         toggleBtn.textContent = '📄 Hide Full Text';
                     }
                 } else if (sourceType === 'static') {
                     // Static content - just show it
                     const staticContent = textContent.dataset.staticContent;
                     if (staticContent) {
                         textContent.innerHTML = staticContent;
                     }
                     toggleBtn.textContent = '📄 Hide Full Text';
                 }
             } else {
                 // Hide content
                 textContent.classList.add('hidden');
                 if (sourceType === 'fetch') {
                     toggleBtn.textContent = '📄 Show Full Text';
                 } else {
                     toggleBtn.textContent = '📄 Show Full Text';
                 }
             }
         }

        // Text content toggle function
        async function toggleTextContent(recordIndex, sourceType, sourceUrl) {
            const textContent = document.getElementById(`textContent-${recordIndex}`);
            const toggleBtn = document.getElementById(`textBtn-${recordIndex}`);
            
            if (textContent.classList.contains('hidden')) {
                // Show content
                textContent.classList.remove('hidden');
                
                if (sourceType === 'fetch' && sourceUrl) {
                    // Check if we already fetched the content
                    if (!textContent.dataset.fetched) {
                        try {
                            toggleBtn.textContent = '📄 Loading...';
                            toggleBtn.disabled = true;
                            
                            const response = await fetch(sourceUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const text = await response.text();
                            
                            textContent.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">${escapeHtml(text)}</div>`;
                            textContent.dataset.fetched = 'true';
                            toggleBtn.textContent = '📄 Hide Full Article';
                            toggleBtn.disabled = false;
                        } catch (error) {
                            console.error('Error fetching text content:', error);
                            textContent.innerHTML = `<div style="color: #dc3545; padding: 10px;">
                                <strong>Error loading article:</strong><br>
                                ${escapeHtml(error.message)}<br>
                                <small>URL: ${escapeHtml(sourceUrl)}</small>
                            </div>`;
                            toggleBtn.textContent = '❌ Failed to Load';
                            toggleBtn.disabled = false;
                        }
                    } else {
                        toggleBtn.textContent = '📄 Hide Full Article';
                    }
                } else if (sourceType === 'static') {
                    // Static content - just show it
                    const staticContent = textContent.dataset.staticContent;
                    if (staticContent) {
                        textContent.innerHTML = staticContent;
                    }
                    toggleBtn.textContent = '📄 Hide Full Text';
                }
            } else {
                // Hide content
                textContent.classList.add('hidden');
                if (sourceType === 'fetch') {
                    toggleBtn.textContent = '📄 Load Full Article';
                } else {
                    toggleBtn.textContent = '📄 Show Full Text';
                }
            }
        }

        // Interface update functions
        function updatePostInterface() {
            const postType = document.getElementById('post-type').value;
            const authorSection = document.getElementById('author-section');
            
            if (postType === 'microblog') {
                authorSection.style.display = 'none';
            } else {
                authorSection.style.display = 'block';
            }
        }

        function updatePostSource() {
            const source = document.getElementById('post-source').value;
            const manualInterface = document.getElementById('manual-post-interface');
            const xInterface = document.getElementById('x-post-interface');
            const publishText = document.getElementById('post-publish-text');
            
            if (source === 'archive-x') {
                manualInterface.classList.add('hidden');
                xInterface.classList.remove('hidden');
                publishText.textContent = '📱 Archive X Post';
            } else {
                manualInterface.classList.remove('hidden');
                xInterface.classList.add('hidden');
                publishText.textContent = '📤 Publish Post';
            }
        }

        function updateVideoInterface() {
            const source = document.getElementById('video-source').value;
            const inputSection = document.getElementById('video-input-section');
            
            switch (source) {
                case 'manual':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'youtube-archive':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="youtube-url">YouTube URL:</label>
                            <input type="url" id="youtube-url" placeholder="https://youtube.com/watch?v=..." required>
                            <button type="button" onclick="archiveYouTubeVideo()" style="margin-top: 10px; width: 100%;">
                                📥 Archive Video & Get Metadata
                            </button>
                        </div>

                        <div id="youtube-progress" class="hidden" style="margin-top: 20px;">
                            <div class="publish-progress">
                                <h4>📥 Archiving YouTube Video...</h4>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="youtube-progress-bar" style="width: 0%;"></div>
                                </div>
                                <div id="youtube-status" style="margin-top: 10px; font-size: 0.9rem;">Initializing...</div>
                            </div>
                        </div>

                        <div id="youtube-preview" class="hidden" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #ff0000;">
                            <h4>🎥 Video Preview</h4>
                            <div id="youtube-thumbnail" style="margin-bottom: 15px;"></div>
                            <div id="youtube-metadata"></div>
                        </div>
                    `;
                    break;
                case 'direct':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-url">Video URL:</label>
                            <input type="url" id="video-url" placeholder="https://example.com/video.mp4">
                        </div>
                    `;
                    break;
                case 'upload':
                    inputSection.innerHTML = `
                        <div class="form-group">
                            <label for="video-file">Upload Video:</label>
                            <input type="file" id="video-file" accept="video/*">
                            <small>Note: Large files may take time to upload</small>
                        </div>
                    `;
                    break;
            }
        }

        // Dynamic ingredient/exercise management
        function addIngredient() {
            const container = document.getElementById('ingredients-container');
            const newRow = document.createElement('div');
            newRow.className = 'ingredient-row';
            newRow.style = 'display: grid; grid-template-columns: 80px 80px 1fr 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Amount" class="ingredient-amount">
                <input type="text" placeholder="Unit" class="ingredient-unit">
                <input type="text" placeholder="Ingredient name" class="ingredient-name">
                <button type="button" onclick="removeIngredient(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeIngredient(button) {
            button.parentElement.remove();
        }

        function addExercise() {
            const container = document.getElementById('exercises-container');
            const newRow = document.createElement('div');
            newRow.className = 'exercise-row';
            newRow.style = 'display: grid; grid-template-columns: 1fr 80px 80px 80px 40px; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <input type="text" placeholder="Exercise name" class="exercise-name">
                <input type="text" placeholder="Sets" class="exercise-sets">
                <input type="text" placeholder="Reps" class="exercise-reps">
                <input type="text" placeholder="Rest(s)" class="exercise-rest">
                <button type="button" onclick="removeExercise(this)">✕</button>
            `;
            container.appendChild(newRow);
        }

        function removeExercise(button) {
            button.parentElement.remove();
        }

        // X Post Scraping Functions
        async function scrapeXPost() {
            const url = document.getElementById('x-post-url').value;
            const statusDiv = document.getElementById('x-post-status');
            const previewDiv = document.getElementById('x-post-preview');
            
            if (!url || (!url.includes('x.com') && !url.includes('twitter.com'))) {
                showXPostStatus('Please enter a valid X/Twitter URL', 'error');
                return;
            }

            try {
                showXPostStatus('🔍 Fetching post data...', 'loading');
                
                const response = await fetch('/api/scrape/x-post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();

                if (response.ok) {
                    displayXPostPreview(data);
                    showXPostStatus('✅ Post data fetched successfully!', 'success');
                } else {
                    showXPostStatus(`❌ Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showXPostStatus(`❌ Network error: ${error.message}`, 'error');
            }
        }

        function displayXPostPreview(data) {
            const previewDiv = document.getElementById('x-post-preview');
            const contentDiv = document.getElementById('x-post-content');
            const metaDiv = document.getElementById('x-post-meta');

            // Store data for publishing
            window.scrapedXPostData = data;

            contentDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">@${data.author}</div>
                <div style="line-height: 1.4;">${data.text}</div>
                ${data.images && data.images.length > 0 ? `
                    <div style="margin-top: 10px;">
                        ${data.images.map(img => `<img src="${img}" style="max-width: 100px; margin-right: 10px; border-radius: 4px;">`).join('')}
                    </div>
                ` : ''}
            `;

            metaDiv.innerHTML = `
                <strong>Original URL:</strong> ${data.url}<br>
                <strong>Date:</strong> ${data.date || 'Unknown'}<br>
                <strong>Images:</strong> ${data.images ? data.images.length : 0}
            `;

            previewDiv.classList.remove('hidden');
        }

        function showXPostStatus(message, type) {
            const statusDiv = document.getElementById('x-post-status');
            statusDiv.className = 'hidden';
            
            if (type === 'error') {
                statusDiv.className = 'error-message';
            } else if (type === 'success') {
                statusDiv.className = 'success-message';
            } else {
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.style.border = '1px solid #2196f3';
            }
            
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden');
        }

        // YouTube Video Archiving Functions
        async function archiveYouTubeVideo() {
            const url = document.getElementById('youtube-url').value;
            const progressDiv = document.getElementById('youtube-progress');
            const previewDiv = document.getElementById('youtube-preview');
            
            if (!url || (!url.includes('youtube.com') && !url.includes('youtu.be'))) {
                alert('Please enter a valid YouTube URL');
                return;
            }

            try {
                progressDiv.classList.remove('hidden');
                updateYouTubeProgress(10, 'Extracting video metadata...');

                const response = await fetch('/api/scrape/youtube-archive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();
                
                updateYouTubeProgress(30, 'Downloading video...');

                // Poll for completion
                const checkProgress = async () => {
                    try {
                        const progressResponse = await fetch(`/api/scrape/youtube-progress?taskId=${data.taskId}`, {
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });
                        
                        const progressData = await progressResponse.json();
                        
                        if (progressData.status === 'complete') {
                            displayYouTubePreview(progressData.result);
                            updateYouTubeProgress(100, 'Video archived successfully!');
                            setTimeout(() => progressDiv.classList.add('hidden'), 2000);
                        } else if (progressData.status === 'error') {
                            updateYouTubeProgress(0, `Error: ${progressData.error}`);
                        } else {
                            updateYouTubeProgress(progressData.progress || 50, progressData.message || 'Processing...');
                            setTimeout(checkProgress, 2000);
                        }
                    } catch (error) {
                        updateYouTubeProgress(0, `Error: ${error.message}`);
                    }
                };

                setTimeout(checkProgress, 2000);

            } catch (error) {
                updateYouTubeProgress(0, `Error: ${error.message}`);
            }
        }

        function updateYouTubeProgress(percent, status) {
            document.getElementById('youtube-progress-bar').style.width = `${percent}%`;
            document.getElementById('youtube-status').textContent = status;
        }

        function extractVideoId(url) {
            const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
            return match ? match[1] : null;
        }

        function displayYouTubePreview(data) {
            const previewDiv = document.getElementById('youtube-preview');
            const thumbnailDiv = document.getElementById('youtube-thumbnail');
            const metadataDiv = document.getElementById('youtube-metadata');

            // Store data for publishing
            window.archivedYouTubeData = data;

            // Auto-populate form fields
            document.getElementById('video-title').value = data.title || '';
            document.getElementById('video-description').value = data.description || '';
            document.getElementById('video-channel').value = data.uploader || '';
            document.getElementById('video-duration').value = data.duration ? Math.ceil(data.duration / 60) : '';
            document.getElementById('video-thumbnail').value = data.thumbnail || '';
            
            // Set tags from YouTube tags
            if (data.tags && data.tags.length > 0) {
                document.getElementById('video-tags').value = data.tags.slice(0, 10).join(', ');
            }

            thumbnailDiv.innerHTML = data.thumbnail ? 
                `<img src="${data.thumbnail}" style="max-width: 200px; border-radius: 8px;">` : 
                '<div style="color: #666;">No thumbnail available</div>';

            metadataDiv.innerHTML = `
                <div><strong>Title:</strong> ${data.title || 'Unknown'}</div>
                <div><strong>Channel:</strong> ${data.uploader || 'Unknown'}</div>
                <div><strong>Duration:</strong> ${data.duration ? formatDuration(data.duration) : 'Unknown'}</div>
                <div><strong>Upload Date:</strong> ${data.upload_date || 'Unknown'}</div>
                <div><strong>Views:</strong> ${data.view_count ? data.view_count.toLocaleString() : 'Unknown'}</div>
                <div><strong>Resolution:</strong> ${data.resolution || 'Unknown'}</div>
                <div><strong>Video URL:</strong> <a href="${data.video_url}" target="_blank">Archived Video</a></div>
            `;

            previewDiv.classList.remove('hidden');
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Exercise Resolution for Workouts
        async function resolveWorkoutExercises() {
            const exerciseRows = document.querySelectorAll('.exercise-row');
            const exercises = [];
            const exerciseNames = [];

            exerciseRows.forEach(row => {
                const name = row.querySelector('.exercise-name').value.trim();
                if (name) {
                    exerciseNames.push(name.toLowerCase());
                    exercises.push({
                        name: name,
                        sets: parseInt(row.querySelector('.exercise-sets').value) || 3,
                        reps: row.querySelector('.exercise-reps').value || '12',
                        rest_seconds: parseInt(row.querySelector('.exercise-rest').value) || 60
                    });
                }
            });

            if (exerciseNames.length === 0) {
                throw new Error('Please add at least one exercise');
            }

            // Check if non-standard workout
            const isNonStandard = document.getElementById('workout-non-standard').checked;
            if (isNonStandard) {
                return { exercises, exerciseDidRefs: null };
            }

            try {
                showMessage('publish-status', '🔍 Looking up exercises in database...', 'info');

                // Look up exercises in OIP
                const response = await fetch('/api/workout/resolve-exercises', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ exerciseNames })
                });

                const data = await response.json();

                if (response.ok) {
                    // Update exercise names with DID references where available
                    const resolvedExercises = exercises.map(exercise => {
                        const didRef = data.exerciseDidRefs[exercise.name.toLowerCase()];
                        return {
                            ...exercise,
                            exerciseDidRef: didRef || exercise.name
                        };
                    });

                    const missingCount = Object.values(data.exerciseDidRefs).filter(ref => ref === null).length;
                    if (missingCount > 0) {
                        showMessage('publish-status', `✅ Found ${exerciseNames.length - missingCount} exercises, creating ${missingCount} new ones from Kaggle dataset...`, 'info');
                    } else {
                        showMessage('publish-status', '✅ All exercises found in database!', 'success');
                    }

                    return { exercises: resolvedExercises, exerciseDidRefs: data.exerciseDidRefs };
                } else {
                    throw new Error(data.error || 'Failed to resolve exercises');
                }
            } catch (error) {
                console.error('Exercise resolution error:', error);
                showMessage('publish-status', `⚠️ Exercise lookup failed, publishing with exercise names: ${error.message}`, 'warning');
                return { exercises, exerciseDidRefs: null };
            }
        }

        // Publishing functions for each record type
        async function publishPost() {
            try {
                const postSource = document.getElementById('post-source').value;
                let postData;

                if (postSource === 'archive-x' && window.scrapedXPostData) {
                    // Use scraped X post data
                    postData = {
                        basic: {
                            name: window.scrapedXPostData.text.substring(0, 100) + (window.scrapedXPostData.text.length > 100 ? '...' : ''),
                            description: window.scrapedXPostData.text,
                            language: 'en',
                            date: window.scrapedXPostData.date ? Math.floor(new Date(window.scrapedXPostData.date).getTime() / 1000) : Math.floor(Date.now() / 1000),
                            nsfw: false,
                            tagItems: ['twitter', 'x', 'social-media'],
                            webUrl: window.scrapedXPostData.url // Original X post URL
                        },
                        post: {
                            articleText: window.scrapedXPostData.text,
                            bylineWriter: window.scrapedXPostData.author,
                            webUrl: window.scrapedXPostData.url,
                            imageItems: window.scrapedXPostData.images || [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: [],
                            replyTo: ''
                        }
                    };
                } else {
                    // Use manual form data
                    postData = {
                        basic: {
                            name: document.getElementById('post-title').value,
                            description: document.getElementById('post-description').value,
                            language: 'en',
                            date: Math.floor(Date.now() / 1000),
                            nsfw: document.getElementById('post-nsfw').checked,
                            tagItems: document.getElementById('post-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        post: {
                            articleText: document.getElementById('post-content').value,
                            bylineWriter: document.getElementById('post-author')?.value || '',
                            bylineWritersTitle: document.getElementById('post-author-title')?.value || '',
                            bylineWritersLocation: document.getElementById('post-author-location')?.value || '',
                            webUrl: document.getElementById('post-web-url')?.value || '',
                            featuredImage: document.getElementById('post-featured-image')?.value || '',
                            replyTo: document.getElementById('post-reply-to')?.value || '',
                            imageItems: [],
                            imageCaptionItems: [],
                            videoItems: [],
                            audioItems: [],
                            audioCaptionItems: []
                        }
                    };
                }

                if (!postData.basic.name || !postData.post.articleText) {
                    showMessage('publish-status', 'Please fill in title and content', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newPost', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(postData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Post published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish post', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishVideo() {
            try {
                const videoSource = document.getElementById('video-source').value;
                let videoData;

                if (videoSource === 'youtube-archive' && window.archivedYouTubeData) {
                    // Use archived YouTube data
                    videoData = {
                        youtubeUrl: window.archivedYouTubeData.original_url || document.getElementById('youtube-url').value,
                        archivedVideoUrl: window.archivedYouTubeData.video_url,
                        thumbnailUrl: window.archivedYouTubeData.thumbnail,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t),
                            webUrl: window.archivedYouTubeData.original_url // Original YouTube URL
                        },
                        videoMetadata: {
                            duration: window.archivedYouTubeData.duration,
                            uploader: window.archivedYouTubeData.uploader,
                            upload_date: window.archivedYouTubeData.upload_date,
                            view_count: window.archivedYouTubeData.view_count,
                            resolution: window.archivedYouTubeData.resolution
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                } else {
                    // Use manual form data
                    videoData = {
                        youtubeUrl: document.getElementById('video-url')?.value,
                        thumbnailUrl: document.getElementById('video-thumbnail')?.value,
                        basicMetadata: {
                            name: document.getElementById('video-title').value,
                            description: document.getElementById('video-description').value,
                            language: 'en',
                            nsfw: document.getElementById('video-nsfw').checked,
                            tagItems: document.getElementById('video-tags').value.split(',').map(t => t.trim()).filter(t => t)
                        },
                        videoMetadata: {
                            duration: document.getElementById('video-duration').value ? parseInt(document.getElementById('video-duration').value) * 60 : null,
                            uploader: document.getElementById('video-channel').value
                        },
                        blockchain: 'arweave',
                        publishTo: {
                            arweave: document.getElementById('video-arweave').checked,
                            ipfs: document.getElementById('video-ipfs').checked
                        }
                    };
                }

                if (!videoData.basicMetadata.name) {
                    showMessage('publish-status', 'Please fill in video title', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newVideo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(videoData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Video published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish video', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishRecipe() {
            try {
                // Collect ingredients
                const ingredientRows = document.querySelectorAll('.ingredient-row');
                const ingredients = [];
                const ingredientAmounts = [];
                const ingredientUnits = [];

                ingredientRows.forEach(row => {
                    const amount = row.querySelector('.ingredient-amount').value;
                    const unit = row.querySelector('.ingredient-unit').value;
                    const name = row.querySelector('.ingredient-name').value;
                    
                    if (name.trim()) {
                        ingredients.push(name);
                        ingredientAmounts.push(parseFloat(amount) || 1);
                        ingredientUnits.push(unit || 'unit');
                    }
                });

                const recipeData = {
                    basic: {
                        name: document.getElementById('recipe-title').value,
                        description: document.getElementById('recipe-description').value,
                        language: 'En',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('recipe-tags').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    recipe: [{
                        prep_time_mins: parseInt(document.getElementById('recipe-prep-time').value) || null,
                        cook_time_mins: parseInt(document.getElementById('recipe-cook-time').value) || null,
                        total_time_mins: (parseInt(document.getElementById('recipe-prep-time').value) || 0) + (parseInt(document.getElementById('recipe-cook-time').value) || 0),
                        servings: parseInt(document.getElementById('recipe-servings').value) || null,
                        ingredient_amount: ingredientAmounts,
                        ingredient_unit: ingredientUnits,
                        ingredient: ingredients,
                        instructions: document.getElementById('recipe-instructions').value,
                        notes: document.getElementById('recipe-notes').value,
                        cuisine: document.getElementById('recipe-cuisine').value,
                        course: document.getElementById('recipe-course').value
                    }],
                    image: {
                        webUrl: document.getElementById('recipe-image').value,
                        contentType: 'image/jpeg'
                    }
                };

                if (!recipeData.basic.name || !recipeData.recipe[0].instructions) {
                    showMessage('publish-status', 'Please fill in recipe name and instructions', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newRecipe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(recipeData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Recipe published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish recipe', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Network error: ' + error.message, 'error');
            }
        }

        async function publishWorkout() {
            try {
                // Resolve exercises first
                const exerciseData = await resolveWorkoutExercises();
                
                const workoutData = {
                    basic: {
                        name: document.getElementById('workout-title').value,
                        description: document.getElementById('workout-description').value,
                        language: 'en',
                        date: Math.floor(Date.now() / 1000),
                        nsfw: false,
                        tagItems: document.getElementById('workout-goals').value.split(',').map(t => t.trim()).filter(t => t)
                    },
                    workout: {
                        duration_mins: parseInt(document.getElementById('workout-duration').value) || null,
                        difficulty: document.getElementById('workout-difficulty').value,
                        category: document.getElementById('workout-category').value,
                        equipment_required: document.getElementById('workout-equipment').value.split(',').map(t => t.trim()).filter(t => t),
                        target_muscle_groups: document.getElementById('workout-muscles').value.split(',').map(t => t.trim()).filter(t => t),
                        exercise: exerciseData.exerciseDidRefs ? 
                            exerciseData.exercises.map(ex => ex.exerciseDidRef) : 
                            exerciseData.exercises.map(ex => ex.name),
                        exercise_sets: exerciseData.exercises.map(ex => ex.sets),
                        exercise_reps: exerciseData.exercises.map(ex => ex.reps),
                        exercise_rest_seconds: exerciseData.exercises.map(ex => ex.rest_seconds),
                        notes: document.getElementById('workout-notes').value,
                        non_standard: document.getElementById('workout-non-standard').checked
                    }
                };

                if (!workoutData.basic.name || exerciseData.exercises.length === 0) {
                    showMessage('publish-status', 'Please fill in workout name and add at least one exercise', 'error');
                    return;
                }

                const response = await fetch('/api/publish/newWorkout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify(workoutData)
                });

                const result = await response.json();
                
                if (response.ok) {
                    showMessage('publish-success', `Workout published successfully! Transaction ID: ${result.transactionId}`, 'success');
                    // Clear form
                    document.getElementById('publish-record-type').value = '';
                    loadPublishInterface();
                } else {
                    showMessage('publish-status', result.error || 'Failed to publish workout', 'error');
                }
            } catch (error) {
                showMessage('publish-status', 'Exercise resolution error: ' + error.message, 'error');
            }
        }

        // Helper functions
        function previewImage() {
            const imageUrl = document.getElementById('image-url').value;
            const previewContainer = document.getElementById('image-preview');
            const previewImg = document.getElementById('preview-img');
            
            if (imageUrl) {
                previewImg.src = imageUrl;
                previewContainer.classList.remove('hidden');
            }
        }

    </script>
</body>
</html> 