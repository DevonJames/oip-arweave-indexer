<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alfred Notes</title>

    <!-- Retro-futurist fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Neo-retro palette - DARK MODE (default) */
            --primary-blue: #5B8CFF;
            --primary-blue-light: #25294A;
            --secondary-purple: #B084FF;
            --accent-cyan: #5FFCF9;
            --accent-pink: #FF7AD9;

            --bg-deep: #050816;
            --bg-light: #0C1024;
            --bg-panel: #11152B;
            --bg-elevated: #171C37;
            --bg-chip: #1F2442;

            --text-primary: #F7F7FF;
            --text-secondary: #B0B4D0;
            --text-tertiary: #7C81A8;

            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-strong: rgba(255, 255, 255, 0.16);

            --red: #FF5C5C;
            --green: #3ED598;
            --success-green: #3ED598;

            --shadow-soft: 0 18px 45px rgba(5, 8, 22, 0.95);
            --shadow-chip: 0 0 0 1px rgba(255, 255, 255, 0.04);

            --radius-lg: 18px;
            --radius-xl: 28px;

            --transition-fast: 0.18s ease-out;
        }

        /* LIGHT MODE - Retro-futuristic pastel palette */
        [data-theme="light"] {
            --primary-blue: #4A7BFF;
            --primary-blue-light: #E8ECFF;
            --secondary-purple: #9B6FFF;
            --accent-cyan: #00D4D4;
            --accent-pink: #FF5DC4;

            --bg-deep: #F5F6FA;
            --bg-light: #FAFBFF;
            --bg-panel: #FFFFFF;
            --bg-elevated: #F8F9FE;
            --bg-chip: #EFF1F9;

            --text-primary: #1A1D2E;
            --text-secondary: #4A5373;
            --text-tertiary: #7A8099;

            --border-subtle: rgba(74, 83, 115, 0.12);
            --border-strong: rgba(74, 83, 115, 0.25);

            --red: #FF4757;
            --green: #2ECC71;
            --success-green: #2ECC71;

            --shadow-soft: 0 18px 45px rgba(74, 83, 115, 0.15);
            --shadow-chip: 0 0 0 1px rgba(74, 83, 115, 0.08);
        }

        /* Light mode specific adjustments */
        [data-theme="light"] .record-button {
            box-shadow:
                0 20px 40px rgba(74, 83, 115, 0.25),
                0 0 35px rgba(0, 212, 212, 0.4);
        }

        [data-theme="light"] .record-button:hover {
            box-shadow:
                0 26px 48px rgba(74, 83, 115, 0.35),
                0 0 45px rgba(0, 212, 212, 0.5);
        }

        [data-theme="light"] .record-button.recording {
            box-shadow:
                0 20px 40px rgba(74, 83, 115, 0.35),
                0 0 40px rgba(255, 71, 87, 0.6);
        }

        [data-theme="light"] .app-title {
            text-shadow: 0 0 8px rgba(0, 212, 212, 0.5);
        }

        [data-theme="light"] .nav-item.active {
            box-shadow: 0 0 0 1px rgba(0, 212, 212, 0.4), 0 0 20px rgba(0, 212, 212, 0.4);
        }

        [data-theme="light"] .template-card:hover {
            box-shadow: 0 18px 40px rgba(74, 83, 115, 0.25);
        }

        [data-theme="light"] .note-card:hover {
            box-shadow: 0 22px 46px rgba(74, 83, 115, 0.25);
        }

        [data-theme="light"] .auth-modal {
            background: radial-gradient(circle at top, rgba(74, 123, 255, 0.15), transparent 60%) rgba(245, 246, 250, 0.92);
        }

        [data-theme="light"] .send-button {
            box-shadow: 0 0 20px rgba(0, 212, 212, 0.6);
        }

        [data-theme="light"] .primary-button {
            box-shadow: 0 16px 34px rgba(74, 83, 115, 0.25), 0 0 26px rgba(0, 212, 212, 0.5);
        }

        [data-theme="light"] .recording-panel {
            border: 1px solid rgba(255, 71, 87, 0.5);
        }

        [data-theme="light"] .logout-btn {
            color: var(--text-primary);
        }

        /* Icon styling for light/dark mode */
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            object-fit: contain;
        }

        .icon-nav {
            width: 24px;
            height: 24px;
            filter: brightness(0) saturate(100%) invert(52%) sepia(13%) saturate(537%) hue-rotate(200deg) brightness(92%) contrast(85%);
            transition: filter var(--transition-fast);
        }

        .nav-item.active .icon-nav {
            filter: brightness(0) saturate(100%) invert(84%) sepia(45%) saturate(2907%) hue-rotate(134deg) brightness(101%) contrast(97%);
        }

        .icon-record {
            width: 60px;
            height: 60px;
            filter: brightness(0) saturate(100%) invert(100%) sepia(0%) saturate(7500%) hue-rotate(21deg) brightness(104%) contrast(104%);
        }

        .icon-template {
            width: 32px;
            height: 32px;
            filter: brightness(0) saturate(100%) invert(84%) sepia(45%) saturate(2907%) hue-rotate(134deg) brightness(101%) contrast(97%);
            margin-bottom: 8px;
        }

        .icon-theme {
            width: 20px;
            height: 20px;
            filter: brightness(0) saturate(100%) invert(84%) sepia(45%) saturate(2907%) hue-rotate(134deg) brightness(101%) contrast(97%);
        }

        .icon-note-badge {
            width: 14px;
            height: 14px;
            filter: brightness(0) saturate(100%) invert(84%) sepia(45%) saturate(2907%) hue-rotate(134deg) brightness(101%) contrast(97%);
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Light mode icon adjustments */
        [data-theme="light"] .icon-nav {
            filter: brightness(0) saturate(100%) invert(27%) sepia(11%) saturate(1234%) hue-rotate(200deg) brightness(96%) contrast(92%);
        }

        [data-theme="light"] .nav-item.active .icon-nav {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        [data-theme="light"] .icon-record {
            filter: brightness(0) saturate(100%) invert(15%) sepia(8%) saturate(3318%) hue-rotate(200deg) brightness(95%) contrast(95%);
        }

        [data-theme="light"] .icon-template {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        [data-theme="light"] .icon-theme {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        [data-theme="light"] .icon-note-badge {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        .note-meta img {
            filter: brightness(0) saturate(100%) invert(82%) sepia(51%) saturate(2450%) hue-rotate(125deg) brightness(102%) contrast(97%);
        }

        [data-theme="light"] .note-meta img {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        body {
            font-family: "Space Grotesk", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background:
                radial-gradient(circle at 0% 0%, rgba(91, 140, 255, 0.18), transparent 55%),
                radial-gradient(circle at 100% 0%, rgba(255, 122, 217, 0.18), transparent 55%),
                radial-gradient(circle at 50% 100%, rgba(95, 252, 249, 0.08), transparent 55%),
                linear-gradient(145deg, #050816 0%, #050816 40%, #050A24 100%);
            color: var(--text-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            transition: background 0.3s ease;
        }

        [data-theme="light"] body {
            background:
                radial-gradient(circle at 0% 0%, rgba(74, 123, 255, 0.12), transparent 55%),
                radial-gradient(circle at 100% 0%, rgba(255, 93, 196, 0.12), transparent 55%),
                radial-gradient(circle at 50% 100%, rgba(0, 212, 212, 0.08), transparent 55%),
                linear-gradient(145deg, #F5F6FA 0%, #FAFBFF 40%, #F8F9FE 100%);
        }

        /* Global cards / glass */
        .glass {
            background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.08), transparent 40%) var(--bg-panel);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-soft);
            backdrop-filter: blur(20px);
        }

        .chip {
            background: var(--bg-chip);
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-chip);
        }

        /* Main Container */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 10px 0;
        }

        /* Header */
        .app-header {
            background: linear-gradient(135deg, rgba(95, 252, 249, 0.05), rgba(91, 140, 255, 0.05)) var(--bg-panel);
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-soft);
        }

        .app-title {
            font-family: "Press Start 2P", system-ui;
            font-size: 12px;
            letter-spacing: 0.09em;
            text-transform: uppercase;
            color: var(--accent-cyan);
            text-shadow: 0 0 8px rgba(95, 252, 249, 0.65);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .app-title::before {
            content: "▌█▐";
            font-size: 10px;
            opacity: 0.8;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .user-info span {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(15, 20, 50, 0.9);
            border: 1px solid var(--border-subtle);
        }

        [data-theme="light"] .app-header {
            background: linear-gradient(135deg, rgba(0, 212, 212, 0.08), rgba(74, 123, 255, 0.08)) var(--bg-panel);
        }

        [data-theme="light"] .user-info span {
            background: rgba(239, 241, 249, 0.95);
        }

        .theme-toggle {
            padding: 6px 12px;
            background: var(--bg-chip);
            color: var(--accent-cyan);
            border: 1px solid var(--border-subtle);
            border-radius: 999px;
            cursor: pointer;
            font-size: 16px;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }

        .theme-toggle:hover {
            background: var(--bg-elevated);
            transform: scale(1.08);
        }

        .logout-btn {
            padding: 6px 12px;
            background: radial-gradient(circle at 0 0, rgba(255, 92, 92, 0.28), transparent 55%) var(--bg-panel);
            color: white;
            border: 1px solid rgba(255, 92, 92, 0.7);
            border-radius: 999px;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .logout-btn:hover {
            background: var(--red);
        }

        /* Content Area */
        .app-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            margin-top: 14px;
            border-radius: var(--radius-xl);
            border: 1px solid var(--border-subtle);
            background: radial-gradient(circle at top, rgba(91, 140, 255, 0.06), transparent 52%) var(--bg-light);
        }

        .view-container {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }

        .view-container.active {
            display: flex;
        }

        /* Bottom Navigation */
        .bottom-nav {
            margin-top: 10px;
            background: linear-gradient(135deg, rgba(9, 11, 35, 0.95), rgba(9, 11, 35, 0.98));
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-around;
            padding: 6px 4px;
            box-shadow: var(--shadow-soft);
        }

        [data-theme="light"] .bottom-nav {
            background: linear-gradient(135deg, rgba(239, 241, 249, 0.95), rgba(255, 255, 255, 0.98));
            border: 1px solid rgba(74, 83, 115, 0.12);
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 18px;
            cursor: pointer;
            color: var(--text-tertiary);
            border: none;
            background: none;
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            transition: color var(--transition-fast), transform var(--transition-fast), background var(--transition-fast), box-shadow var(--transition-fast);
            border-radius: 999px;
        }

        .nav-icon {
            font-size: 20px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 28px;
        }

        .nav-item.active {
            color: var(--accent-cyan);
            background: radial-gradient(circle at 50% 0%, rgba(95, 252, 249, 0.22), transparent 65%) var(--bg-chip);
            box-shadow: 0 0 0 1px rgba(95, 252, 249, 0.4), 0 0 24px rgba(95, 252, 249, 0.5);
            transform: translateY(-1px);
        }

        /* Home View */
        .home-view {
            padding: 32px 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 32px;
        }

        .home-mode-toggle {
            display: flex;
            gap: 8px;
            background: var(--bg-chip);
            padding: 4px;
            border-radius: 999px;
            border: 1px solid var(--border-subtle);
        }

        .mode-toggle-btn {
            padding: 10px 24px;
            border-radius: 999px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .mode-toggle-btn.active {
            background: var(--accent-cyan);
            color: var(--bg-panel);
        }

        .mode-toggle-btn:hover:not(.active) {
            color: var(--text-primary);
            background: rgba(95, 252, 249, 0.1);
        }

        .home-mode-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .upload-form {
            width: 100%;
            max-width: 520px;
        }

        .upload-area {
            background: var(--bg-panel);
            border: 2px dashed var(--border-subtle);
            border-radius: var(--radius-lg);
            padding: 48px 32px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-bottom: 24px;
        }

        .upload-area:hover {
            border-color: var(--accent-cyan);
            background: rgba(95, 252, 249, 0.05);
        }

        .upload-area.drag-over {
            border-color: var(--accent-cyan);
            background: rgba(95, 252, 249, 0.1);
        }

        .upload-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .upload-formats {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .form-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .record-button {
            width: 220px;
            height: 220px;
            border-radius: 50%;
            background:
                radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.35), transparent 50%),
                conic-gradient(from 210deg, var(--accent-cyan), var(--secondary-purple), var(--accent-pink), var(--accent-cyan));
            position: relative;
            border: none;
            cursor: pointer;
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.75),
                0 0 40px rgba(91, 140, 255, 0.6);
            transition: transform var(--transition-fast), box-shadow var(--transition-fast), filter var(--transition-fast);
        }

        .record-button::before {
            content: "";
            position: absolute;
            inset: 14px;
            border-radius: inherit;
            background: radial-gradient(circle at top, rgba(255, 255, 255, 0.08), transparent 60%) var(--bg-panel);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .record-button span {
            position: relative;
            font-size: 46px;
            filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.8));
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-record {
            width: 60px;
            height: 60px;
            filter: brightness(0) saturate(100%) invert(82%) sepia(51%) saturate(2450%) hue-rotate(125deg) brightness(102%) contrast(97%);
        }

        [data-theme="light"] .icon-record {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        .record-button:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                0 26px 48px rgba(0, 0, 0, 0.9),
                0 0 52px rgba(95, 252, 249, 0.7);
        }

        .record-button.recording {
            background:
                radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.4), transparent 50%),
                conic-gradient(from 180deg, #ff7b7b, #ff3b3b, #ff7b7b, #ff3b3b);
            animation: pulse 1.4s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.85), 0 0 40px rgba(255, 123, 123, 0.7); }
            50% { transform: scale(1.04); box-shadow: 0 26px 52px rgba(0, 0, 0, 0.95), 0 0 55px rgba(255, 123, 123, 0.95); }
        }

        .template-selector {
            width: 100%;
            max-width: 520px;
        }

        .template-title {
            font-family: "Press Start 2P", system-ui;
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            margin-bottom: 18px;
            text-align: center;
            color: var(--text-secondary);
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            max-width: 600px;
            margin: 0 auto;
        }

        .template-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 18px 12px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-chip);
            position: relative;
            overflow: hidden;
        }

        .template-card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(95, 252, 249, 0.08), rgba(176, 132, 255, 0.08));
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .template-card:hover {
            border-color: rgba(95, 252, 249, 0.6);
            transform: translateY(-3px);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.85);
        }

        .template-card.selected {
            border-color: rgba(95, 252, 249, 0.85);
            background: radial-gradient(circle at top, rgba(95, 252, 249, 0.18), transparent 60%) var(--bg-panel);
        }

        .template-card.selected::before {
            opacity: 1;
        }

        .template-icon {
            font-size: 28px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 40px;
        }

        .template-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Participants Section */
        .participants-section {
            width: 100%;
            max-width: 520px;
            margin-top: 28px;
        }

        .participant-entry {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: var(--shadow-chip);
            transition: all var(--transition-fast);
        }

        .participant-entry:hover {
            border-color: rgba(95, 252, 249, 0.4);
        }

        .participant-field {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .participant-label {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .participant-input {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 13px;
            color: var(--text-primary);
            font-family: inherit;
            outline: none;
            transition: all var(--transition-fast);
        }

        .participant-input:focus {
            border-color: var(--accent-cyan);
            background: var(--bg-panel);
        }

        .participant-input::placeholder {
            color: var(--text-tertiary);
        }

        .remove-participant-btn {
            background: transparent;
            border: 1px solid rgba(255, 92, 92, 0.3);
            color: var(--red);
            border-radius: 8px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all var(--transition-fast);
        }

        .remove-participant-btn:hover {
            background: rgba(255, 92, 92, 0.15);
            border-color: var(--red);
        }

        .add-participant-btn {
            width: 100%;
            padding: 12px;
            background: var(--bg-panel);
            border: 1px dashed var(--border-strong);
            border-radius: 12px;
            color: var(--accent-cyan);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            font-family: inherit;
            transition: all var(--transition-fast);
            margin-top: 10px;
        }

        .add-participant-btn:hover {
            background: rgba(95, 252, 249, 0.08);
            border-color: var(--accent-cyan);
            border-style: solid;
        }

        /* Library View */
        .library-view {
            background: transparent;
        }

        .library-header {
            padding: 16px 20px 4px;
        }

        .search-bar {
            display: flex;
            align-items: center;
            background: var(--bg-panel);
            border-radius: 999px;
            padding: 8px 14px;
            gap: 10px;
            border: 1px solid var(--border-subtle);
        }

        .search-bar span {
            opacity: 0.8;
        }

        .search-bar input {
            flex: 1;
            border: none;
            background: none;
            font-size: 14px;
            outline: none;
            color: var(--text-primary);
        }

        .search-bar input::placeholder {
            color: var(--text-tertiary);
        }

        .filter-button {
            margin-top: 10px;
            padding: 8px 14px;
            background: var(--bg-chip);
            color: var(--accent-cyan);
            border: 1px dashed rgba(95, 252, 249, 0.6);
            border-radius: 999px;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.12em;
        }

        .notes-list {
            padding: 12px 20px 22px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .note-card {
            background: var(--bg-panel);
            border-radius: var(--radius-lg);
            padding: 14px 16px;
            box-shadow: var(--shadow-soft);
            cursor: pointer;
            transition: transform var(--transition-fast), box-shadow var(--transition-fast), border var(--transition-fast);
            border: 1px solid var(--border-subtle);
            position: relative;
            overflow: hidden;
        }

        .note-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(95, 252, 249, 0.12), transparent 60%);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .note-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 22px 46px rgba(0, 0, 0, 0.95);
            border-color: rgba(95, 252, 249, 0.5);
        }

        .note-card:hover::after {
            opacity: 1;
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
        }

        .note-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .note-badge {
            font-family: "Press Start 2P", system-ui;
            background: var(--bg-chip);
            color: var(--accent-cyan);
            padding: 4px 7px;
            border-radius: 999px;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            border: 1px solid rgba(95, 252, 249, 0.7);
        }

        .note-preview {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .note-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: var(--text-tertiary);
        }

        /* Chat View */
        .chat-view {
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            padding: 16px 20px 8px;
        }

        .chat-toggle {
            display: inline-flex;
            background: var(--bg-panel);
            border-radius: 999px;
            padding: 4px;
            gap: 4px;
            border: 1px solid var(--border-subtle);
        }

        .chat-toggle-btn {
            flex: 1;
            padding: 7px 16px;
            border: none;
            background: none;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: all var(--transition-fast);
        }

        .chat-toggle-btn.active {
            background: radial-gradient(circle at 30% 0%, rgba(95, 252, 249, 0.25), transparent 60%) var(--bg-chip);
            color: var(--accent-cyan);
            box-shadow: 0 0 0 1px rgba(95, 252, 249, 0.6);
        }

        .chat-model-selector {
            padding: 7px 12px;
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            border-radius: 999px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            outline: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all var(--transition-fast);
        }

        .chat-model-selector:hover {
            border-color: rgba(95, 252, 249, 0.4);
            background: var(--bg-chip);
        }

        .chat-model-selector:focus {
            border-color: rgba(95, 252, 249, 0.6);
            box-shadow: 0 0 0 2px rgba(95, 252, 249, 0.1);
        }

        .chat-mode-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
        }

        .info-button {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1.5px solid var(--accent-cyan);
            background: transparent;
            color: var(--accent-cyan);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
            font-family: 'Space Grotesk', sans-serif;
        }

        .info-button:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            box-shadow: 0 0 12px rgba(95, 252, 249, 0.4);
        }

        [data-theme="light"] .info-button {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        [data-theme="light"] .info-button:hover {
            background: var(--accent-cyan);
            color: white;
        }

        .info-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .info-modal.active {
            display: flex;
        }

        .info-modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 24px;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .info-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .info-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-cyan);
        }

        .info-modal-close {
            width: 28px;
            height: 28px;
            border: none;
            background: var(--bg-chip);
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .info-modal-close:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }

        .info-modal-body {
            color: var(--text-primary);
            line-height: 1.6;
        }

        .info-modal-section {
            margin-bottom: 16px;
        }

        .info-modal-section-title {
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 6px;
            font-size: 14px;
        }

        .info-modal-section-text {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .chat-messages {
            flex: 1;
            padding: 18px 20px 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        /* Alfred Visualization Panel */
        .alfred-viz-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 320px;
            background: var(--bg-elevated);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-strong);
            box-shadow: var(--shadow-soft);
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
        }

        #chatView.active .alfred-viz-panel {
            display: block;
        }

        /* Hide panel on mobile devices (screen width < 768px) */
        @media (max-width: 768px) {
            .alfred-viz-panel {
                display: none !important;
            }
        }

        .alfred-viz-panel.collapsed {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: linear-gradient(135deg, var(--accent-cyan), var(--primary-blue));
            display: flex;
            align-items: center;
            justify-content: center;
            border-color: var(--accent-cyan);
        }

        .alfred-viz-panel.collapsed:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(95, 252, 249, 0.5);
        }

        .alfred-viz-panel.collapsed.speaking {
            animation: vizPulse 1.5s ease-in-out infinite;
        }

        @keyframes vizPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(95, 252, 249, 0.7),
                            0 4px 20px rgba(95, 252, 249, 0.4);
            }
            50% { 
                box-shadow: 0 0 0 8px rgba(95, 252, 249, 0),
                            0 4px 30px rgba(95, 252, 249, 0.6);
            }
        }

        .alfred-viz-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-subtle);
            cursor: pointer;
            user-select: none;
        }

        .alfred-viz-panel.collapsed .alfred-viz-header {
            border-bottom: none;
            padding: 12px;
            justify-content: center;
        }

        .alfred-viz-title {
            font-family: "Press Start 2P", system-ui;
            font-size: 9px;
            letter-spacing: 0.1em;
            color: var(--accent-cyan);
            text-transform: uppercase;
        }

        .alfred-viz-panel.collapsed .alfred-viz-title {
            display: none;
        }

        .alfred-viz-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            transition: all var(--transition-fast);
        }

        .alfred-viz-toggle:hover {
            color: var(--accent-cyan);
            transform: scale(1.1);
        }

        .alfred-viz-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .alfred-viz-panel.collapsed .alfred-viz-content {
            display: none;
        }

        .alfred-avatar-container {
            position: relative;
            width: 280px;
            height: 280px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alfred-avatar-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .alfred-soundwave-overlay {
            position: absolute;
            left: 50%;
            top: calc(33% + 30px);
            transform: translate(-50%, -50%) scale(0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .alfred-soundwave-overlay.active {
            opacity: 1;
        }

        .alfred-viz-status {
            font-size: 11px;
            color: var(--text-tertiary);
            font-family: "Space Grotesk", sans-serif;
            text-align: center;
            padding: 8px 16px;
            background: var(--bg-chip);
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
        }

        .alfred-viz-status.speaking {
            color: var(--accent-cyan);
            border-color: var(--accent-cyan);
            background: rgba(95, 252, 249, 0.1);
        }

        .message {
            display: flex;
            gap: 10px;
            max-width: 80%;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background: radial-gradient(circle at 20% 0%, rgba(255, 255, 255, 0.25), transparent 60%) var(--bg-chip);
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
            font-family: "Press Start 2P", system-ui;
            font-size: 9px;
            border: 1px solid rgba(95, 252, 249, 0.6);
        }

        .message-content {
            background: var(--bg-panel);
            padding: 10px 14px;
            border-radius: 14px;
            box-shadow: var(--shadow-chip);
            border: 1px solid var(--border-subtle);
        }

        .message.user .message-content {
            background: linear-gradient(135deg, rgba(95, 252, 249, 0.18), rgba(91, 140, 255, 0.45));
            color: white;
            border-color: rgba(95, 252, 249, 0.6);
        }

        .message-text {
            font-size: 14px;
            line-height: 1.55;
        }

        .message-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }

        .speaker-button {
            background: linear-gradient(135deg, var(--accent-cyan), var(--primary-blue));
            border: none;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: var(--bg-deep);
            font-family: "Space Grotesk", sans-serif;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(95, 252, 249, 0.3);
        }

        .speaker-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(95, 252, 249, 0.4);
        }

        .speaker-button:active {
            transform: translateY(0);
        }

        .speaker-button.loading {
            opacity: 0.6;
            cursor: wait;
            background: linear-gradient(135deg, var(--text-tertiary), var(--text-secondary));
        }

        .speaker-button.playing {
            background: linear-gradient(135deg, var(--green), var(--accent-cyan));
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .speaker-icon {
            width: 14px;
            height: 14px;
        }

        .chat-input-container {
            background: linear-gradient(180deg, rgba(5, 8, 22, 0.2), rgba(5, 8, 22, 0.7));
            border-top: 1px solid var(--border-subtle);
            padding: 14px 20px 18px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid var(--border-subtle);
            border-radius: 999px;
            font-size: 14px;
            outline: none;
            resize: none;
            font-family: inherit;
            min-height: 40px;
            max-height: 96px;
            background: var(--bg-panel);
            color: var(--text-primary);
        }

        .chat-input::placeholder {
            color: var(--text-tertiary);
        }

        .send-button {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 0%, rgba(255, 255, 255, 0.18), transparent 55%) var(--accent-cyan);
            color: #050816;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(95, 252, 249, 0.8);
        }

        .send-button:disabled {
            background: var(--border-subtle);
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Settings View */
        .settings-view {
            padding: 20px;
        }

        .settings-section {
            background: var(--bg-panel);
            border-radius: var(--radius-lg);
            padding: 18px 18px 14px;
            margin-bottom: 16px;
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-soft);
        }

        .section-title {
            font-family: "Press Start 2P", system-ui;
            font-size: 10px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            margin-bottom: 12px;
            color: var(--accent-cyan);
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .setting-row:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-size: 14px;
            color: var(--text-primary);
        }

        .setting-description {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 4px;
        }

        .toggle-switch {
            position: relative;
            width: 46px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-subtle);
            transition: 0.3s;
            border-radius: 26px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: #050816;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--accent-cyan), var(--green));
        }

        input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .model-select {
            padding: 10px 16px;
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            font-size: 13px;
            font-family: "Space Grotesk", sans-serif;
            font-weight: 500;
            background: var(--bg-elevated);
            color: var(--text-primary);
            cursor: pointer;
            outline: none;
            transition: all var(--transition-fast);
            width: 100%;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%235FFCF9' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        .model-select:hover {
            border-color: var(--accent-cyan);
            background: var(--bg-panel);
            box-shadow: 0 0 0 2px rgba(95, 252, 249, 0.15);
        }

        .model-select:focus {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(95, 252, 249, 0.25);
        }

        .model-select option {
            background: var(--bg-panel);
            color: var(--text-primary);
            padding: 10px;
        }

        /* Note Detail View */
        .note-detail-view {
            padding: 20px;
        }

        .note-detail-header {
            background: var(--bg-panel);
            padding: 18px 18px 14px;
            border-radius: var(--radius-lg);
            margin-bottom: 16px;
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-soft);
        }

        .note-detail-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .note-detail-meta {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .summary-section {
            background: var(--bg-panel);
            padding: 18px;
            border-radius: var(--radius-lg);
            margin-bottom: 14px;
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-soft);
        }

        .summary-heading {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--accent-cyan);
        }

        .summary-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .summary-list li {
            padding-left: 18px;
            position: relative;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .summary-list li:before {
            content: "◆";
            position: absolute;
            left: 4px;
            color: var(--accent-cyan);
            font-size: 10px;
        }

        /* Buttons */
        .primary-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--secondary-purple));
            color: #050816;
            border: none;
            border-radius: 999px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 16px 34px rgba(0, 0, 0, 0.9), 0 0 26px rgba(95, 252, 249, 0.7);
        }

        .primary-button:hover {
            filter: brightness(1.08);
        }

        .secondary-button {
            width: 100%;
            padding: 10px 18px;
            background: var(--bg-panel);
            color: var(--text-primary);
            border-radius: 999px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid var(--border-subtle);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        /* Loading State */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 16px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top, rgba(91, 140, 255, 0.28), transparent 60%) rgba(5, 8, 22, 0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .auth-modal.hidden {
            display: none;
        }

        .auth-card {
            background: var(--bg-panel);
            padding: 26px 24px 20px;
            border-radius: var(--radius-lg);
            max-width: 420px;
            width: 92%;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border-strong);
        }

        .auth-title {
            font-family: "Press Start 2P", system-ui;
            font-size: 13px;
            letter-spacing: 0.16em;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            color: var(--accent-cyan);
        }

        .form-group {
            margin-bottom: 14px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-subtle);
            border-radius: 999px;
            font-size: 13px;
            outline: none;
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .form-input:focus {
            border-color: rgba(95, 252, 249, 0.8);
        }

        .auth-toggle {
            text-align: center;
            margin-top: 14px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .auth-toggle a {
            color: var(--accent-cyan);
            text-decoration: none;
            font-weight: 500;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 18px;
            background: var(--bg-panel);
            padding: 12px 16px;
            border-radius: 14px;
            box-shadow: var(--shadow-soft);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1001;
            animation: slideIn 0.25s ease;
            font-size: 13px;
            border: 1px solid var(--border-subtle);
        }

        .toast.hidden {
            display: none;
        }

        @keyframes slideIn {
            from {
                transform: translateX(260px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success {
            border-left: 3px solid var(--green);
        }

        .toast.error {
            border-left: 3px solid var(--red);
        }

        /* Recording Panel */
        .recording-panel {
            position: fixed;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 14px 20px;
            box-shadow: var(--shadow-soft);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 999;
            border-radius: 999px;
            border: 1px solid rgba(255, 92, 92, 0.6);
        }

        .recording-panel.active {
            display: flex;
        }

        .recording-timer {
            font-family: "Press Start 2P", system-ui;
            font-size: 11px;
            letter-spacing: 0.16em;
            color: var(--red);
        }

        .recording-status {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stop-recording-btn {
            padding: 8px 16px;
            background: var(--red);
            color: #050816;
            border: none;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        /* Empty State */
        .empty-state {
            padding: 50px 20px;
            text-align: center;
            color: var(--text-tertiary);
        }

        .empty-icon {
            font-size: 54px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .empty-icon img {
            width: 64px;
            height: 64px;
            filter: brightness(0) saturate(100%) invert(52%) sepia(13%) saturate(537%) hue-rotate(200deg) brightness(92%) contrast(85%);
        }

        [data-theme="light"] .empty-icon img {
            filter: brightness(0) saturate(100%) invert(58%) sepia(92%) saturate(2449%) hue-rotate(158deg) brightness(97%) contrast(101%);
        }

        .empty-text {
            font-size: 15px;
            font-weight: 500;
        }

        /* Scrollbars */
        .view-container::-webkit-scrollbar,
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .view-container::-webkit-scrollbar-thumb,
        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border-subtle);
            border-radius: 3px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-container {
                padding: 8px 8px 0;
            }
            .note-card {
                padding: 12px 12px;
            }
            .home-view {
                padding: 24px 16px;
            }
            .record-button {
                width: 180px;
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <!-- BODY + SCRIPT remain unchanged from your original file -->
    <!-- ... Paste the existing <body> content and <script> exactly as-is ... -->

    <!-- BEGIN ORIGINAL BODY CONTENT -->
    <div class="app-container">
        <!-- Header -->
        <div class="app-header">
            <div class="app-title">Alfred Notes</div>
            <div class="user-info">
                <button class="theme-toggle" onclick="alfredApp.toggleTheme()" title="Toggle theme" id="themeToggle">
                    <img src="icons/noun-moon-4600451.svg" alt="Theme" class="icon-theme" id="themeIcon">
                </button>
                <span id="userEmail">Loading...</span>
                <button class="logout-btn" onclick="alfredApp.logout()">Logout</button>
            </div>
        </div>

        <!-- Content Views -->
        <div class="app-content">
            <!-- Home View -->
            <div id="homeView" class="view-container active">
                <div class="home-view">
                    <!-- Mode Toggle -->
                    <div class="home-mode-toggle">
                        <button class="mode-toggle-btn active" data-mode="record" onclick="alfredApp.switchHomeMode('record')">🎙️ Record</button>
                        <button class="mode-toggle-btn" data-mode="upload" onclick="alfredApp.switchHomeMode('upload')">📤 Upload Audio</button>
                    </div>

                    <!-- Record Mode -->
                    <div id="recordMode" class="home-mode-content">
                        <button class="record-button" id="recordButton" onclick="alfredApp.toggleRecording()">
                            <span id="recordIcon">
                                <img src="icons/noun-microphone-7208171.svg" alt="Record" class="icon-record">
                            </span>
                        </button>
                    </div>

                    <!-- Upload Mode -->
                    <div id="uploadMode" class="home-mode-content" style="display: none;">
                        <div class="upload-form">
                            <div class="upload-area" id="uploadArea">
                                <img src="icons/noun-microphone-7208171.svg" alt="Upload" style="width: 48px; height: 48px; opacity: 0.5; margin-bottom: 12px;">
                                <div class="upload-text">Click to select or drag & drop audio file</div>
                                <div class="upload-formats">Supports: MP3, M4A, WAV, WebM, FLAC, OGG</div>
                                <input type="file" id="audioFileInput" accept="audio/*" style="display: none;" onchange="alfredApp.handleAudioFileSelect(event)">
                            </div>
                            
                            <div id="uploadFormFields" style="display: none;">
                                <div class="form-group">
                                    <label class="form-label">Start Time</label>
                                    <input type="datetime-local" id="uploadStartTime" class="form-input" required>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">End Time</label>
                                    <input type="datetime-local" id="uploadEndTime" class="form-input" required>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Device Type</label>
                                    <select id="uploadDeviceType" class="form-input">
                                        <option value="IPHONE">iPhone</option>
                                        <option value="MAC">Mac</option>
                                        <option value="WATCH">Apple Watch</option>
                                        <option value="OTHER">Other</option>
                                    </select>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Participant Names (comma-separated)</label>
                                    <input type="text" id="uploadParticipantNames" class="form-input" placeholder="John Doe, Jane Smith">
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Participant Roles (comma-separated)</label>
                                    <input type="text" id="uploadParticipantRoles" class="form-input" placeholder="CEO, CTO">
                                </div>
                                
                                <div class="form-group" style="display: flex; gap: 16px; align-items: center;">
                                    <label class="form-checkbox">
                                        <input type="checkbox" id="uploadAddToWebServer" checked>
                                        <span>Add to Web Server</span>
                                    </label>
                                    <label class="form-checkbox">
                                        <input type="checkbox" id="uploadAddToBitTorrent">
                                        <span>Add to BitTorrent</span>
                                    </label>
                                </div>
                                
                                <button class="primary-button" onclick="alfredApp.uploadAudioFile()" style="width: 100%; margin-top: 8px;">
                                    📤 Upload & Process
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="template-selector">
                        <h3 class="template-title">Select Template</h3>
                        <div class="template-grid">
                            <div class="template-card selected" data-template="MEETING">
                                <div class="template-icon">
                                    <img src="icons/noun-group-7945444.svg" alt="Meeting" class="icon-template">
                                </div>
                                <div class="template-name">Meeting</div>
                            </div>
                            <div class="template-card" data-template="ONE_ON_ONE">
                                <div class="template-icon">
                                    <img src="icons/noun-partner-4253508.svg" alt="1:1" class="icon-template">
                                </div>
                                <div class="template-name">1:1</div>
                            </div>
                            <div class="template-card" data-template="STANDUP">
                                <div class="template-icon">
                                    <img src="icons/noun-checklist-8032577.svg" alt="Standup" class="icon-template">
                                </div>
                                <div class="template-name">Standup</div>
                            </div>
                            <div class="template-card" data-template="IDEA">
                                <div class="template-icon">
                                    <img src="icons/noun-innovation-7945253.svg" alt="Idea" class="icon-template">
                                </div>
                                <div class="template-name">Idea / Brain Dump</div>
                            </div>
                            <div class="template-card" data-template="REFLECTION">
                                <div class="template-icon">
                                    <img src="icons/noun-thinking-5552685.svg" alt="Reflection" class="icon-template">
                                </div>
                                <div class="template-name">Daily Reflection</div>
                            </div>
                            <div class="template-card" data-template="INTERVIEW">
                                <div class="template-icon">
                                    <img src="icons/noun-training-7945372.svg" alt="Interview" class="icon-template">
                                </div>
                                <div class="template-name">Interview / Lecture</div>
                            </div>
                        </div>
                    </div>

                    <!-- Participants Section -->
                    <div class="participants-section" id="participantsSection">
                        <h3 class="template-title">Participants (Optional)</h3>
                        <div id="participantsList">
                            <!-- Participant entries will be dynamically added here -->
                        </div>
                        <button class="add-participant-btn" onclick="alfredApp.addParticipant()">+ Add Participant</button>
                    </div>
                </div>
            </div>

            <!-- Library View -->
            <div id="libraryView" class="view-container">
                <div class="library-view">
                    <div class="library-header">
                        <div class="search-bar">
                            <span>🔍</span>
                            <input type="text" placeholder="Search notes..." id="searchInput" onkeyup="alfredApp.searchNotes()">
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 10px;">
                            <button class="filter-button" onclick="alfredApp.toggleFilters()">🔽 Advanced Search & Filters</button>
                            <button class="filter-button" onclick="alfredApp.refreshNotesFromBackend()" style="border-color: rgba(95, 252, 249, 0.8); background: rgba(95, 252, 249, 0.1);"><img src="icons/noun-reset-3749886.svg" alt="" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; opacity: 0.9;"> Refresh from Backend</button>
                        </div>
                    </div>
                    <div class="notes-list" id="notesList">
                        <div class="loading">
                            <div class="spinner"></div>
                            <div>Loading your notes...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat View -->
            <div id="chatView" class="view-container">
                <div class="chat-view">
                    <div class="chat-header">
                        <div style="display: flex; align-items: center; gap: 12px; justify-content: center;">
                            <div class="chat-toggle">
                                <button class="chat-toggle-btn active" data-ai="alfred" onclick="alfredApp.switchAI('alfred')">Alfred</button>
                                <button class="chat-toggle-btn" data-ai="alice" onclick="alfredApp.switchAI('alice')">Alice</button>
                            </div>
                            <select class="chat-model-selector" id="chatModelSelect" onchange="alfredApp.updateChatModel(this.value)">
                                <option value="parallel">Parallel (All Models)</option>
                                <option value="llama3.2:3b">Llama 3.2 (3B)</option>
                                <option value="gpt-4o-mini">GPT-4o Mini</option>
                                <option value="grok-beta">Grok Beta</option>
                            </select>
                        </div>
                        <div class="chat-mode-row">
                            <div class="chat-toggle">
                                <button class="chat-toggle-btn active" data-mode="chat" onclick="alfredApp.switchChatMode('chat')">Chat</button>
                                <button class="chat-toggle-btn" data-mode="notes" onclick="alfredApp.switchChatMode('notes')">All Notes</button>
                                <button class="chat-toggle-btn" data-mode="selected" onclick="alfredApp.switchChatMode('selected')" id="selectedNoteBtn" style="display: none;">Selected Note</button>
                            </div>
                            <button class="info-button" onclick="alfredApp.showModeInfo()" title="Learn about chat modes">i</button>
                        </div>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <!-- Messages will be dynamically inserted here -->
                    </div>
                    <div class="chat-input-container">
                        <textarea class="chat-input" id="chatInput" placeholder="Ask Alfred anything..." rows="1"></textarea>
                        <button class="send-button" id="sendButton" onclick="alfredApp.sendMessage()">➤</button>
                    </div>

                    <!-- Alfred Visualization Panel -->
                    <div id="alfredVizPanel" class="alfred-viz-panel collapsed">
                        <div class="alfred-viz-header" onclick="alfredApp.toggleAlfredViz()">
                            <div class="alfred-viz-title">Alfred</div>
                            <button class="alfred-viz-toggle">◐</button>
                        </div>
                        <div class="alfred-viz-content">
                            <div class="alfred-avatar-container">
                                <img src="/alfred.png" alt="Alfred" class="alfred-avatar-img">
                                <canvas id="alfredSoundwave" class="alfred-soundwave-overlay" width="60" height="24"></canvas>
                            </div>
                            <div id="alfredVizStatus" class="alfred-viz-status">Ready to speak</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Info Modal -->
            <div id="infoModal" class="info-modal" onclick="alfredApp.closeInfoModal(event)">
                <div class="info-modal-content" onclick="event.stopPropagation()">
                    <div class="info-modal-header">
                        <div class="info-modal-title">Chat Modes</div>
                        <button class="info-modal-close" onclick="alfredApp.closeInfoModal()">×</button>
                    </div>
                    <div class="info-modal-body">
                        <div class="info-modal-section">
                            <div class="info-modal-section-title">💬 Chat Mode</div>
                            <div class="info-modal-section-text">
                                General-purpose AI assistant. Ask any question and get helpful responses. This mode doesn't search your notes - it's like having a conversation with a knowledgeable assistant about any topic.
                            </div>
                        </div>
                        <div class="info-modal-section">
                            <div class="info-modal-section-title">📚 All Notes Mode</div>
                            <div class="info-modal-section-text">
                                Searches across all your meeting notes to find relevant information. Ask questions like "What did we discuss about the API last week?" or "Who was assigned to the design task?" and Alfred will search your notes, find the most relevant one, and answer based on that content.
                            </div>
                        </div>
                        <div class="info-modal-section">
                            <div class="info-modal-section-title">📝 Selected Note Mode</div>
                            <div class="info-modal-section-text">
                                Ask questions about a specific note you're viewing. When you click "Chat with Alfred about this note" from a note detail page, this mode is automatically activated and all questions will be answered using only that note's content, transcript, and summary.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings View -->
            <div id="settingsView" class="view-container">
                <div class="settings-view">
                    <div class="settings-section">
                        <h2 class="section-title">Alfred Backend</h2>
                        <div class="setting-row">
                            <div>
                                <div class="setting-label">Enable Backend Processing</div>
                                <div class="setting-description">Upload recordings to Alfred backend for transcription, summarization, and RAG indexing</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="backendToggle" checked onchange="alfredApp.updateSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-row">
                            <div style="flex: 1;">
                                <div class="setting-label">Backend API</div>
                                <div class="setting-description" id="apiUrlDisplay" style="display: block;">
                                    <span id="apiUrlText">Loading...</span>
                                    <button class="edit-url-btn" onclick="alfredApp.startEditingApiUrl()" style="margin-left: 8px; padding: 4px 10px; background: var(--bg-chip); border: 1px solid var(--border-subtle); border-radius: 6px; color: var(--accent-cyan); font-size: 11px; cursor: pointer; font-family: 'Space Grotesk', sans-serif;">Edit</button>
                                </div>
                                <div class="api-url-editor" id="apiUrlEditor" style="display: none; margin-top: 8px;">
                                    <input type="text" id="apiUrlInput" class="form-input" placeholder="https://api.oip.onl" style="margin-bottom: 8px;">
                                    <div style="display: flex; gap: 8px;">
                                        <button class="secondary-button" onclick="alfredApp.saveApiUrl()" style="flex: 1; padding: 8px 16px; font-size: 12px;">Save</button>
                                        <button class="secondary-button" onclick="alfredApp.cancelEditingApiUrl()" style="flex: 1; padding: 8px 16px; font-size: 12px;">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2 class="section-title">Upload to Web Server</h2>
                        <div class="setting-row">
                            <div>
                                <div class="setting-label">Store audio files on web server</div>
                                <div class="setting-description">Enable HTTP access to your recordings</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="webServerToggle" checked onchange="alfredApp.updateSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2 class="section-title">Voice Response</h2>
                        <div class="setting-row">
                            <div>
                                <div class="setting-label">Enable Voice Responses</div>
                                <div class="setting-description">Hear Alfred/Alice speak their responses</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="audioToggle" onchange="alfredApp.updateSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-row">
                            <div style="width: 100%;">
                                <div class="setting-label">TTS Engine</div>
                                <select class="model-select" id="ttsEngineSelect" onchange="alfredApp.updateSettings()" style="margin-top: 8px;">
                                    <option value="kokoro">Kokoro TTS (High quality, fast)</option>
                                    <option value="silero">Silero Neural TTS (GPU-accelerated)</option>
                                    <option value="elevenlabs">ElevenLabs (Premium, requires API key)</option>
                                    <option value="edge_tts">Edge TTS (Microsoft)</option>
                                    <option value="gtts">Google TTS (Simple, reliable)</option>
                                    <option value="espeak">eSpeak (Offline fallback)</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-row">
                            <div style="width: 100%;">
                                <div class="setting-label">Voice Selection</div>
                                <select class="model-select" id="voiceSelect" onchange="alfredApp.updateSettings()" style="margin-top: 8px;">
                                    <option value="en">English (American)</option>
                                    <option value="en-gb">English (British)</option>
                                    <option value="es">Spanish</option>
                                    <option value="fr">French</option>
                                    <option value="de">German</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-row">
                            <div>
                                <div class="setting-label">Auto-play Responses</div>
                                <div class="setting-description">Automatically play audio when received</div>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoPlayToggle" onchange="alfredApp.updateSettings()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2 class="section-title">LLM Model</h2>
                        <div class="setting-row">
                            <div class="setting-label">Select the model for summarization</div>
                            <select class="model-select" id="modelSelect" onchange="alfredApp.updateSettings()">
                                <option value="llama3.2:3b" selected>Llama 3.2 3B (Fast, good quality - recommended)</option>
                                <option value="llama3.2:1b">Llama 3.2 1B (Fastest, lower quality)</option>
                                <option value="llama3.1:8b">Llama 3.1 8B (Slower, best quality)</option>
                                <option value="gemma2:2b">Gemma 2 2B (Alternative lightweight model)</option>
                            </select>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h2 class="section-title">About</h2>
                        <div class="setting-row">
                            <div class="setting-label">Alfred Meeting Notes</div>
                            <div class="setting-description">Version 1.0.0</div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-label">Backend API</div>
                            <div class="setting-description" id="apiUrlDisplayAbout">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Note Detail View -->
            <div id="noteDetailView" class="view-container">
                <div class="note-detail-view">
                    <div style="margin-bottom: 20px; display: flex; gap: 12px; flex-wrap: wrap;">
                        <button class="secondary-button" onclick="alfredApp.showView('libraryView')" style="width: auto; padding: 10px 20px;">← Back to Library</button>
                        <button class="filter-button" onclick="alfredApp.fillMissingAnalysis()" style="border-color: rgba(95, 252, 249, 0.8); background: rgba(95, 252, 249, 0.1); padding: 10px 20px;"><img src="icons/noun-reset-3749886.svg" alt="" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; opacity: 0.9;"> Fill in Missing Analysis</button>
                    </div>
                    <div class="note-detail-header">
                        <h1 class="note-detail-title" id="noteDetailTitle">Note Title</h1>
                        <div class="note-detail-meta">
                            <span id="noteDetailDate">Nov 20, 2025</span>
                            <span id="noteDetailDuration">0m</span>
                        </div>
                    </div>

                    <div class="summary-section">
                        <h2 class="summary-heading">Key Summary</h2>
                        <ul class="summary-list" id="keySummary">
                            <li>Loading...</li>
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h2 class="summary-heading">Action Items</h2>
                        <ul class="summary-list" id="actionItems">
                            <li>Loading...</li>
                        </ul>
                    </div>

                    <div class="summary-section">
                        <h2 class="summary-heading">Open Questions</h2>
                        <ul class="summary-list" id="openQuestions">
                            <li>Loading...</li>
                        </ul>
                    </div>

                    <div style="margin-top: 20px;">
                        <button class="primary-button" onclick="alfredApp.chatAboutNote()">💬 Chat with Alfred about this note</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <button class="nav-item active" onclick="alfredApp.showView('homeView')" data-view="homeView">
                <div class="nav-icon">
                    <img src="icons/noun-home-8131209.svg" alt="Home" class="icon-nav">
                </div>
                <div>Home</div>
            </button>
            <button class="nav-item" onclick="alfredApp.showView('libraryView')" data-view="libraryView">
                <div class="nav-icon">
                    <img src="icons/noun-notebook-7945455.svg" alt="Notes" class="icon-nav">
                </div>
                <div>Notes</div>
            </button>
            <button class="nav-item" onclick="alfredApp.showView('chatView')" data-view="chatView">
                <div class="nav-icon">
                    <img src="icons/alfred-buttler.png" alt="Alfred" class="icon-nav">
                </div>
                <div>Alfred</div>
            </button>
            <button class="nav-item" onclick="alfredApp.showView('settingsView')" data-view="settingsView">
                <div class="nav-icon">
                    <img src="icons/noun-setting-4468047.svg" alt="Settings" class="icon-nav">
                </div>
                <div>Settings</div>
            </button>
        </div>

        <!-- Recording Panel -->
        <div class="recording-panel" id="recordingPanel">
            <div class="recording-timer" id="recordingTimer">00:00</div>
            <div class="recording-status">Recording...</div>
            <button class="stop-recording-btn" onclick="alfredApp.stopRecording()">⏹ Stop Recording</button>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="auth-modal" id="authModal">
        <div class="auth-card">
            <h2 class="auth-title">Welcome to Alfred Notes</h2>
            <div id="loginForm">
                <div class="form-group">
                    <label class="form-label">Email</label>
                    <input type="email" class="form-input" id="loginEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label class="form-label">Password</label>
                    <input type="password" class="form-input" id="loginPassword" placeholder="Enter your password">
                </div>
                <button class="primary-button" onclick="alfredApp.login()">Login</button>
                <div class="auth-toggle">
                    Don't have an account? <a href="#" onclick="alfredApp.showRegister()">Register</a>
                </div>
            </div>
            <div id="registerForm" style="display: none;">
                <div class="form-group">
                    <label class="form-label">Email</label>
                    <input type="email" class="form-input" id="registerEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label class="form-label">Password</label>
                    <input type="password" class="form-input" id="registerPassword" placeholder="Choose a password">
                </div>
                <button class="primary-button" onclick="alfredApp.register()">Register</button>
                <div class="auth-toggle">
                    Already have an account? <a href="#" onclick="alfredApp.showLogin()">Login</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast hidden" id="toast">
        <span id="toastIcon">✓</span>
        <span id="toastMessage">Success!</span>
    </div>

    <script>
        // Alfred Notes Application
        const alfredApp = {
            // State
            state: {
                isRecording: false,
                mediaRecorder: null,
                audioChunks: [],
                recordingStartTime: null,
                selectedTemplate: 'MEETING',
                participants: [],
                notes: [],
                currentNote: null,
                jwtToken: localStorage.getItem('alfred_jwt_token'),
                userEmail: localStorage.getItem('alfred_user_email'),
                theme: localStorage.getItem('alfred_theme') || 'dark',
                settings: {
                    backendEnabled: true,
                    webServerUpload: true,
                    model: 'llama3.2:3b',
                    apiBaseUrl: localStorage.getItem('alfred_api_base_url') || 'https://api.oip.onl',
                    audioEnabled: localStorage.getItem('alfred_audio_enabled') === 'true',
                    ttsEngine: localStorage.getItem('alfred_tts_engine') || 'kokoro',
                    voiceId: localStorage.getItem('alfred_voice_id') || 'en',
                    autoPlay: localStorage.getItem('alfred_auto_play') === 'true'
                },
                isEditingApiUrl: false,
                currentAI: 'alfred',
                chatMode: 'chat', // 'chat', 'notes', or 'selected'
                selectedNoteForChat: null, // The note DID when in 'selected' mode
                conversationHistory: [],
                homeMode: 'record', // 'record' or 'upload'
                selectedAudioFile: null,
                currentAudio: null, // Currently playing audio element
                currentAudioButton: null, // Button for currently playing audio
                soundwaveAnimationId: null, // Animation frame ID for sound wave
                isStreamingAudio: false, // Whether audio is currently streaming
                streamComplete: false, // Whether the SSE stream is complete
                audioContext: null, // Web Audio API context
                audioAnalyser: null, // Audio analyser node
                audioSource: null // Audio source node
            },

            // Initialize app
            init() {
                console.log('🎙️ Alfred Notes initializing...');
                
                // Initialize theme
                this.initTheme();
                
                // Initialize API URL display
                this.updateApiUrlDisplay();
                
                // Initialize chat model selector
                const chatModelSelect = document.getElementById('chatModelSelect');
                if (chatModelSelect) {
                    chatModelSelect.value = this.state.settings.model;
                }
                
                // Initialize audio settings
                const audioToggle = document.getElementById('audioToggle');
                const ttsEngineSelect = document.getElementById('ttsEngineSelect');
                const voiceSelect = document.getElementById('voiceSelect');
                const autoPlayToggle = document.getElementById('autoPlayToggle');
                const modelSelect = document.getElementById('modelSelect');
                
                if (audioToggle) audioToggle.checked = this.state.settings.audioEnabled;
                if (ttsEngineSelect) ttsEngineSelect.value = this.state.settings.ttsEngine;
                if (voiceSelect) voiceSelect.value = this.state.settings.voiceId;
                if (autoPlayToggle) autoPlayToggle.checked = this.state.settings.autoPlay;
                if (modelSelect) modelSelect.value = this.state.settings.model;
                
                // Check authentication
                if (!this.state.jwtToken) {
                    this.showAuthModal();
                } else {
                    this.hideAuthModal();
                    this.loadUserInfo();
                    this.loadNotes();
                }

                // Setup template selection
                this.setupTemplateSelection();
                
                // Initialize participants section
                this.renderParticipants();
                
                // Setup event listeners
                this.setupEventListeners();
                
                console.log('✅ Alfred Notes ready');
            },

            // Helper function to convert enum CODE to display name
            getEnumDisplayName(enumCode, enumType = 'note_type') {
                const enumMappings = {
                    note_type: {
                        'MEETING': 'Meeting',
                        'ONE_ON_ONE': '1:1',
                        'STANDUP': 'Standup',
                        'IDEA': 'Idea',
                        'REFLECTION': 'Reflection',
                        'INTERVIEW': 'Interview'
                    },
                    device_type: {
                        'IPHONE': 'iPhone',
                        'MAC': 'Mac',
                        'WATCH': 'Watch',
                        'OTHER': 'Other'
                    },
                    transcription_status: {
                        'PENDING': 'Pending',
                        'COMPLETE': 'Complete',
                        'FAILED': 'Failed'
                    },
                    sentiment_overall: {
                        'NEGATIVE': 'Negative',
                        'NEUTRAL': 'Neutral',
                        'POSITIVE': 'Positive'
                    }
                };

                return enumMappings[enumType]?.[enumCode] || enumCode;
            },

            // Setup template cards
            setupTemplateSelection() {
                const cards = document.querySelectorAll('.template-card');
                cards.forEach(card => {
                    card.addEventListener('click', () => {
                        cards.forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        this.state.selectedTemplate = card.dataset.template;
                    });
                });
            },

            // Participant Management
            addParticipant() {
                const participantId = Date.now();
                this.state.participants.push({ id: participantId, name: '', role: '' });
                this.renderParticipants();
            },

            removeParticipant(id) {
                this.state.participants = this.state.participants.filter(p => p.id !== id);
                this.renderParticipants();
            },

            updateParticipant(id, field, value) {
                const participant = this.state.participants.find(p => p.id === id);
                if (participant) {
                    participant[field] = value;
                }
            },

            renderParticipants() {
                const container = document.getElementById('participantsList');
                if (!container) return;

                container.innerHTML = this.state.participants.map(p => `
                    <div class="participant-entry">
                        <div class="participant-field">
                            <div class="participant-label">Name</div>
                            <input 
                                type="text" 
                                class="participant-input" 
                                placeholder="John Doe" 
                                value="${p.name}"
                                oninput="alfredApp.updateParticipant(${p.id}, 'name', this.value)"
                            >
                        </div>
                        <div class="participant-field">
                            <div class="participant-label">Role</div>
                            <input 
                                type="text" 
                                class="participant-input" 
                                placeholder="CEO" 
                                value="${p.role}"
                                oninput="alfredApp.updateParticipant(${p.id}, 'role', this.value)"
                            >
                        </div>
                        <button class="remove-participant-btn" onclick="alfredApp.removeParticipant(${p.id})" title="Remove participant">×</button>
                    </div>
                `).join('');
            },

            getParticipantsData() {
                const names = this.state.participants
                    .filter(p => p.name.trim())
                    .map(p => p.name.trim());
                const roles = this.state.participants
                    .filter(p => p.name.trim())
                    .map(p => p.role.trim());
                return { names, roles };
            },

            clearParticipants() {
                this.state.participants = [];
                this.renderParticipants();
            },

            // Setup event listeners
            setupEventListeners() {
                // Enter key for login
                ['loginEmail', 'loginPassword'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') this.login();
                        });
                    }
                });

                // Enter key for register
                ['registerEmail', 'registerPassword'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('keypress', (e) => {
                            if (e.key === 'Enter') this.register();
                        });
                    }
                });

                // Drag and drop for audio upload
                const uploadArea = document.getElementById('uploadArea');
                if (uploadArea) {
                    uploadArea.addEventListener('click', () => {
                        document.getElementById('audioFileInput').click();
                    });

                    uploadArea.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        uploadArea.classList.add('drag-over');
                    });

                    uploadArea.addEventListener('dragleave', () => {
                        uploadArea.classList.remove('drag-over');
                    });

                    uploadArea.addEventListener('drop', (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('drag-over');
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            this.handleAudioFileSelect({ target: { files } });
                        }
                    });
                }

                // Escape key to close info modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modal = document.getElementById('infoModal');
                        if (modal && modal.classList.contains('active')) {
                            this.closeInfoModal();
                        }
                    }
                });

                // Chat input enter
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });
                }
            },

            // Authentication
            async login() {
                const email = document.getElementById('loginEmail').value.trim();
                const password = document.getElementById('loginPassword').value;

                if (!email || !password) {
                    this.showToast('Please enter email and password', 'error');
                    return;
                }

                try {
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/user/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email, password })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.state.jwtToken = data.token;
                        this.state.userEmail = email;
                        localStorage.setItem('alfred_jwt_token', data.token);
                        localStorage.setItem('alfred_user_email', email);
                        
                        this.hideAuthModal();
                        this.loadUserInfo();
                        this.loadNotes();
                        this.showToast('Logged in successfully', 'success');
                    } else {
                        this.showToast(data.error || 'Login failed', 'error');
                    }
                } catch (error) {
                    console.error('Login error:', error);
                    this.showToast('Login failed: ' + error.message, 'error');
                }
            },

            async register() {
                const email = document.getElementById('registerEmail').value.trim();
                const password = document.getElementById('registerPassword').value;

                if (!email || !password) {
                    this.showToast('Please enter email and password', 'error');
                    return;
                }

                try {
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/user/register`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email, password })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.state.jwtToken = data.token;
                        this.state.userEmail = email;
                        localStorage.setItem('alfred_jwt_token', data.token);
                        localStorage.setItem('alfred_user_email', email);
                        
                        this.hideAuthModal();
                        this.loadUserInfo();
                        this.showToast('Account created successfully', 'success');
                    } else {
                        this.showToast(data.error || 'Registration failed', 'error');
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    this.showToast('Registration failed: ' + error.message, 'error');
                }
            },

            logout() {
                this.state.jwtToken = null;
                this.state.userEmail = null;
                this.state.notes = [];
                localStorage.removeItem('alfred_jwt_token');
                localStorage.removeItem('alfred_user_email');
                this.showAuthModal();
                this.showToast('Logged out successfully', 'success');
            },

            showAuthModal() {
                const modal = document.getElementById('authModal');
                if (modal) modal.classList.remove('hidden');
            },

            hideAuthModal() {
                const modal = document.getElementById('authModal');
                if (modal) modal.classList.add('hidden');
            },

            showLogin() {
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('registerForm').style.display = 'none';
            },

            showRegister() {
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('registerForm').style.display = 'block';
            },

            loadUserInfo() {
                const userEmailEl = document.getElementById('userEmail');
                if (userEmailEl) {
                    userEmailEl.textContent = this.state.userEmail || 'User';
                }
            },

            // Recording
            async toggleRecording() {
                if (this.state.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            },

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.state.mediaRecorder = new MediaRecorder(stream);
                    this.state.audioChunks = [];
                    this.state.recordingStartTime = Date.now();

                    this.state.mediaRecorder.ondataavailable = (event) => {
                        this.state.audioChunks.push(event.data);
                    };

                    this.state.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };

                    this.state.mediaRecorder.start();
                    this.state.isRecording = true;

                    // Update UI
                    document.getElementById('recordButton').classList.add('recording');
                    const recordIcon = document.getElementById('recordIcon');
                    if (recordIcon) {
                        recordIcon.innerHTML = '<img src="icons/noun-microphone-7208171.svg" alt="Recording" class="icon-record">';
                    }
                    document.getElementById('recordingPanel').classList.add('active');
                    this.startRecordingTimer();

                    console.log('🎙️ Recording started');
                } catch (error) {
                    console.error('Error starting recording:', error);
                    this.showToast('Failed to access microphone', 'error');
                }
            },

            stopRecording() {
                if (this.state.mediaRecorder && this.state.isRecording) {
                    this.state.mediaRecorder.stop();
                    this.state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.state.isRecording = false;

                    // Update UI
                    document.getElementById('recordButton').classList.remove('recording');
                    const recordIcon = document.getElementById('recordIcon');
                    if (recordIcon) {
                        recordIcon.innerHTML = '<img src="icons/noun-microphone-7208171.svg" alt="Record" class="icon-record">';
                    }
                    document.getElementById('recordingPanel').classList.remove('active');
                    this.stopRecordingTimer();

                    console.log('⏹️ Recording stopped');
                }
            },

            startRecordingTimer() {
                this.recordingTimerInterval = setInterval(() => {
                    const elapsed = Date.now() - this.state.recordingStartTime;
                    const seconds = Math.floor(elapsed / 1000);
                    const minutes = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    document.getElementById('recordingTimer').textContent = 
                        `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }, 1000);
            },

            stopRecordingTimer() {
                if (this.recordingTimerInterval) {
                    clearInterval(this.recordingTimerInterval);
                    this.recordingTimerInterval = null;
                }
            },

            // Home Mode Switching (Record vs Upload)
            switchHomeMode(mode) {
                this.state.homeMode = mode;
                
                // Update toggle buttons
                document.querySelectorAll('.mode-toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                // Show/hide appropriate mode content
                document.getElementById('recordMode').style.display = mode === 'record' ? 'flex' : 'none';
                document.getElementById('uploadMode').style.display = mode === 'upload' ? 'flex' : 'none';
                
                console.log('🔄 Switched to', mode, 'mode');
            },

            // Audio File Upload
            handleAudioFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Validate file type
                const validTypes = ['audio/mp3', 'audio/mpeg', 'audio/mp4', 'audio/x-m4a', 'audio/wav', 'audio/webm', 'audio/flac', 'audio/ogg'];
                if (!validTypes.some(type => file.type.includes(type.split('/')[1]))) {
                    this.showToast('Invalid file type. Please select an audio file.', 'error');
                    return;
                }
                
                this.state.selectedAudioFile = file;
                
                // Update UI to show file selected
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.innerHTML = `
                    <img src="icons/noun-microphone-7208171.svg" alt="Audio" style="width: 48px; height: 48px; opacity: 0.7; margin-bottom: 12px;">
                    <div class="upload-text" style="color: var(--accent-cyan);">✓ ${file.name}</div>
                    <div class="upload-formats">${(file.size / (1024 * 1024)).toFixed(2)} MB</div>
                    <div style="margin-top: 12px; font-size: 12px; color: var(--text-tertiary); cursor: pointer;" onclick="alfredApp.clearAudioFile()">Click to select a different file</div>
                `;
                
                // Show form fields
                document.getElementById('uploadFormFields').style.display = 'block';
                
                // Set default times (now and now + 5 minutes)
                const now = new Date();
                const endTime = new Date(now.getTime() + 5 * 60000);
                document.getElementById('uploadStartTime').value = now.toISOString().slice(0, 16);
                document.getElementById('uploadEndTime').value = endTime.toISOString().slice(0, 16);
                
                console.log('📁 File selected:', file.name, file.type, file.size);
            },

            clearAudioFile() {
                this.state.selectedAudioFile = null;
                document.getElementById('audioFileInput').value = '';
                
                // Reset upload area
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.innerHTML = `
                    <img src="icons/noun-microphone-7208171.svg" alt="Upload" style="width: 48px; height: 48px; opacity: 0.5; margin-bottom: 12px;">
                    <div class="upload-text">Click to select or drag & drop audio file</div>
                    <div class="upload-formats">Supports: MP3, M4A, WAV, WebM, FLAC, OGG</div>
                `;
                
                // Hide form fields
                document.getElementById('uploadFormFields').style.display = 'none';
            },

            async uploadAudioFile() {
                if (!this.state.selectedAudioFile) {
                    this.showToast('Please select an audio file first', 'error');
                    return;
                }
                
                if (!this.state.jwtToken) {
                    this.showToast('Please login first', 'error');
                    this.showAuthModal();
                    return;
                }
                
                try {
                    console.log('📤 Uploading audio file...');
                    this.showToast('Uploading and processing audio...', 'info');
                    
                    // Get form values
                    const startTime = document.getElementById('uploadStartTime').value;
                    const endTime = document.getElementById('uploadEndTime').value;
                    const noteType = this.state.selectedTemplate;
                    const deviceType = document.getElementById('uploadDeviceType').value;
                    const participantNames = document.getElementById('uploadParticipantNames').value;
                    const participantRoles = document.getElementById('uploadParticipantRoles').value;
                    const addToWebServer = document.getElementById('uploadAddToWebServer').checked;
                    const addToBitTorrent = document.getElementById('uploadAddToBitTorrent').checked;
                    
                    // Validate required fields
                    if (!startTime || !endTime) {
                        this.showToast('Please fill in start and end times', 'error');
                        return;
                    }
                    
                    // Convert times to ISO format
                    const startTimeISO = new Date(startTime).toISOString();
                    const endTimeISO = new Date(endTime).toISOString();
                    
                    // Build form data
                    const formData = new FormData();
                    formData.append('audio', this.state.selectedAudioFile);
                    formData.append('start_time', startTimeISO);
                    formData.append('end_time', endTimeISO);
                    formData.append('note_type', noteType);
                    formData.append('device_type', deviceType);
                    formData.append('model', this.state.settings.model || 'parallel');
                    formData.append('addToWebServer', addToWebServer ? 'true' : 'false');
                    formData.append('addToBitTorrent', addToBitTorrent ? 'true' : 'false');
                    
                    // Add participants if provided
                    if (participantNames.trim()) {
                        formData.append('participant_display_names', JSON.stringify(
                            participantNames.split(',').map(n => n.trim()).filter(n => n)
                        ));
                    }
                    if (participantRoles.trim()) {
                        formData.append('participant_roles', JSON.stringify(
                            participantRoles.split(',').map(r => r.trim()).filter(r => r)
                        ));
                    }
                    
                    // Upload to backend
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/notes/from-audio`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        },
                        body: formData
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast('Note created successfully!', 'success');
                        this.clearAudioFile();
                        this.switchHomeMode('record'); // Switch back to record mode
                        this.loadNotes(); // Refresh notes list
                    } else {
                        this.showToast('Failed to create note: ' + (data.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Upload error:', error);
                    this.showToast('Failed to upload note', 'error');
                }
            },

            async processRecording() {
                const audioBlob = new Blob(this.state.audioChunks, { type: 'audio/webm' });
                const endTime = Date.now();
                
                // Capture participant data before clearing UI
                const participantsData = this.getParticipantsData();
                
                // Clear participants from UI immediately
                this.clearParticipants();
                
                this.showToast('Processing recording...', 'success');

                try {
                    await this.uploadNote(audioBlob, this.state.recordingStartTime, endTime, participantsData);
                } catch (error) {
                    console.error('Error processing recording:', error);
                    this.showToast('Failed to process recording', 'error');
                }
            },

            async uploadNote(audioBlob, startTime, endTime, participantsData = null) {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                formData.append('start_time', new Date(startTime).toISOString());
                formData.append('end_time', new Date(endTime).toISOString());
                formData.append('note_type', this.state.selectedTemplate); // Keep uppercase - backend expects: MEETING, ONE_ON_ONE, STANDUP, IDEA, REFLECTION, INTERVIEW, OTHER
                formData.append('device_type', 'OTHER'); // Backend expects: IPHONE, MAC, WATCH, OTHER
                formData.append('model', this.state.settings.model);
                formData.append('addToWebServer', this.state.settings.webServerUpload);

                // Add participants if provided
                if (participantsData) {
                    const { names, roles } = participantsData;
                    if (names.length > 0) {
                        formData.append('participant_display_names', JSON.stringify(names));
                    }
                    if (roles.length > 0) {
                        formData.append('participant_roles', JSON.stringify(roles));
                    }
                }

                try {
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/notes/from-audio`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        },
                        body: formData
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast('Note created successfully!', 'success');
                        this.loadNotes();
                    } else {
                        this.showToast('Failed to create note: ' + (data.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Upload error:', error);
                    this.showToast('Failed to upload note', 'error');
                }
            },

            // Notes Management
            async loadNotes() {
                if (!this.state.jwtToken) return;

                try {
                    console.log('📝 Loading notes...');
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/records?source=gun&recordType=notes&limit=50&sortBy=date:desc`, {
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        }
                    });

                    const data = await response.json();
                    console.log('📝 Notes API response:', {
                        recordCount: data.records?.length || 0,
                        authenticated: data.auth?.authenticated,
                        sampleNote: data.records?.[0] ? {
                            hasDid: !!data.records[0].did,
                            hasOipDid: !!data.records[0].oip?.did,
                            didValue: data.records[0].oip?.did || data.records[0].did
                        } : null
                    });
                    
                    if (data.records) {
                        this.state.notes = data.records;
                        this.renderNotesList();
                        console.log(`✅ Loaded ${data.records.length} notes`);
                    } else {
                        console.warn('⚠️ No records in response');
                    }
                } catch (error) {
                    console.error('❌ Error loading notes:', error);
                }
            },

            async refreshNotesFromBackend() {
                if (!this.state.jwtToken) {
                    this.showToast('Please login first', 'error');
                    return;
                }

                try {
                    console.log('🔄 Refreshing notes from backend...');
                    this.showToast('Fetching notes from backend...', 'info');
                    
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/records?recordType=notes&source=gun&sortBy=date:desc`, {
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('🔄 Backend response:', {
                        recordCount: data.records?.length || 0,
                        authenticated: data.auth?.authenticated
                    });
                    
                    if (data.records && data.records.length > 0) {
                        // Get existing DIDs to avoid duplicates
                        const existingDids = new Set(
                            this.state.notes.map(note => note.oip?.did || note.did).filter(Boolean)
                        );

                        // Filter out notes that already exist
                        const newNotes = data.records.filter(note => {
                            const noteDid = note.oip?.did || note.did;
                            return noteDid && !existingDids.has(noteDid);
                        });

                        if (newNotes.length > 0) {
                            // Add new notes to the beginning of the list
                            this.state.notes = [...newNotes, ...this.state.notes];
                            this.renderNotesList();
                            console.log(`✅ Added ${newNotes.length} new notes from backend`);
                            this.showToast(`Added ${newNotes.length} new note${newNotes.length > 1 ? 's' : ''} from backend`, 'success');
                        } else {
                            console.log('ℹ️ No new notes found on backend');
                            this.showToast('No new notes found on backend', 'info');
                        }
                    } else {
                        console.log('ℹ️ No notes returned from backend');
                        this.showToast('No notes found on backend', 'info');
                    }
                } catch (error) {
                    console.error('❌ Error refreshing notes from backend:', error);
                    this.showToast(`Failed to refresh: ${error.message}`, 'error');
                }
            },

            renderNotesList() {
                const notesList = document.getElementById('notesList');
                if (!notesList) return;

                if (this.state.notes.length === 0) {
                    notesList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <img src="icons/noun-notes-7945433.svg" alt="No notes">
                            </div>
                            <div class="empty-text">No notes yet. Start recording!</div>
                        </div>
                    `;
                    return;
                }

                notesList.innerHTML = this.state.notes.map(note => {
                    const basic = note.data?.basic || {};
                    const noteData = note.data?.notes || {};
                    const date = basic.date ? new Date(basic.date * 1000).toLocaleDateString() : 'Unknown';
                    const duration = noteData.audio_ref ? '5m' : 'N/A';
                    const preview = basic.description || noteData.summary_key_points?.[0] || 'No preview available';
                    
                    // Convert enum CODE to display name
                    const noteTypeDisplay = this.getEnumDisplayName(noteData.note_type, 'note_type');

                    // Get DID from correct location (oip.did or top-level did for backward compatibility)
                    const noteDid = note.oip?.did || note.did;
                    
                    return `
                        <div class="note-card" onclick="alfredApp.viewNote('${noteDid}')">
                            <div class="note-header">
                                <div class="note-title">${basic.name || 'Untitled Note'}</div>
                                <div class="note-badge">
                                    <img src="icons/noun-notes-7945433.svg" alt="" class="icon-note-badge">
                                    ${noteTypeDisplay || 'note'}
                                </div>
                            </div>
                            <div class="note-preview">${preview.substring(0, 150)}...</div>
                            <div class="note-meta">
                                <span><img src="icons/noun-calendar-8032539.svg" alt="Date" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; opacity: 0.7;"> ${date}</span>
                                <span>⏱️ ${duration}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            async viewNote(noteDid) {
                try {
                    console.log('📖 Viewing note with DID:', noteDid);
                    
                    if (!noteDid || noteDid === 'undefined') {
                        console.error('❌ Invalid DID:', noteDid);
                        this.showToast('Invalid note ID', 'error');
                        return;
                    }
                    
                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/records?source=gun&did=${noteDid}`, {
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        }
                    });

                    const data = await response.json();
                    
                    if (data.records && data.records[0]) {
                        console.log('✅ Note loaded successfully');
                        this.state.currentNote = data.records[0];
                        this.renderNoteDetail();
                        this.showView('noteDetailView');
                    } else {
                        console.warn('⚠️ No note found with DID:', noteDid);
                        this.showToast('Note not found', 'error');
                    }
                } catch (error) {
                    console.error('❌ Error loading note:', error);
                    this.showToast('Failed to load note', 'error');
                }
            },

            renderNoteDetail() {
                if (!this.state.currentNote) return;

                const basic = this.state.currentNote.data?.basic || {};
                const noteData = this.state.currentNote.data?.notes || {};

                document.getElementById('noteDetailTitle').textContent = basic.name || 'Untitled Note';
                document.getElementById('noteDetailDate').textContent = 
                    basic.date ? new Date(basic.date * 1000).toLocaleDateString() : 'Unknown';
                document.getElementById('noteDetailDuration').textContent = '5m';

                // Key Summary
                const keySummary = document.getElementById('keySummary');
                if (keySummary) {
                    const keyPoints = noteData.summary_key_points || [];
                    keySummary.innerHTML = keyPoints.length > 0 
                        ? keyPoints.map(point => `<li>${point}</li>`).join('')
                        : '<li>No key points available</li>';
                }

                // Action Items
                const actionItems = document.getElementById('actionItems');
                if (actionItems) {
                    const actions = noteData.summary_action_item_texts || [];
                    actionItems.innerHTML = actions.length > 0
                        ? actions.map(action => `<li>${action}</li>`).join('')
                        : '<li>No action items</li>';
                }

                // Open Questions
                const openQuestions = document.getElementById('openQuestions');
                if (openQuestions) {
                    const questions = noteData.summary_open_questions || [];
                    openQuestions.innerHTML = questions.length > 0
                        ? questions.map(q => `<li>${q}</li>`).join('')
                        : '<li>No open questions</li>';
                }
            },

            async fillMissingAnalysis() {
                if (!this.state.currentNote) {
                    this.showToast('No note loaded', 'error');
                    return;
                }

                try {
                    console.log('🔍 Filling in missing analysis...');
                    this.showToast('Analyzing note content...', 'info');

                    const noteData = this.state.currentNote.data?.notes || {};
                    
                    // Check if transcript DID exists
                    const transcriptDid = noteData.transcript_full_text;
                    if (!transcriptDid) {
                        this.showToast('No transcript available for this note', 'error');
                        return;
                    }

                    // Fetch the transcript
                    console.log('📄 Fetching transcript:', transcriptDid);
                    const transcriptResponse = await fetch(`${this.state.settings.apiBaseUrl}/api/records?recordType=text&source=gun&did=${transcriptDid}`, {
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        }
                    });

                    const transcriptData = await transcriptResponse.json();
                    const transcriptText = transcriptData.records?.[0]?.data?.text?.value;
                    
                    if (!transcriptText) {
                        this.showToast('Could not retrieve transcript text', 'error');
                        return;
                    }

                    console.log('✅ Transcript retrieved, length:', transcriptText.length);

                    // Format participants
                    const participantNames = noteData.participant_display_names || [];
                    const participantRoles = noteData.participant_roles || [];
                    
                    let participantsFormatted = '';
                    if (participantNames.length > 0) {
                        participantsFormatted = participantNames.map((name, idx) => {
                            const role = participantRoles[idx] || '';
                            return role ? `${name} (${role})` : name;
                        }).join(', ');
                    } else if (participantRoles.length > 0) {
                        participantsFormatted = participantRoles.join(', ');
                    }

                    // Identify empty fields
                    const fieldsToFill = [];
                    const fieldChecks = {
                        'summary_key_points': noteData.summary_key_points,
                        'summary_decisions': noteData.summary_decisions,
                        'summary_action_item_texts': noteData.summary_action_item_texts,
                        'summary_action_item_assignees': noteData.summary_action_item_assignees,
                        'summary_action_item_due_texts': noteData.summary_action_item_due_texts,
                        'summary_open_questions': noteData.summary_open_questions,
                        'topics_auto': noteData.topics_auto,
                        'keywords_auto': noteData.keywords_auto
                    };

                    for (const [field, value] of Object.entries(fieldChecks)) {
                        if (!value || (Array.isArray(value) && value.length === 0)) {
                            fieldsToFill.push(field);
                        }
                    }

                    if (fieldsToFill.length === 0) {
                        this.showToast('All analysis fields are already filled', 'info');
                        return;
                    }

                    console.log('📋 Fields to fill:', fieldsToFill);

                    // Build LLM prompt
                    const prompt = `Analyze this meeting transcript and provide missing analysis fields.

TRANSCRIPT:
${transcriptText}

${participantsFormatted ? `PARTICIPANTS: ${participantsFormatted}\n` : ''}
MISSING FIELDS TO FILL: ${fieldsToFill.join(', ')}

Please provide a JSON object with ONLY the missing fields from this list:
- summary_key_points: array of key discussion points (3-7 items)
- summary_decisions: array of decisions made (if any)
- summary_action_item_texts: array of action items identified
- summary_action_item_assignees: array of who is responsible (parallel to action_item_texts, use "unassigned" if unclear)
- summary_action_item_due_texts: array of due dates (parallel to action_item_texts, use "no date" if not specified)
- summary_open_questions: array of unresolved questions or issues
- topics_auto: array of high-level topics discussed (3-5 items)
- keywords_auto: array of important keywords and concepts (5-10 items)

Return ONLY a JSON object with the missing fields. Example format:
{
  "summary_key_points": ["point 1", "point 2"],
  "summary_decisions": ["decision 1"],
  "topics_auto": ["topic1", "topic2"]
}

JSON:`;

                    // Call LLM
                    console.log('🤖 Calling LLM for analysis...');
                    const llmResponse = await fetch(`${this.state.settings.apiBaseUrl}/api/alfred/generate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.state.jwtToken}`
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            model: this.state.settings.model || 'llama3.2:3b'
                        })
                    });

                    const llmData = await llmResponse.json();
                    let analysis;

                    try {
                        // Try to parse JSON from response
                        const jsonMatch = llmData.response.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            analysis = JSON.parse(jsonMatch[0]);
                        } else {
                            throw new Error('No JSON found in response');
                        }
                    } catch (parseError) {
                        console.error('❌ Failed to parse LLM response:', parseError);
                        this.showToast('Failed to parse analysis results', 'error');
                        return;
                    }

                    console.log('✅ Analysis received:', Object.keys(analysis));

                    // Update the current note with new analysis
                    for (const [field, value] of Object.entries(analysis)) {
                        if (fieldsToFill.includes(field) && value) {
                            this.state.currentNote.data.notes[field] = value;
                        }
                    }

                    // Re-render the note detail view
                    this.renderNoteDetail();
                    
                    this.showToast(`Filled in ${Object.keys(analysis).length} missing field(s)`, 'success');
                    console.log('✅ Missing analysis fields filled successfully');

                    // TODO: Optionally save the updated note back to the backend
                    // This would require a PATCH endpoint for notes

                } catch (error) {
                    console.error('❌ Error filling missing analysis:', error);
                    this.showToast(`Failed to fill analysis: ${error.message}`, 'error');
                }
            },

            // Chat
            chatAboutNote() {
                if (!this.state.currentNote) return;
                
                // Store the note DID for selected note mode
                this.state.selectedNoteForChat = this.state.currentNote.did || this.state.currentNote.oip?.did;
                
                // Set mode to 'selected'
                this.state.chatMode = 'selected';
                
                // Clear conversation history for new note chat
                this.state.conversationHistory = [];
                
                // Show and activate the "Selected Note" button
                const selectedNoteBtn = document.getElementById('selectedNoteBtn');
                if (selectedNoteBtn) {
                    selectedNoteBtn.style.display = 'block';
                }
                
                // Update toggle buttons to show "Selected Note" as active
                document.querySelectorAll('.chat-toggle-btn[data-mode]').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === 'selected') {
                        btn.classList.add('active');
                    }
                });
                
                // Initialize chat view with note context
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.innerHTML = '';
                    
                    const noteName = this.state.currentNote.data?.basic?.name || 'Untitled';
                    const welcomeMessage = document.createElement('div');
                    welcomeMessage.className = 'message';
                    welcomeMessage.innerHTML = `
                        <div class="message-avatar">A</div>
                        <div class="message-content">
                            <div class="message-text">Hello! I've analyzed your note "${noteName}". Ask me anything about it - I have access to the full transcript, summary, and related content.</div>
                        </div>
                    `;
                    chatMessages.appendChild(welcomeMessage);
                }
                
                // Update placeholder
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    const noteName = this.state.currentNote.data?.basic?.name || 'this note';
                    chatInput.placeholder = `Ask about "${noteName}"...`;
                }
                
                this.showView('chatView', true); // Keep context
            },

            async sendMessage() {
                const input = document.getElementById('chatInput');
                const question = input.value.trim();
                if (!question) return;

                input.value = '';

                this.addMessage('user', question);

                // Add to conversation history
                this.state.conversationHistory.push({
                    role: 'user',
                    content: question
                });

                try {
                    // Always use /api/notes/converse (will add audio support to backend)
                    const requestBody = {
                        question: question,
                        model: this.state.settings.model,
                        conversationHistory: this.state.conversationHistory.slice(-10)
                    };
                    
                    // Add note DID if in selected note mode
                    if (this.state.chatMode === 'selected' && this.state.selectedNoteForChat) {
                        requestBody.noteDid = this.state.selectedNoteForChat;
                        console.log('📝 Selected Note mode - using DID:', this.state.selectedNoteForChat);
                    } else if (this.state.chatMode === 'notes') {
                        requestBody.allNotes = true;
                        console.log('📚 All Notes mode - searching all notes');
                    } else {
                        requestBody.allNotes = false;
                        console.log('💬 Chat mode - pure LLM');
                    }
                    
                    // Add audio parameters if audio is enabled
                    if (this.state.settings.audioEnabled) {
                        requestBody.return_audio = true;
                        requestBody.engine = 'elevenlabs';
                        requestBody.voice_id = 'onwK4e9ZLuTAKqWW03F9';
                        requestBody.speed = 1;
                        
                        console.log('🎤 Audio enabled - requesting audio response');
                    }
                    
                    console.log('🚀 Sending request to /api/notes/converse:', requestBody);

                    const response = await fetch(`${this.state.settings.apiBaseUrl}/api/notes/converse`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.state.jwtToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('📥 Response from /api/notes/converse:', data);

                    if (data.success) {
                        const answer = data.answer || 'No response';
                        const audioData = data.audio_data;
                        
                        // Add message with optional audio (auto-play is handled in addMessage)
                        this.addMessage('assistant', answer, audioData);
                        
                        // Add assistant response to history
                        this.state.conversationHistory.push({
                            role: 'assistant',
                            content: answer
                        });
                    } else {
                        this.addMessage('assistant', 'Sorry, I encountered an error: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Chat error:', error);
                    this.addMessage('assistant', 'Sorry, I encountered an error connecting to the service.');
                }
            },

            async handleStreamingResponse(dialogueId, userQuestion) {
                console.log('🎯 Opening SSE stream for dialogueId:', dialogueId);
                const streamUrl = `${this.state.settings.apiBaseUrl}/api/voice/open-stream?dialogueId=${dialogueId}`;
                const eventSource = new EventSource(streamUrl);
                
                let accumulatedText = '';
                let filteredText = '';
                let assistantMessageDiv = null;
                let audioChunks = [];
                let audioPlaybackStarted = false;
                let questionFiltered = false;
                
                // Reset stream state
                this.state.streamComplete = false;
                this.state.isStreamingAudio = false;

                eventSource.addEventListener('textChunk', (event) => {
                    try {
                        const chunkData = JSON.parse(event.data);
                        console.log('📝 Text chunk received:', chunkData.text);
                        accumulatedText += chunkData.text || '';
                        
                        // Filter out the user's question if it appears at the beginning
                        let displayText = accumulatedText;
                        if (!questionFiltered && userQuestion) {
                            // Check if the accumulated text starts with the user's question
                            const questionLower = userQuestion.toLowerCase();
                            const accumulatedLower = accumulatedText.toLowerCase();
                            
                            if (accumulatedLower.startsWith(questionLower)) {
                                displayText = accumulatedText.substring(userQuestion.length).trim();
                                questionFiltered = true;
                                console.log('🧹 Filtered out repeated question from response');
                            } else if (accumulatedLower.includes(questionLower) && accumulatedText.length < userQuestion.length + 50) {
                                // Sometimes the question might be slightly modified (punctuation, etc.)
                                const questionIndex = accumulatedLower.indexOf(questionLower);
                                if (questionIndex === 0 || questionIndex === 1) {
                                    displayText = accumulatedText.substring(questionIndex + userQuestion.length).trim();
                                    questionFiltered = true;
                                    console.log('🧹 Filtered out repeated question from response (with offset)');
                                }
                            }
                        }
                        
                        // Update existing message or create new one
                        if (!assistantMessageDiv) {
                            const chatMessages = document.getElementById('chatMessages');
                            assistantMessageDiv = document.createElement('div');
                            assistantMessageDiv.className = 'message assistant';
                            
                            const avatarDiv = document.createElement('div');
                            avatarDiv.className = 'message-avatar';
                            avatarDiv.textContent = this.state.currentAI === 'alice' ? 'L' : 'A';
                            
                            const contentDiv = document.createElement('div');
                            contentDiv.className = 'message-content';
                            contentDiv.innerHTML = `<div class="message-text"></div>`;
                            
                            assistantMessageDiv.appendChild(avatarDiv);
                            assistantMessageDiv.appendChild(contentDiv);
                            chatMessages.appendChild(assistantMessageDiv);
                        }
                        
                        // Store the filtered text for conversation history
                        filteredText = displayText;
                        
                        // Update message text with filtered content
                        const messageText = assistantMessageDiv.querySelector('.message-text');
                        if (messageText) {
                            messageText.innerHTML = displayText.replace(/\n/g, '<br>');
                        }
                        
                        // Scroll to bottom
                        const chatMessages = document.getElementById('chatMessages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    } catch (error) {
                        console.error('Error processing text chunk:', error);
                    }
                });

                eventSource.addEventListener('audioChunk', async (event) => {
                    try {
                        const chunkData = JSON.parse(event.data);
                        console.log('🎵 Audio chunk received:', chunkData.audio ? `${chunkData.audio.length} chars` : 'no audio');
                        
                        if (chunkData.audio && this.state.settings.audioEnabled) {
                            audioChunks.push(chunkData.audio);
                            console.log(`📦 Audio chunk ${audioChunks.length} queued`);
                            
                            // Start audio playback with the first chunk if not already started
                            if (!audioPlaybackStarted) {
                                audioPlaybackStarted = true;
                                console.log('🎵 Starting sequential audio playback...');
                                this.playStreamedAudioSequentially(audioChunks);
                            }
                        }
                    } catch (error) {
                        console.error('Error processing audio chunk:', error);
                    }
                });

                eventSource.addEventListener('complete', (event) => {
                    console.log('🎉 Stream complete event received');
                    eventSource.close();
                    
                    // Add assistant response to history (use filtered text to avoid duplicating the question)
                    this.state.conversationHistory.push({
                        role: 'assistant',
                        content: filteredText || accumulatedText
                    });
                    
                    // Signal that streaming is complete (audio playback will finish playing remaining chunks)
                    this.state.streamComplete = true;
                    console.log(`✅ Stream complete. Total audio chunks: ${audioChunks.length}`);
                    console.log('✅ Conversation updated. Total messages:', this.state.conversationHistory.length);
                });

                eventSource.addEventListener('error', (event) => {
                    console.error('❌ EventSource error:', event);
                    eventSource.close();
                    this.state.isStreamingAudio = false;
                    this.stopSoundwaveVisualization();
                    
                    if (!assistantMessageDiv || !accumulatedText) {
                        this.addMessage('assistant', 'Sorry, there was an error streaming the response.');
                    }
                });
            },

            combineAudioChunks(chunks) {
                // For now, just return the first chunk
                // In a more sophisticated implementation, you could concatenate WAV files
                return chunks[0];
            },

            async playStreamedAudioSequentially(audioChunksArray) {
                if (!audioChunksArray || audioChunksArray.length === 0) return;
                
                console.log('🎵 Starting sequential audio playback with real-time analysis');
                
                // Initialize Web Audio API for audio analysis
                if (!this.state.audioContext) {
                    this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (!this.state.audioAnalyser) {
                    this.state.audioAnalyser = this.state.audioContext.createAnalyser();
                    this.state.audioAnalyser.fftSize = 64; // Small FFT for 16 bars
                    this.state.audioAnalyser.smoothingTimeConstant = 0.8;
                }
                
                let currentChunkIndex = 0;
                this.state.isStreamingAudio = true;
                this.state.streamComplete = false;
                
                const playNextChunk = async () => {
                    // If we've played all available chunks, check if more are coming
                    if (currentChunkIndex >= audioChunksArray.length) {
                        // Wait a bit to see if more chunks arrive
                        if (!this.state.streamComplete) {
                            console.log('⏳ Waiting for more audio chunks...');
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // Check again
                            if (currentChunkIndex >= audioChunksArray.length && !this.state.streamComplete) {
                                // Still no new chunks, wait a bit more
                                await new Promise(resolve => setTimeout(resolve, 300));
                            }
                        }
                        
                        // Final check - if still no chunks and stream is complete, we're done
                        if (currentChunkIndex >= audioChunksArray.length) {
                            console.log('🎵 All audio chunks played');
                            this.stopSoundwaveVisualization();
                            this.state.isStreamingAudio = false;
                            
                            // Disconnect audio source
                            if (this.state.audioSource) {
                                try {
                                    this.state.audioSource.disconnect();
                                    this.state.audioSource = null;
                                } catch (e) {
                                    console.log('Audio source already disconnected');
                                }
                            }
                            return;
                        }
                    }
                    
                    const audioData = audioChunksArray[currentChunkIndex];
                    console.log(`🎵 Playing chunk ${currentChunkIndex + 1} of ${audioChunksArray.length}`);
                    currentChunkIndex++;
                    
                    try {
                        // Convert base64 to blob
                        const binaryString = atob(audioData);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const blob = new Blob([bytes], { type: 'audio/wav' });
                        const audioUrl = URL.createObjectURL(blob);
                        
                        // Create audio element
                        const audio = new Audio(audioUrl);
                        this.state.currentAudio = audio;
                        
                        // Connect to Web Audio API for analysis
                        // Disconnect previous source if exists
                        if (this.state.audioSource) {
                            try {
                                this.state.audioSource.disconnect();
                            } catch (e) {
                                console.log('Previous audio source already disconnected');
                            }
                        }
                        
                        // Create new media element source and connect it
                        try {
                            this.state.audioSource = this.state.audioContext.createMediaElementSource(audio);
                            this.state.audioSource.connect(this.state.audioAnalyser);
                            this.state.audioAnalyser.connect(this.state.audioContext.destination);
                        } catch (error) {
                            console.error('Error connecting audio for analysis:', error);
                            // Fallback: play audio without visualization
                        }
                        
                        // Start visualization on first chunk
                        if (currentChunkIndex === 1) {
                            this.startSoundwaveVisualization();
                        }
                        
                        // Wait for audio to finish before playing next chunk
                        await new Promise((resolve, reject) => {
                            audio.onended = () => {
                                console.log(`✅ Chunk ${currentChunkIndex} finished`);
                                URL.revokeObjectURL(audioUrl);
                                resolve();
                            };
                            
                            audio.onerror = (error) => {
                                console.error('Error playing audio chunk:', error);
                                URL.revokeObjectURL(audioUrl);
                                reject(error);
                            };
                            
                            audio.play().catch(reject);
                        });
                        
                        // Play next chunk after this one finishes
                        playNextChunk();
                        
                    } catch (error) {
                        console.error('Error processing audio chunk:', error);
                        this.stopSoundwaveVisualization();
                        this.state.isStreamingAudio = false;
                        
                        if (this.state.audioSource) {
                            try {
                                this.state.audioSource.disconnect();
                                this.state.audioSource = null;
                            } catch (e) {
                                console.log('Audio source already disconnected');
                            }
                        }
                    }
                };
                
                // Start playing the first chunk
                playNextChunk();
            },

            addMessage(role, text, audioData = null) {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'message-avatar';
                avatarDiv.textContent = role === 'user' ? 'U' : (this.state.currentAI === 'alice' ? 'L' : 'A');

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                // Convert newlines to <br> tags and preserve formatting
                const formattedText = text.replace(/\n/g, '<br>');
                contentDiv.innerHTML = `<div class="message-text">${formattedText}</div>`;

                // Add speaker button for assistant messages with audio
                if (role === 'assistant' && audioData) {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'message-actions';
                    
                    const speakerBtn = document.createElement('button');
                    speakerBtn.className = 'speaker-button';
                    speakerBtn.innerHTML = `
                        <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                            <path d="M15.54 8.46a5 5 0 010 7.07"/>
                            <path d="M19.07 4.93a10 10 0 010 14.14"/>
                        </svg>
                        <span>Play</span>
                    `;
                    speakerBtn.onclick = () => this.playAudio(audioData, speakerBtn);
                    
                    actionsDiv.appendChild(speakerBtn);
                    contentDiv.appendChild(actionsDiv);
                    
                    // Auto-play if enabled (check both audioEnabled and autoPlay settings)
                    if (this.state.settings.audioEnabled && this.state.settings.autoPlay) {
                        console.log('🎵 Auto-playing audio response');
                        setTimeout(() => this.playAudio(audioData, speakerBtn), 100);
                    }
                }

                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);
                chatMessages.appendChild(messageDiv);

                chatMessages.scrollTop = chatMessages.scrollHeight;
            },

            playAudio(audioDataBase64, buttonElement) {
                // If already playing, stop
                if (this.state.currentAudio && !this.state.currentAudio.paused) {
                    this.state.currentAudio.pause();
                    this.state.currentAudio.currentTime = 0;
                    if (this.state.currentAudioButton) {
                        this.state.currentAudioButton.classList.remove('playing');
                        this.state.currentAudioButton.innerHTML = `
                            <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                                <path d="M15.54 8.46a5 5 0 010 7.07"/>
                                <path d="M19.07 4.93a10 10 0 010 14.14"/>
                            </svg>
                            <span>Play</span>
                        `;
                    }
                    // Stop visualization when pausing
                    this.stopSoundwaveVisualization();
                    if (this.state.currentAudioButton === buttonElement) {
                        this.state.currentAudio = null;
                        this.state.currentAudioButton = null;
                        return;
                    }
                }

                try {
                    // Initialize Web Audio API for audio analysis
                    if (!this.state.audioContext) {
                        this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    if (!this.state.audioAnalyser) {
                        this.state.audioAnalyser = this.state.audioContext.createAnalyser();
                        this.state.audioAnalyser.fftSize = 64;
                        this.state.audioAnalyser.smoothingTimeConstant = 0.8;
                    }
                    
                    // Convert base64 to blob
                    const binaryString = atob(audioDataBase64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const blob = new Blob([bytes], { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(blob);

                    // Create audio element
                    const audio = new Audio(audioUrl);
                    this.state.currentAudio = audio;
                    this.state.currentAudioButton = buttonElement;
                    
                    // Connect to Web Audio API for analysis
                    // Disconnect previous source if exists
                    if (this.state.audioSource) {
                        try {
                            this.state.audioSource.disconnect();
                        } catch (e) {
                            console.log('Previous audio source already disconnected');
                        }
                    }
                    
                    // Create new media element source and connect it
                    try {
                        this.state.audioSource = this.state.audioContext.createMediaElementSource(audio);
                        this.state.audioSource.connect(this.state.audioAnalyser);
                        this.state.audioAnalyser.connect(this.state.audioContext.destination);
                    } catch (error) {
                        console.error('Error connecting audio for analysis:', error);
                        // Fallback: play audio without visualization
                    }
                    
                    this.state.isStreamingAudio = true;

                    buttonElement.classList.add('playing');
                    buttonElement.innerHTML = `
                        <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="6" y="4" width="4" height="16"/>
                            <rect x="14" y="4" width="4" height="16"/>
                        </svg>
                        <span>Pause</span>
                    `;

                    // Start sound wave visualization
                    this.startSoundwaveVisualization();

                    audio.onended = () => {
                        buttonElement.classList.remove('playing');
                        buttonElement.innerHTML = `
                            <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                                <path d="M15.54 8.46a5 5 0 010 7.07"/>
                                <path d="M19.07 4.93a10 10 0 010 14.14"/>
                            </svg>
                            <span>Play</span>
                        `;
                        URL.revokeObjectURL(audioUrl);
                        this.state.currentAudio = null;
                        this.state.currentAudioButton = null;
                        this.state.isStreamingAudio = false;
                        
                        // Stop sound wave visualization
                        this.stopSoundwaveVisualization();
                        
                        // Disconnect audio source
                        if (this.state.audioSource) {
                            try {
                                this.state.audioSource.disconnect();
                                this.state.audioSource = null;
                            } catch (e) {
                                console.log('Audio source already disconnected');
                            }
                        }
                    };

                    audio.play().catch(error => {
                        console.error('Error playing audio:', error);
                        this.showToast('Failed to play audio', 'error');
                        buttonElement.classList.remove('playing');
                        buttonElement.innerHTML = `
                            <svg class="speaker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                                <path d="M15.54 8.46a5 5 0 010 7.07"/>
                                <path d="M19.07 4.93a10 10 0 010 14.14"/>
                            </svg>
                            <span>Play</span>
                        `;
                        this.state.isStreamingAudio = false;
                        // Stop visualization on error
                        this.stopSoundwaveVisualization();
                    });
                } catch (error) {
                    console.error('Error creating audio:', error);
                    this.showToast('Failed to create audio', 'error');
                    this.stopSoundwaveVisualization();
                }
            },

            // Alfred Visualization Panel
            toggleAlfredViz() {
                const panel = document.getElementById('alfredVizPanel');
                if (panel) {
                    panel.classList.toggle('collapsed');
                }
            },

            startSoundwaveVisualization() {
                const canvas = document.getElementById('alfredSoundwave');
                const overlay = document.querySelector('.alfred-soundwave-overlay');
                const status = document.getElementById('alfredVizStatus');
                const panel = document.getElementById('alfredVizPanel');
                
                if (!canvas || !this.state.audioAnalyser) return;
                
                const ctx = canvas.getContext('2d');
                
                if (overlay) overlay.classList.add('active');
                if (status) {
                    status.classList.add('speaking');
                    status.textContent = 'Speaking...';
                }
                if (panel) panel.classList.add('speaking');
                
                // Initialize sound wave animation with real audio data
                // Use half as many bars since we'll mirror them
                const barsPerSide = 8;
                const totalBars = barsPerSide * 2;
                const barWidth = canvas.width / totalBars;
                const bufferLength = this.state.audioAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                console.log('🎵 Starting mirrored audio-driven visualization with', barsPerSide, 'bars per side');
                
                const animate = () => {
                    if (!this.state.isStreamingAudio) {
                        return; // Stop animation if audio stopped
                    }
                    
                    // Get real-time frequency data from the audio
                    this.state.audioAnalyser.getByteFrequencyData(dataArray);
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw bars mirrored from center outward
                    for (let i = 0; i < barsPerSide; i++) {
                        // Map bar index to frequency data (sample the frequency spectrum)
                        const dataIndex = Math.floor((i / barsPerSide) * bufferLength);
                        const value = dataArray[dataIndex];
                        
                        // Normalize the value (0-255) to a height percentage (0-1)
                        const normalizedHeight = value / 255;
                        
                        // Add minimum height so bars are always visible
                        const height = normalizedHeight * canvas.height * 0.8 + canvas.height * 0.15;
                        
                        const y = (canvas.height - height) / 2;
                        
                        // Create gradient with intensity based on frequency (black to grey)
                        const gradient = ctx.createLinearGradient(0, y, 0, y + height);
                        const alpha = 0.7 + (normalizedHeight * 0.3); // Vary transparency with intensity
                        gradient.addColorStop(0, `rgba(100, 100, 100, ${alpha})`); // Grey
                        gradient.addColorStop(0.5, `rgba(50, 50, 50, ${alpha})`); // Dark grey
                        gradient.addColorStop(1, `rgba(20, 20, 20, ${alpha})`); // Almost black
                        
                        ctx.fillStyle = gradient;
                        
                        // Add subtle glow effect that varies with frequency intensity
                        ctx.shadowColor = '#333333';
                        ctx.shadowBlur = 3 + (normalizedHeight * 5);
                        
                        // Draw left side (from center going left)
                        const xLeft = (canvas.width / 2) - ((i + 1) * barWidth) + barWidth * 0.1;
                        ctx.fillRect(xLeft, y, barWidth * 0.8, height);
                        
                        // Draw right side (from center going right) - mirror
                        const xRight = (canvas.width / 2) + (i * barWidth) + barWidth * 0.1;
                        ctx.fillRect(xRight, y, barWidth * 0.8, height);
                        
                        // Reset shadow for next iteration
                        ctx.shadowBlur = 0;
                    }
                    
                    this.state.soundwaveAnimationId = requestAnimationFrame(animate);
                };
                
                animate();
            },

            stopSoundwaveVisualization() {
                const canvas = document.getElementById('alfredSoundwave');
                const overlay = document.querySelector('.alfred-soundwave-overlay');
                const status = document.getElementById('alfredVizStatus');
                const panel = document.getElementById('alfredVizPanel');
                
                console.log('🛑 Stopping audio visualization');
                
                // Stop the streaming flag to halt animation
                this.state.isStreamingAudio = false;
                
                if (this.state.soundwaveAnimationId) {
                    cancelAnimationFrame(this.state.soundwaveAnimationId);
                    this.state.soundwaveAnimationId = null;
                }
                
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                if (overlay) {
                    overlay.classList.remove('active');
                }
                
                if (status) {
                    status.classList.remove('speaking');
                    status.textContent = 'Ready to speak';
                }
                
                if (panel) {
                    panel.classList.remove('speaking');
                }
            },

            switchAI(ai) {
                this.state.currentAI = ai;
                
                document.querySelectorAll('.chat-toggle-btn[data-ai]').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.ai === ai) {
                        btn.classList.add('active');
                    }
                });

                // Update panel title
                const vizTitle = document.querySelector('.alfred-viz-title');
                if (vizTitle) {
                    vizTitle.textContent = ai === 'alfred' ? 'Alfred' : 'Alice';
                }

                // Clear conversation history when switching AIs
                this.state.conversationHistory = [];
                
                // Clear chat messages and show welcome message
                this.initChatView();
            },

            updateChatModel(model) {
                this.state.settings.model = model;
                console.log(`🤖 Chat model updated to: ${model}`);
                this.showToast(`Model changed to ${model}`, 'success');
            },

            switchChatMode(mode) {
                this.state.chatMode = mode;
                
                document.querySelectorAll('.chat-toggle-btn[data-mode]').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.mode === mode) {
                        btn.classList.add('active');
                    }
                });

                // Clear conversation history when switching modes
                this.state.conversationHistory = [];
                
                // If switching away from selected mode, clear the selected note and hide the button
                if (mode !== 'selected') {
                    this.state.selectedNoteForChat = null;
                    this.state.currentNote = null;
                    
                    const selectedNoteBtn = document.getElementById('selectedNoteBtn');
                    if (selectedNoteBtn) {
                        selectedNoteBtn.style.display = 'none';
                    }
                }
                
                // Update placeholder text based on mode
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    if (mode === 'notes') {
                        chatInput.placeholder = 'Ask about your notes (e.g., "What did we discuss about the API last week?")';
                    } else if (mode === 'selected') {
                        const noteName = this.state.currentNote?.data?.basic?.name || 'this note';
                        chatInput.placeholder = `Ask about "${noteName}"...`;
                    } else {
                        chatInput.placeholder = 'Ask Alfred anything...';
                    }
                }
                
                // Reinitialize chat view with new mode
                this.initChatView();
                
                // Show toast to inform user
                const modeText = mode === 'notes' ? 'All Notes' : mode === 'selected' ? 'Selected Note' : 'Chat';
                this.showToast(`Switched to ${modeText} mode`, 'success');
            },

            showModeInfo() {
                const modal = document.getElementById('infoModal');
                if (modal) {
                    modal.classList.add('active');
                }
            },

            closeInfoModal(event) {
                const modal = document.getElementById('infoModal');
                if (modal && (!event || event.target === modal)) {
                    modal.classList.remove('active');
                }
            },

            initChatView() {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) return;

                // Clear current note and selected note for general modes
                if (this.state.chatMode !== 'selected') {
                    this.state.currentNote = null;
                    this.state.selectedNoteForChat = null;
                }
                
                this.state.conversationHistory = [];

                chatMessages.innerHTML = '';

                // Hide Selected Note button if not in selected mode
                const selectedNoteBtn = document.getElementById('selectedNoteBtn');
                if (selectedNoteBtn && this.state.chatMode !== 'selected') {
                    selectedNoteBtn.style.display = 'none';
                }

                // Update placeholder based on current mode
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    if (this.state.chatMode === 'notes') {
                        chatInput.placeholder = 'Ask about your notes (e.g., "What did we discuss about the API last week?")';
                    } else if (this.state.chatMode === 'selected') {
                        const noteName = this.state.currentNote?.data?.basic?.name || 'this note';
                        chatInput.placeholder = `Ask about "${noteName}"...`;
                    } else {
                        chatInput.placeholder = 'Ask Alfred anything...';
                    }
                }

                const welcomeMessage = document.createElement('div');
                welcomeMessage.className = 'message';
                
                let welcomeText;
                if (this.state.chatMode === 'notes') {
                    welcomeText = this.state.currentAI === 'alfred' 
                        ? "Hello! I'm Alfred. I can search across all your meeting notes to help you find information. Try asking questions like 'What did we discuss about the API last week?' or 'Who was assigned to the design task?'"
                        : "Hello! I'm Alice. I can search across all your meeting notes to help you find information. Ask me anything about your notes!";
                } else if (this.state.chatMode === 'selected') {
                    const noteName = this.state.currentNote?.data?.basic?.name || 'this note';
                    welcomeText = this.state.currentAI === 'alfred' 
                        ? `Hello! I'm Alfred. I've analyzed your note "${noteName}". Ask me anything about it - I have access to the full transcript, summary, and related content.`
                        : `Hello! I'm Alice. I've analyzed your note "${noteName}". Ask me anything about it!`;
                } else {
                    welcomeText = this.state.currentAI === 'alfred' 
                        ? "Hello! I'm Alfred, your AI assistant. I can help you with any questions, tasks, or creative projects. What would you like to know?"
                        : "Hello! I'm Alice, your AI assistant. I can help you with any questions, tasks, or creative projects. What would you like to know?";
                }
                
                welcomeMessage.innerHTML = `
                    <div class="message-avatar">${this.state.currentAI === 'alfred' ? 'A' : 'L'}</div>
                    <div class="message-content">
                        <div class="message-text">${welcomeText}</div>
                    </div>
                `;
                chatMessages.appendChild(welcomeMessage);
            },

            // Views
            showView(viewId, keepContext = false) {
                document.querySelectorAll('.view-container').forEach(view => {
                    view.classList.remove('active');
                });
                document.getElementById(viewId)?.classList.add('active');

                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.view === viewId) {
                        item.classList.add('active');
                    }
                });

                if (viewId === 'libraryView') {
                    this.loadNotes();
                } else if (viewId === 'chatView' && !keepContext) {
                    // Only initialize fresh chat if not coming from a note
                    this.initChatView();
                }
            },

            // Settings
            updateSettings() {
                this.state.settings.backendEnabled = document.getElementById('backendToggle')?.checked ?? true;
                this.state.settings.webServerUpload = document.getElementById('webServerToggle')?.checked ?? true;
                this.state.settings.model = document.getElementById('modelSelect')?.value ?? 'llama3.2:3b';
                this.state.settings.audioEnabled = document.getElementById('audioToggle')?.checked ?? false;
                this.state.settings.ttsEngine = document.getElementById('ttsEngineSelect')?.value ?? 'kokoro';
                this.state.settings.voiceId = document.getElementById('voiceSelect')?.value ?? 'en';
                this.state.settings.autoPlay = document.getElementById('autoPlayToggle')?.checked ?? false;
                
                // Save audio settings to localStorage
                localStorage.setItem('alfred_audio_enabled', this.state.settings.audioEnabled);
                localStorage.setItem('alfred_tts_engine', this.state.settings.ttsEngine);
                localStorage.setItem('alfred_voice_id', this.state.settings.voiceId);
                localStorage.setItem('alfred_auto_play', this.state.settings.autoPlay);
                
                this.showToast('Settings updated', 'success');
            },

            // API URL Management
            startEditingApiUrl() {
                const apiUrlDisplay = document.getElementById('apiUrlDisplay');
                const apiUrlEditor = document.getElementById('apiUrlEditor');
                const apiUrlInput = document.getElementById('apiUrlInput');
                
                if (apiUrlDisplay && apiUrlEditor && apiUrlInput) {
                    apiUrlInput.value = this.state.settings.apiBaseUrl;
                    apiUrlDisplay.style.display = 'none';
                    apiUrlEditor.style.display = 'block';
                    apiUrlInput.focus();
                }
            },

            saveApiUrl() {
                const apiUrlInput = document.getElementById('apiUrlInput');
                let newUrl = apiUrlInput?.value?.trim() || 'https://api.oip.onl';
                
                // Remove trailing slash if present
                newUrl = newUrl.replace(/\/$/, '');
                
                // Basic URL validation
                try {
                    new URL(newUrl);
                } catch (e) {
                    this.showToast('Invalid URL format', 'error');
                    return;
                }
                
                // Save to state and localStorage
                this.state.settings.apiBaseUrl = newUrl;
                localStorage.setItem('alfred_api_base_url', newUrl);
                
                // Update display
                this.updateApiUrlDisplay();
                this.cancelEditingApiUrl();
                
                this.showToast('Backend API URL updated', 'success');
            },

            cancelEditingApiUrl() {
                const apiUrlDisplay = document.getElementById('apiUrlDisplay');
                const apiUrlEditor = document.getElementById('apiUrlEditor');
                
                if (apiUrlDisplay && apiUrlEditor) {
                    apiUrlDisplay.style.display = 'block';
                    apiUrlEditor.style.display = 'none';
                }
            },

            updateApiUrlDisplay() {
                const apiUrlText = document.getElementById('apiUrlText');
                const apiUrlDisplayAbout = document.getElementById('apiUrlDisplayAbout');
                
                if (apiUrlText) {
                    apiUrlText.textContent = this.state.settings.apiBaseUrl;
                }
                if (apiUrlDisplayAbout) {
                    apiUrlDisplayAbout.textContent = this.state.settings.apiBaseUrl;
                }
            },

            // Search
            searchNotes() {
                const searchInput = document.getElementById('searchInput');
                const query = searchInput?.value.toLowerCase() || '';
                
                if (!query) {
                    this.renderNotesList();
                    return;
                }

                const filtered = this.state.notes.filter(note => {
                    const basic = note.data?.basic || {};
                    const noteData = note.data?.notes || {};
                    return (basic.name || '').toLowerCase().includes(query) ||
                           (basic.description || '').toLowerCase().includes(query) ||
                           (noteData.summary_key_points || []).some(p => p.toLowerCase().includes(query));
                });

                const notesList = document.getElementById('notesList');
                if (!notesList) return;

                if (filtered.length === 0) {
                    notesList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <img src="icons/noun-notebook-7945455.svg" alt="No results">
                            </div>
                            <div class="empty-text">No notes found matching "${query}"</div>
                        </div>
                    `;
                    return;
                }

                this.state.notes = filtered;
                this.renderNotesList();
            },

            toggleFilters() {
                this.showToast('Advanced filters coming soon!', 'success');
            },

            // Toast notifications
            showToast(message, type = 'success') {
                const toast = document.getElementById('toast');
                if (!toast) return;

                toast.className = `toast ${type}`;
                document.getElementById('toastMessage').textContent = message;
                document.getElementById('toastIcon').textContent = type === 'success' ? '✓' : '⚠';
                toast.classList.remove('hidden');

                setTimeout(() => {
                    toast.classList.add('hidden');
                }, 3000);
            },

            // Theme management
            initTheme() {
                // Apply saved theme
                document.documentElement.setAttribute('data-theme', this.state.theme);
                this.updateThemeIcon();
            },

            toggleTheme() {
                // Toggle between light and dark
                this.state.theme = this.state.theme === 'dark' ? 'light' : 'dark';
                
                // Save to localStorage
                localStorage.setItem('alfred_theme', this.state.theme);
                
                // Apply theme
                document.documentElement.setAttribute('data-theme', this.state.theme);
                
                // Update icon
                this.updateThemeIcon();
                
                // Show toast
                this.showToast(`Switched to ${this.state.theme} mode`, 'success');
            },

            updateThemeIcon() {
                const themeIcon = document.getElementById('themeIcon');
                const themeToggle = document.getElementById('themeToggle');
                if (themeIcon && themeToggle) {
                    // In dark mode, show sun icon (to switch TO light mode)
                    // In light mode, show moon icon (to switch TO dark mode)
                    themeIcon.src = this.state.theme === 'dark' ? 'icons/noun-sun-4646269.svg' : 'icons/noun-moon-4600451.svg';
                    themeIcon.alt = this.state.theme === 'dark' ? 'Light mode' : 'Dark mode';
                    themeToggle.title = this.state.theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
                }
            }
        };

        // Initialize app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => alfredApp.init());
        } else {
            alfredApp.init();
        }
    </script>
</body>
</html>