# OIP Configuration
REGISTRATION_LIMIT=50
PORT=3005
OIP_DAEMON_PORT=3005
JWT_SECRET=

# Public API Base URL (for generating media URLs)
# Set this to your public domain when deploying (e.g., https://oip.fitnessally.io)
# Leave empty for local development (will auto-detect from requests)
PUBLIC_API_BASE_URL=

# Arweave Configuration
WALLET_FILE=config/arweave-keyfile.json
ARWEAVE_KEY_FILE=config/arweave-keyfile.json

# AR.IO Gateway Configuration (Local Arweave Gateway)
# For multi-stack deployments: Run ONE stack with max-decentralized or max-decentralized-gpu
# profile to host the AR.IO gateway, then point all other stacks to it.
# 
# USE_LOCAL_ARIO_GATEWAY: Set to 'true' to use a local AR.IO gateway, 'false' to use arweave.net
# Default: false (uses arweave.net)
USE_LOCAL_ARIO_GATEWAY=false
#
# LOCAL_ARIO_GATEWAY_ADDRESS: Address of your AR.IO gateway (host:port or IP:port)
# Examples:
#   - Docker service name (if running in same compose stack): ario-gateway:4000
#   - Host machine (accessing from outside Docker): localhost:4000
#   - Different machine on LAN: 192.168.1.100:4000
# Default: ario-gateway:4000 (for containerized deployments)
LOCAL_ARIO_GATEWAY_ADDRESS=ario-gateway:4000
#
# AR.IO Gateway Port (for the stack that RUNS the gateway - max-decentralized profiles only)
# This is the external port that the AR.IO gateway container will bind to
# Default: 4000
ARIO_GATEWAY_PORT=4000
# AR.IO Gateway Data Storage Path
# Path where AR.IO gateway cache/data will be stored on host filesystem
# Default: ./ario_gateway_data (relative to project root)
ARIO_GATEWAY_DATA_PATH=./ario_gateway_data
# AR.IO Gateway Start Block Height (optional)
# Start syncing from a specific block height instead of genesis (block 0)
# Useful if you only need recent data - saves time and storage
# IMPORTANT: Set START_HEIGHT directly (AR.IO gateway expects this exact name)
# Example: START_HEIGHT=1500000 (start from block 1.5M)
# Also supports ARIO_START_BLOCK_HEIGHT for backward compatibility
# IMPORTANT: This only applies on FIRST SYNC. If the gateway has already synced data,
# it will continue from where it left off. To start from a new block height:
# 1. Stop the gateway: docker-compose stop ario-gateway
# 2. Delete the data directory: rm -rf ./ario_gateway_data (or your ARIO_GATEWAY_DATA_PATH)
# 3. Set START_HEIGHT to your desired block height
# 4. Restart: docker-compose up -d ario-gateway
# Leave empty or unset to sync from genesis (block 0)
START_HEIGHT=1579580
# ARIO_START_BLOCK_HEIGHT=  # Alternative name (backward compatibility)
# AR.IO Gateway Max Storage Limit (optional)
# Limit the cache/storage size in GB
# Gateway will cache on demand but won't exceed this limit
# Example: ARIO_MAX_STORAGE_GB=100 (limit to 100GB)
# Leave empty or unset for unlimited cache (on-demand only)
ARIO_MAX_STORAGE_GB=100
# AR.IO Gateway Data Filters (optional - Advanced)
# Control which bundles are processed and indexed to save storage
# ANS104_UNBUNDLE_FILTER: Determines which bundles are processed/unbundled
# ANS104_INDEX_FILTER: Controls which data items are indexed in the database
# By default, all data is processed. Use filters to be selective.
# Example: Only process OIP data items
ANS104_UNBUNDLE_FILTER='{"tags": [{"name": "Index-Method", "values": ["OIP"]}]}'
ANS104_INDEX_FILTER='{"tags": [{"name": "Index-Method", "values": ["OIP"]}]}'
# Example: Filter by owner address
# ANS104_UNBUNDLE_FILTER='{"attributes": {"owner_address": "YOUR_WALLET_ADDRESS"}}'
# Leave commented out to process all data
# ANS104_UNBUNDLE_FILTER=
# ANS104_INDEX_FILTER=
#
# AR.IO Gateway Fallback Safety Check
# Maximum allowed block gap when falling back to arweave.net
# If local AR.IO gateway fails and the fallback would skip more than this many blocks,
# the entire cycle will fail instead of using the fallback (to prevent data loss)
# This prevents silently missing hundreds of thousands of blocks of potential OIP transactions
# Default: 1000 blocks (~17 hours at 2 min/block)
# Set higher if you're okay with larger gaps, or lower for stricter data integrity
MAX_BLOCK_GAP_FOR_FALLBACK=100

# Turbo SDK Configuration (ArDrive)
# These environment variables may help resolve ERR_INVALID_URL errors
# TURBO_API=https://payment.ardrive.io
# TURBO_LOGIN=https://payment.ardrive.io/login
# TURBO_UPLOAD_SERVICE_URL=https://upload.ardrive.io
# TURBO_PAYMENT_SERVICE_URL=https://payment.ardrive.io

# Elasticsearch Configuration
ELASTICSEARCHHOST=http://elasticsearch:9200
ELASTICCLIENTUSERNAME=elastic
ELASTICCLIENTPASSWORD=yourpassword

# Elasticsearch Data Storage Path
# Path where Elasticsearch data will be stored on host filesystem
# Uses bind mount instead of Docker-managed volume to avoid disk space issues
# Default: ./elasticsearch_data (relative to project root)
# For more space, use absolute path like: /data/elasticsearch
ELASTICSEARCH_DATA_PATH=./elasticsearch_data

# Elasticsearch Client Recreation Interval (milliseconds)
# Periodically recreates the ES client to prevent memory leaks from Undici connection pooling
# Default: 1800000 (30 minutes)
# Lower values = more frequent recreation but higher connection overhead
ES_CLIENT_RECREATION_INTERVAL=1800000

# GraphQL Client Recreation Interval (milliseconds)
# Periodically recreates the GraphQL client used for Arweave queries to prevent socket/buffer leaks
# Default: 1800000 (30 minutes)
# Lower values = more frequent recreation, reducing connection accumulation
GRAPHQL_CLIENT_RECREATION_INTERVAL=1800000

# Optional: Adjust cache TTL in your .env (default: 1 hour)
BLOCK_HEIGHT_CACHE_TTL=3600000  # milliseconds

# API Keys
OPENAI_API_KEY=
XAI_API_KEY=
XAI_BEARER_TOKEN=

# X (Twitter) API Configuration
# Get from: https://developer.twitter.com/en/portal/dashboard
# Required for reliable X post archiving (otherwise scraping may fail)
X_BEARER_TOKEN=
TWITTER_BEARER_TOKEN=  # Legacy alias, use X_BEARER_TOKEN instead

NGROK_AUTH_TOKEN=
GOOGLE_CLOUD_API_KEY=
GOOGLE_APPLICATION_CREDENTIALS=config/google-service-account-key.json
GOOGLE_API_TOKEN=
ELEVENLABS_API_KEY=
# default voice id is "daniel - steady broadcaster"
ELEVENLABS_VOICE_ID=onwK4e9ZLuTAKqWW03F9
FIRECRAWL=

# Ngrok Domain Configuration
NGROK_DOMAIN=
# Examples:
# NGROK_DOMAIN=api.oip.onl           # For GPU nodes
# NGROK_DOMAIN=mynode.oip.onl        # For custom domains
# NGROK_DOMAIN=                      # Leave empty for random ngrok URLs

# LLM Configuration (Ollama-based)
# OLLAMA_HOST: Internal Docker network address (port always 11434 inside Docker)
# OLLAMA_PORT: External host port mapping (configurable for multi-stack)
OLLAMA_HOST=http://ollama:11434
LLAMA_MODEL=llama3.2:3b
# Available models: tinyllama, mistral, llama2, llama3.2:3b
# Models are managed by Ollama - run ./install_llm_models.sh to install
# HuggingFace token (optional - for some restricted models)
HUGGINGFACE_TOKEN=

# LLM Timeout Configuration
# Timeout for LLM API calls (summarization, chunk tagging) in milliseconds
# Increase for long meetings (35+ minutes of audio generates long transcripts)
# Default: 300000 (5 minutes)
LLM_TIMEOUT_MS=300000

# Chunk Tagging Configuration (for Alfred Notes)
# CHUNK_TAG_BATCH_SIZE: Number of chunks to process simultaneously
# Lower values = less system load, higher values = faster but may overwhelm LLM
# Default: 10
CHUNK_TAG_BATCH_SIZE=10

# CHUNK_TAG_BATCH_DELAY_MS: Delay between batches in milliseconds
# Prevents overwhelming the LLM service with too many simultaneous requests
# Default: 1000 (1 second)
CHUNK_TAG_BATCH_DELAY_MS=1000

# Voice Services Configuration
STT_SERVICE_URL=http://stt-service:8003
TTS_SERVICE_URL=http://tts-service:8005
TEXT_GENERATOR_URL=http://text-generator:8081

# Distributed Client Configuration
# For Mac/iOS clients connecting to backend
BACKEND_HOST=192.168.1.100
BACKEND_PORT=3000
BACKEND_PROTOCOL=http

# Whisper STT Configuration
WHISPER_MODEL=base
# Options: tiny, base, small, medium, large (larger = better quality, more resource usage)
WHISPER_DEVICE=cpu
# Options: cpu, cuda (for GPU acceleration)
WHISPER_COMPUTE_TYPE=int8
# Options: int8, int16, float16, float32 (int8 is fastest)

# GUN Configuration (for private/temporary storage)
GUN_PEERS=http://gun-relay:8765
GUN_ENABLE_ENCRYPTION=true
GUN_DEFAULT_PRIVACY=false

# GUN Sync Configuration (for multi-node synchronization)
GUN_SYNC_ENABLED=true
# GUN_SYNC_INTERVAL: How often to check for new records from other nodes (milliseconds)
# Default: 300000 (5 minutes) - reduced from 30s to prevent socket/memory leaks
# Lower values = more frequent sync but higher resource usage
GUN_SYNC_INTERVAL=300000
GUN_REGISTRY_ROOT=oip:registry
GUN_NODE_ID_OVERRIDE=
GUN_SYNC_PRIVATE_RECORDS=true
GUN_SYNC_TRUSTED_NODES=
GUN_EXTERNAL_PEERS=

# GUN Registry Timeout Configuration
# Timeout for GUN registry writes (putSimple operations) in milliseconds
# Increase for high-load scenarios with many simultaneous writes (e.g., 80+ chunks)
# Default: 30000 (30 seconds)
GUN_REGISTRY_TIMEOUT_MS=30000

# Record Type Index Preferences
# Controls which record types are indexed
# Options: all, whitelist, blacklist
# Default: all (indexes all record types)
RECORD_TYPE_INDEX_MODE=all

# Custom Public Directory Configuration
# Set to 'true' to serve static files from parent directory's public/ folder
# Useful for multi-deployment scenarios like RockHoppersGame/public/
CUSTOM_PUBLIC_PATH=false

# Local Media Configuration (for custom apps with local media files)
# Enable serving local media files (audio/video) from a directory
ENABLE_LOCAL_MEDIA=false
# Path to local media directory (relative to public path or absolute)
# Default: {publicPath}/mediamixer/local-tracks
LOCAL_MEDIA_PATH=

# Multi-Stack Deployment Configuration
# Unique project name to avoid Docker conflicts when running multiple OIP stacks
# This affects container names, network names, and volume names
COMPOSE_PROJECT_NAME=oip-arweave-indexer

# Service Port Configuration (for running multiple OIP stacks)
# Main OIP Daemon API port (already configured above as PORT)
# Alexandria Service configuration
# Set to true when using alexandria profiles (enables proxy from daemon to alexandria for AI/voice routes)
ALEXANDRIA_ENABLED=true
ALEXANDRIA_PORT=3006
ELASTICSEARCH_PORT=9200
ELASTICSEARCH_TRANSPORT_PORT=9300
KIBANA_PORT=5601
IPFS_SWARM_PORT=4001
IPFS_API_PORT=5001
IPFS_GATEWAY_PORT=8080
OLLAMA_PORT=11434
STT_SERVICE_PORT=8003
TTS_SERVICE_PORT=8005
GUN_RELAY_PORT=8765
ARIO_GATEWAY_PORT=4000
NGROK_DASHBOARD_PORT=4040
NGROK_PORT=4035
DEBUG_PORT=9229
NEXT_FRONTEND_PORT=3000

# ═══════════════════════════════════════════════════════════════════════════════
# ONION PRESS SERVER CONFIGURATION (onion-press-server profile)
# ═══════════════════════════════════════════════════════════════════════════════

# Onion Press Service Port
ONION_PRESS_PORT=3007

# Enable Onion Press proxy in OIP Daemon (allows /onion-press/ path on main domain)
# Set to 'false' to disable the /onion-press/ route on the daemon
ONION_PRESS_ENABLED=true

# Internal URL for Onion Press service (used by OIP daemon proxy)
# Usually doesn't need to be changed unless using custom networking
# ONION_PRESS_URL=http://onion-press-service:3007

# Publishing Destinations - control where records are published
# Set to 'true' or 'false' to enable/disable each destination
PUBLISH_TO_ARWEAVE=true
PUBLISH_TO_GUN=true
PUBLISH_TO_INTERNETARCHIVE=false

# WordPress Configuration
WORDPRESS_PORT=8080
WORDPRESS_DB_USER=wordpress
WORDPRESS_DB_PASSWORD=wordpress
WORDPRESS_DB_NAME=wordpress
WORDPRESS_DB_ROOT_PASSWORD=rootpassword

# TOR Configuration (integrated into onion-press-service)
# TOR runs within the onion-press container, providing:
# - SOCKS proxy for outbound .onion requests
# - Hidden service for incoming .onion connections
TOR_SOCKS_PORT=9050
TOR_CONTROL_PORT=9051

# Internet Archive Organization Handle
# The organization record that contains the IA gateway's .onion address
# This organization should have a 'gateway_onion_address' field
IA_ORGANIZATION_HANDLE=internetarchive

# ═══════════════════════════════════════════════════════════════════════════════

# Memory Configuration
# Set by set-memory.sh script based on available system memory
# Example: --max-old-space-size=32768 for 32GB
NODE_OPTIONS=

# Timezone Configuration
# Set to your local timezone for proper timestamp handling
# Example: America/Los_Angeles, America/New_York, Europe/London, UTC
TZ=UTC

# Database Keep-Alive Configuration
# KEEP_DB_DELAY: Initial delay before starting keep-alive checks (seconds)
# KEEP_DB_REFRESH: Interval between keep-alive refreshes (seconds)
KEEP_DB_DELAY=15
KEEP_DB_REFRESH=600

# Memory Diagnostics
# Enable memory usage logging for debugging memory leaks
# Set to 'true' to enable detailed memory diagnostics
MEMORY_DIAGNOSTICS_ENABLED=false

# ═══════════════════════════════════════════════════════════════════════════════
# Memory Management & Scheduled Restart
# ═══════════════════════════════════════════════════════════════════════════════
# Scheduled memory check - restarts container if heap exceeds threshold at specified time
# Set MEMORY_RESTART_THRESHOLD_GB=0 to disable automatic restarts
MEMORY_RESTART_THRESHOLD_GB=36
MEMORY_RESTART_TIME=02:00
MEMORY_RESTART_TIMEZONE=America/Los_Angeles

# V8 memory optimization flags
# --max-old-space-size: Maximum heap size in MB (should be > MEMORY_RESTART_THRESHOLD_GB)
# --optimize-for-size: Prioritize memory over speed
# --trace-gc: (optional) Log every GC event for debugging
# Note: --expose-gc is passed via CMD in Dockerfile (not allowed in NODE_OPTIONS)
NODE_OPTIONS=--max-old-space-size=49152 --optimize-for-size

# STT Max Duration (5 hours)
STT_MAX_DURATION_SECONDS=18000

# LLM Timeout (10 minutes base)
LLM_TIMEOUT_MS=600000

# HTTP Server Timeouts
HTTP_SERVER_TIMEOUT_MS=1800000
HTTP_KEEPALIVE_TIMEOUT_MS=2100000
HTTP_HEADERS_TIMEOUT_MS=2100000

# How often to clear caches and run GC (hours). Set to 0 to disable.
MEMORY_CLEANUP_INTERVAL_HOURS=2

# Logging verbosity (affects elasticsearch.js and keepDBUpToDate)
# Options: normal (all logs), minimal (important only), quiet (errors only)
# Reducing logging can help prevent memory growth from string accumulation
LOG_LEVEL=minimal
