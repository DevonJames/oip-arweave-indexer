<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALFRED Phase 3: Interruption Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
            text-align: center;
        }
        
        .status.disconnected { background-color: #fee; color: #c00; }
        .status.connecting { background-color: #fff3cd; color: #856404; }
        .status.connected { background-color: #d4edda; color: #155724; }
        .status.interruption { background-color: #e7f3ff; color: #0056b3; }
        
        .controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button.primary { background-color: #007aff; color: white; }
        button.primary:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; color: white; }
        button.danger { background-color: #dc3545; color: white; }
        button.success { background-color: #28a745; color: white; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .conversation-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .conversation-panel {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 16px;
            height: 300px;
            overflow-y: auto;
        }
        
        .conversation-message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
        }
        
        .conversation-message.user {
            background-color: #007aff;
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .conversation-message.agent {
            background-color: #e9ecef;
            color: #333;
        }
        
        .conversation-message.interrupted {
            background-color: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }
        
        .conversation-message.partial {
            background-color: #e7f3ff;
            color: #0056b3;
            font-style: italic;
            opacity: 0.8;
        }
        
        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            padding: 16px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 16px;
        }
        
        .turn-indicator.user-turn {
            background-color: #d4edda;
            color: #155724;
        }
        
        .turn-indicator.agent-turn {
            background-color: #cce5ff;
            color: #004085;
        }
        
        .turn-indicator.processing {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .turn-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: currentColor;
        }
        
        .turn-dot.active {
            animation: pulse 1.5s infinite;
        }
        
        .interruption-controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            padding: 16px;
            background-color: #f8f9fa;
            border-radius: 8px;
            align-items: center;
        }
        
        .interruption-status {
            flex: 1;
            font-weight: 500;
        }
        
        .interruption-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }
        
        .interruption-metric {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .interruption-metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #007aff;
        }
        
        .interruption-metric-label {
            font-size: 11px;
            color: #6c757d;
            margin-top: 4px;
        }
        
        .test-scenarios {
            margin: 20px 0;
        }
        
        .test-scenario {
            margin: 10px 0;
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007aff;
        }
        
        .test-scenario h4 {
            margin: 0 0 8px 0;
            color: #007aff;
        }
        
        .test-scenario p {
            margin: 0;
            font-size: 14px;
            color: #6c757d;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¤ ALFRED Phase 3: Real-Time Interruption Test</h1>
            <p>Test real-time interruption handling with smart-turn v2 equivalent and audio crossfading</p>
        </div>
        
        <div id="status" class="status disconnected">
            Disconnected
        </div>
        
        <div class="controls">
            <button id="connectBtn" class="primary">Connect</button>
            <button id="disconnectBtn" class="secondary" disabled>Disconnect</button>
            <button id="simulateTTSBtn" class="success" disabled>Simulate Agent Speech</button>
            <button id="testInterruptionBtn" class="danger" disabled>Test Interruption</button>
            <button id="clearLogBtn" class="secondary">Clear All</button>
        </div>
        
        <div id="turnIndicator" class="turn-indicator user-turn">
            <div id="turnDot" class="turn-dot"></div>
            <span id="turnText">User Turn - Ready to Listen</span>
        </div>
        
        <div class="interruption-controls">
            <div class="interruption-status">
                <strong>Interruption Status:</strong> 
                <span id="interruptionStatus">Ready</span>
            </div>
            <div>
                <strong>Can Interrupt:</strong> 
                <span id="canInterruptStatus">No</span>
            </div>
            <div>
                <strong>Agent Speaking:</strong> 
                <span id="agentSpeakingStatus">No</span>
            </div>
        </div>
        
        <div class="conversation-area">
            <div>
                <h3>ðŸ’¬ Live Conversation</h3>
                <div id="conversationPanel" class="conversation-panel"></div>
            </div>
            <div>
                <h3>ðŸ“Š Processing Log</h3>
                <div id="processingLog" class="conversation-panel"></div>
            </div>
        </div>
        
        <div class="interruption-metrics">
            <div class="interruption-metric">
                <div id="interruptionLatencyValue" class="interruption-metric-value">--</div>
                <div class="interruption-metric-label">Interruption Latency (ms)</div>
            </div>
            <div class="interruption-metric">
                <div id="interruptionsHandledValue" class="interruption-metric-value">--</div>
                <div class="interruption-metric-label">Interruptions Handled</div>
            </div>
            <div class="interruption-metric">
                <div id="successRateValue" class="interruption-metric-value">--</div>
                <div class="interruption-metric-label">Success Rate (%)</div>
            </div>
            <div class="interruption-metric">
                <div id="conversationTurnsValue" class="interruption-metric-value">--</div>
                <div class="interruption-metric-label">Conversation Turns</div>
            </div>
            <div class="interruption-metric">
                <div id="avgResponseTimeValue" class="interruption-metric-value">--</div>
                <div class="interruption-metric-label">Avg Response Time (ms)</div>
            </div>
        </div>
        
        <div class="test-scenarios">
            <h3>ðŸ§ª Test Scenarios</h3>
            <div class="test-scenario">
                <h4>1. Basic Interruption Test</h4>
                <p>Click "Simulate Agent Speech", wait 1 second, then start speaking. Verify smooth interruption.</p>
            </div>
            <div class="test-scenario">
                <h4>2. Temporal Threshold Test</h4>
                <p>Try to interrupt immediately after agent starts speaking. Should be blocked for first 500ms.</p>
            </div>
            <div class="test-scenario">
                <h4>3. Keyword Interruption Test</h4>
                <p>Say interruption keywords like "wait", "stop", or "excuse me" during agent speech.</p>
            </div>
            <div class="test-scenario">
                <h4>4. False Positive Test</h4>
                <p>Make background noise or say "um", "uh" during agent speech. Should not interrupt.</p>
            </div>
        </div>
    </div>

    <script>
        class InterruptionTest {
            constructor() {
                this.ws = null;
                this.peerConnection = null;
                this.localStream = null;
                this.dataChannel = null;
                this.conversationFlow = null;
                
                this.isConnected = false;
                this.connectionStartTime = null;
                
                // Conversation state
                this.conversationState = {
                    currentTurn: 'user',
                    agentSpeaking: false,
                    userSpeaking: false,
                    canInterrupt: false
                };
                
                // Interruption metrics
                this.interruptionMetrics = {
                    interruptionLatency: 0,
                    interruptionsHandled: 0,
                    successfulInterruptions: 0,
                    conversationTurns: 0,
                    avgResponseTime: 0
                };
                
                this.setupEventListeners();
                this.updateUI();
            }
            
            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('simulateTTSBtn').addEventListener('click', () => this.simulateAgentSpeech());
                document.getElementById('testInterruptionBtn').addEventListener('click', () => this.testInterruption());
                document.getElementById('clearLogBtn').addEventListener('click', () => this.clearAll());
            }
            
            async connect() {
                try {
                    this.log('Connecting to Phase 3 interruption test server...', 'info');
                    this.updateStatus('connecting', 'Connecting...');
                    
                    // Connect to signaling server
                    this.ws = new WebSocket('ws://localhost:3002');
                    
                    this.ws.onopen = () => {
                        this.log('WebSocket connected', 'success');
                        this.initializeWebRTC();
                    };
                    
                    this.ws.onmessage = (event) => {
                        this.handleSignalingMessage(JSON.parse(event.data));
                    };
                    
                    this.ws.onclose = () => {
                        this.log('WebSocket disconnected', 'warning');
                        this.disconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        this.log(`WebSocket error: ${error}`, 'error');
                        this.disconnect();
                    };
                    
                } catch (error) {
                    this.log(`Connection failed: ${error.message}`, 'error');
                    this.updateStatus('disconnected', 'Connection failed');
                }
            }
            
            async initializeWebRTC() {
                try {
                    // Create peer connection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Setup peer connection handlers
                    this.setupPeerConnectionHandlers();
                    
                    // Get user media with echo cancellation
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,        // Critical for preventing self-interruption
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 16000,
                            channelCount: 1,
                            latency: 0.01
                        }
                    });
                    
                    this.log('Microphone access granted with echo cancellation', 'success');
                    
                    // Add tracks to peer connection
                    this.localStream.getTracks().forEach(track => {
                        this.peerConnection.addTrack(track, this.localStream);
                        this.log(`Added ${track.kind} track with echo cancellation`, 'info');
                    });
                    
                    // Create data channel for interruption signaling
                    this.dataChannel = this.peerConnection.createDataChannel('interruption', {
                        ordered: true,
                        maxRetransmits: 0
                    });
                    
                    this.setupDataChannelHandlers();
                    
                    // Create offer
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    // Send offer to signaling server
                    this.sendSignalingMessage({
                        type: 'offer',
                        offer: offer
                    });
                    
                    this.log('WebRTC offer sent for interruption testing', 'info');
                    
                } catch (error) {
                    this.log(`WebRTC initialization failed: ${error.message}`, 'error');
                    this.disconnect();
                }
            }
            
            setupPeerConnectionHandlers() {
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate
                        });
                    }
                };
                
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    this.log(`Connection state: ${state}`, 'info');
                    
                    if (state === 'connected') {
                        this.isConnected = true;
                        this.connectionStartTime = Date.now();
                        this.updateStatus('connected', 'Connected - Ready for Interruption Testing');
                        this.startInterruptionMonitoring();
                    } else if (state === 'disconnected' || state === 'failed') {
                        this.disconnect();
                    }
                };
                
                this.peerConnection.ontrack = (event) => {
                    this.log('Received remote audio track for TTS playback', 'success');
                    const audio = new Audio();
                    audio.srcObject = event.streams[0];
                    
                    // Monitor for interruption during playback
                    audio.onplay = () => {
                        this.handleAgentSpeechStart();
                    };
                    
                    audio.onended = () => {
                        this.handleAgentSpeechEnd();
                    };
                    
                    audio.play();
                };
            }
            
            setupDataChannelHandlers() {
                this.dataChannel.onopen = () => {
                    this.log('Interruption data channel opened', 'success');
                };
                
                this.dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleInterruptionMessage(data);
                };
                
                this.dataChannel.onerror = (error) => {
                    this.log(`Interruption data channel error: ${error}`, 'error');
                };
            }
            
            handleInterruptionMessage(data) {
                this.log(`Interruption message: ${data.type}`, 'info');
                
                switch (data.type) {
                    case 'speechStart':
                        this.handleUserSpeechStart(data);
                        break;
                        
                    case 'speechEnd':
                        this.handleUserSpeechEnd(data);
                        break;
                        
                    case 'partialTranscription':
                        this.handlePartialTranscription(data);
                        break;
                        
                    case 'finalTranscription':
                        this.handleFinalTranscription(data);
                        break;
                        
                    case 'interruption':
                        this.handleInterruptionDetected(data);
                        break;
                        
                    case 'ttsStarted':
                        this.handleTTSStarted(data);
                        break;
                        
                    case 'ttsInterrupted':
                        this.handleTTSInterrupted(data);
                        break;
                        
                    case 'ttsCompleted':
                        this.handleTTSCompleted(data);
                        break;
                        
                    case 'metrics':
                        this.updateInterruptionMetrics(data);
                        break;
                }
            }
            
            handleUserSpeechStart(data) {
                this.conversationState.userSpeaking = true;
                this.updateTurnIndicator();
                this.addConversationMessage('system', 'ðŸŽ¤ User started speaking...', 'partial');
            }
            
            handleUserSpeechEnd(data) {
                this.conversationState.userSpeaking = false;
                this.updateTurnIndicator();
                this.addConversationMessage('system', 'ðŸ”‡ User stopped speaking', 'partial');
            }
            
            handlePartialTranscription(data) {
                this.updatePartialTranscription(data.text);
            }
            
            handleFinalTranscription(data) {
                this.addConversationMessage('user', data.text, 'user');
                this.clearPartialTranscription();
                this.conversationState.currentTurn = 'processing';
                this.updateTurnIndicator();
            }
            
            handleInterruptionDetected(data) {
                this.log(`ðŸš¨ Interruption detected! Confidence: ${data.confidence.toFixed(3)}, Latency: ${data.latency}ms`, 'success');
                this.updateStatus('interruption', `Interruption Handled (${data.latency}ms)`);
                
                this.interruptionMetrics.interruptionsHandled++;
                this.interruptionMetrics.interruptionLatency = data.latency;
                if (data.handled) {
                    this.interruptionMetrics.successfulInterruptions++;
                }
                
                this.updateInterruptionMetricsDisplay();
                
                // Show interrupted content if available
                if (data.preservedContext && data.preservedContext.interruptedText) {
                    this.addConversationMessage('agent', data.preservedContext.interruptedText, 'interrupted');
                }
                
                setTimeout(() => {
                    this.updateStatus('connected', 'Connected - Ready for Testing');
                }, 2000);
            }
            
            handleTTSStarted(data) {
                this.conversationState.agentSpeaking = true;
                this.conversationState.canInterrupt = data.canBeInterrupted;
                this.conversationState.currentTurn = 'agent';
                this.updateTurnIndicator();
                this.updateInterruptionStatus();
                
                this.addConversationMessage('agent', data.text, 'agent');
                this.log(`ðŸ—£ï¸ Agent started speaking: "${data.text}"`, 'info');
            }
            
            handleTTSInterrupted(data) {
                this.conversationState.agentSpeaking = false;
                this.conversationState.canInterrupt = false;
                this.conversationState.currentTurn = 'user';
                this.updateTurnIndicator();
                this.updateInterruptionStatus();
                
                this.log(`âš¡ TTS interrupted! Text: "${data.interruptedText}"`, 'warning');
            }
            
            handleTTSCompleted(data) {
                this.conversationState.agentSpeaking = false;
                this.conversationState.canInterrupt = false;
                this.conversationState.currentTurn = 'user';
                this.updateTurnIndicator();
                this.updateInterruptionStatus();
                
                this.log(`âœ… TTS completed naturally`, 'info');
            }
            
            updateTurnIndicator() {
                const indicator = document.getElementById('turnIndicator');
                const dot = document.getElementById('turnDot');
                const text = document.getElementById('turnText');
                
                if (this.conversationState.currentTurn === 'user') {
                    indicator.className = 'turn-indicator user-turn';
                    dot.className = 'turn-dot active';
                    text.textContent = this.conversationState.userSpeaking ? 
                        'User Speaking...' : 'User Turn - Ready to Listen';
                } else if (this.conversationState.currentTurn === 'agent') {
                    indicator.className = 'turn-indicator agent-turn';
                    dot.className = 'turn-dot active';
                    text.textContent = this.conversationState.agentSpeaking ? 
                        'Agent Speaking - Can Interrupt' : 'Agent Turn';
                } else if (this.conversationState.currentTurn === 'processing') {
                    indicator.className = 'turn-indicator processing';
                    dot.className = 'turn-dot active';
                    text.textContent = 'Processing Response...';
                }
            }
            
            updateInterruptionStatus() {
                document.getElementById('interruptionStatus').textContent = 
                    this.conversationState.canInterrupt ? 'Ready to Interrupt' : 'Not Available';
                document.getElementById('canInterruptStatus').textContent = 
                    this.conversationState.canInterrupt ? 'Yes' : 'No';
                document.getElementById('agentSpeakingStatus').textContent = 
                    this.conversationState.agentSpeaking ? 'Yes' : 'No';
            }
            
            addConversationMessage(role, text, type = 'normal') {
                const panel = document.getElementById('conversationPanel');
                const message = document.createElement('div');
                message.className = `conversation-message ${role} ${type}`;
                message.textContent = text;
                
                panel.appendChild(message);
                panel.scrollTop = panel.scrollHeight;
            }
            
            updatePartialTranscription(text) {
                // Update or create partial transcription display
                let partialElement = document.getElementById('partialTranscription');
                if (!partialElement) {
                    partialElement = document.createElement('div');
                    partialElement.id = 'partialTranscription';
                    partialElement.className = 'conversation-message user partial';
                    document.getElementById('conversationPanel').appendChild(partialElement);
                }
                partialElement.textContent = text + ' â‹¯';
            }
            
            clearPartialTranscription() {
                const partialElement = document.getElementById('partialTranscription');
                if (partialElement) {
                    partialElement.remove();
                }
            }
            
            simulateAgentSpeech() {
                const testTexts = [
                    "This is a test of the interruption system. I'm going to speak for several seconds to give you time to interrupt me. You can try interrupting at any point during this speech.",
                    "Let me tell you about the weather today. It's quite nice outside with sunny skies and mild temperatures. Perfect for a walk in the park.",
                    "The quick brown fox jumps over the lazy dog. This is a longer sentence to test interruption capabilities during extended speech."
                ];
                
                const randomText = testTexts[Math.floor(Math.random() * testTexts.length)];
                
                // Send TTS simulation request
                this.sendSignalingMessage({
                    type: 'simulate_tts',
                    text: randomText
                });
                
                this.log(`Simulating agent speech: "${randomText.substring(0, 50)}..."`, 'info');
            }
            
            testInterruption() {
                if (!this.conversationState.agentSpeaking) {
                    this.log('No agent speech to interrupt', 'warning');
                    return;
                }
                
                // Send test interruption signal
                this.sendSignalingMessage({
                    type: 'test_interruption',
                    confidence: 0.9,
                    timestamp: Date.now()
                });
                
                this.log('Test interruption signal sent', 'info');
            }
            
            updateInterruptionMetricsDisplay() {
                document.getElementById('interruptionLatencyValue').textContent = 
                    this.interruptionMetrics.interruptionLatency.toFixed(0);
                document.getElementById('interruptionsHandledValue').textContent = 
                    this.interruptionMetrics.interruptionsHandled;
                
                const successRate = this.interruptionMetrics.interruptionsHandled > 0 ?
                    (this.interruptionMetrics.successfulInterruptions / this.interruptionMetrics.interruptionsHandled * 100) : 0;
                document.getElementById('successRateValue').textContent = successRate.toFixed(1);
                
                document.getElementById('conversationTurnsValue').textContent = 
                    this.interruptionMetrics.conversationTurns;
                document.getElementById('avgResponseTimeValue').textContent = 
                    this.interruptionMetrics.avgResponseTime.toFixed(0);
            }
            
            handleSignalingMessage(message) {
                this.log(`Signaling: ${message.type}`, 'info');
                
                switch (message.type) {
                    case 'connected':
                        this.log(`Client ID: ${message.clientId}`, 'success');
                        break;
                        
                    case 'answer':
                        this.peerConnection.setRemoteDescription(message.answer);
                        break;
                        
                    case 'ice-candidate':
                        this.peerConnection.addIceCandidate(message.candidate);
                        break;
                        
                    default:
                        this.handleInterruptionMessage(message);
                }
            }
            
            sendSignalingMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                }
            }
            
            updateStatus(state, message) {
                const statusElement = document.getElementById('status');
                statusElement.className = `status ${state}`;
                statusElement.textContent = message;
            }
            
            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const simulateTTSBtn = document.getElementById('simulateTTSBtn');
                const testInterruptionBtn = document.getElementById('testInterruptionBtn');
                
                connectBtn.disabled = this.isConnected;
                disconnectBtn.disabled = !this.isConnected;
                simulateTTSBtn.disabled = !this.isConnected;
                testInterruptionBtn.disabled = !this.isConnected || !this.conversationState.agentSpeaking;
                
                this.updateInterruptionStatus();
                this.updateInterruptionMetricsDisplay();
            }
            
            log(message, type = 'info') {
                const logElement = document.getElementById('processingLog');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `conversation-message system ${type}`;
                entry.innerHTML = `<small>[${timestamp}]</small><br>${message}`;
                
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
                
                console.log(`[Interruption Test] ${message}`);
            }
            
            clearAll() {
                document.getElementById('conversationPanel').innerHTML = '';
                document.getElementById('processingLog').innerHTML = '';
                
                // Reset metrics
                this.interruptionMetrics = {
                    interruptionLatency: 0,
                    interruptionsHandled: 0,
                    successfulInterruptions: 0,
                    conversationTurns: 0,
                    avgResponseTime: 0
                };
                
                this.updateInterruptionMetricsDisplay();
            }
            
            disconnect() {
                this.log('Disconnecting...', 'info');
                
                this.isConnected = false;
                this.connectionStartTime = null;
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                
                this.updateStatus('disconnected', 'Disconnected');
                this.updateUI();
                
                this.log('Disconnected from interruption test', 'info');
            }
        }
        
        // Initialize the interruption test client
        const interruptionTest = new InterruptionTest();
    </script>
</body>
</html>
