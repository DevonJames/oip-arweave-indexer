<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALFRED Unified Pipeline Monitor</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            min-height: 100vh;
        }
        
        .dashboard {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .status-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .status-card h3 {
            margin: 0 0 16px 0;
            color: #333;
            font-size: 16px;
            font-weight: 600;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }
        
        .metric-label {
            font-size: 14px;
            color: #666;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #007aff;
        }
        
        .metric-value.warning {
            color: #ff9500;
        }
        
        .metric-value.error {
            color: #ff3b30;
        }
        
        .metric-value.success {
            color: #34c759;
        }
        
        .health-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .health-indicator.healthy {
            background-color: #34c759;
            animation: pulse-green 2s infinite;
        }
        
        .health-indicator.stressed {
            background-color: #ff9500;
            animation: pulse-orange 2s infinite;
        }
        
        .health-indicator.overloaded {
            background-color: #ff3b30;
            animation: pulse-red 1s infinite;
        }
        
        .health-indicator.failed {
            background-color: #8e8e93;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .chart {
            width: 100%;
            height: 200px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
        }
        
        .sessions-table {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        
        .table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #333;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button.primary { background-color: #007aff; color: white; }
        button.primary:hover { background-color: #0056b3; }
        button.secondary { background-color: #6c757d; color: white; }
        button.danger { background-color: #dc3545; color: white; }
        
        .log-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
        
        .log-content {
            height: 300px;
            overflow-y: auto;
            background: #1e1e1e;
            color: #ffffff;
            padding: 16px;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin: 2px 0;
        }
        
        .log-entry.info { color: #5ac8fa; }
        .log-entry.success { color: #32d74b; }
        .log-entry.warning { color: #ff9f0a; }
        .log-entry.error { color: #ff453a; }
        
        @keyframes pulse-green {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes pulse-orange {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <div class="header">
            <h1>üîß ALFRED Unified Pipeline Monitor</h1>
            <p>Real-time monitoring of the Phase 4 unified voice processing pipeline</p>
            <div class="controls">
                <button id="connectBtn" class="primary">Connect to Pipeline</button>
                <button id="refreshBtn" class="secondary">Refresh Data</button>
                <button id="optimizeBtn" class="secondary">Trigger Optimization</button>
                <button id="clearLogsBtn" class="secondary">Clear Logs</button>
            </div>
        </div>
        
        <div class="status-grid">
            <!-- Pipeline Health -->
            <div class="status-card">
                <h3>üè• Pipeline Health</h3>
                <div class="metric">
                    <span class="metric-label">Overall Status:</span>
                    <span class="metric-value">
                        <span id="healthIndicator" class="health-indicator healthy"></span>
                        <span id="healthStatus">Healthy</span>
                    </span>
                </div>
                <div class="metric">
                    <span class="metric-label">Processing Load:</span>
                    <span id="processingLoad" class="metric-value">0%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Memory Usage:</span>
                    <span id="memoryUsage" class="metric-value">0 MB</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Uptime:</span>
                    <span id="uptime" class="metric-value">0s</span>
                </div>
            </div>
            
            <!-- Performance Metrics -->
            <div class="status-card">
                <h3>‚ö° Performance Metrics</h3>
                <div class="metric">
                    <span class="metric-label">Frame Processing:</span>
                    <span id="frameProcessingTime" class="metric-value">-- ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Pipeline Latency:</span>
                    <span id="pipelineLatency" class="metric-value">-- ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Throughput:</span>
                    <span id="throughput" class="metric-value">-- fps</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Error Rate:</span>
                    <span id="errorRate" class="metric-value">--%</span>
                </div>
            </div>
            
            <!-- Session Management -->
            <div class="status-card">
                <h3>üë• Session Management</h3>
                <div class="metric">
                    <span class="metric-label">Active Sessions:</span>
                    <span id="activeSessions" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Connections:</span>
                    <span id="totalConnections" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Frames in Queue:</span>
                    <span id="framesInQueue" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Backpressure:</span>
                    <span id="backpressureStatus" class="metric-value">Inactive</span>
                </div>
            </div>
            
            <!-- Resource Optimization -->
            <div class="status-card">
                <h3>üéõÔ∏è Resource Optimization</h3>
                <div class="metric">
                    <span class="metric-label">Memory Efficiency:</span>
                    <span id="memoryEfficiency" class="metric-value">100%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">CPU Utilization:</span>
                    <span id="cpuUtilization" class="metric-value">--%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Optimization Events:</span>
                    <span id="optimizationEvents" class="metric-value">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">GC Triggers:</span>
                    <span id="gcTriggers" class="metric-value">0</span>
                </div>
            </div>
        </div>
        
        <div class="charts-container">
            <div class="chart-card">
                <h3>üìà Processing Load Over Time</h3>
                <div class="chart" id="loadChart">
                    Real-time load chart will be implemented here
                </div>
            </div>
            
            <div class="chart-card">
                <h3>üíæ Memory Usage Trend</h3>
                <div class="chart" id="memoryChart">
                    Real-time memory chart will be implemented here
                </div>
            </div>
        </div>
        
        <div class="sessions-table">
            <h3>üìä Active Sessions</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th>Session ID</th>
                        <th>Connected</th>
                        <th>Frames Processed</th>
                        <th>Avg Latency</th>
                        <th>Transcriptions</th>
                        <th>Interruptions</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="sessionsTableBody">
                    <tr>
                        <td colspan="7" style="text-align: center; color: #666; font-style: italic;">
                            No active sessions
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="log-panel">
            <h3>üìù Pipeline Events Log</h3>
            <div class="log-content" id="logContent"></div>
        </div>
    </div>

    <script>
        class PipelineMonitor {
            constructor() {
                this.isConnected = false;
                this.metricsInterval = null;
                this.logEntries = [];
                this.maxLogEntries = 500;
                
                // Performance data
                this.performanceData = {
                    loadHistory: [],
                    memoryHistory: [],
                    maxDataPoints: 60  // 5 minutes at 5-second intervals
                };
                
                this.setupEventListeners();
                this.updateUI();
            }
            
            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('refreshBtn').addEventListener('click', () => this.refreshData());
                document.getElementById('optimizeBtn').addEventListener('click', () => this.triggerOptimization());
                document.getElementById('clearLogsBtn').addEventListener('click', () => this.clearLogs());
            }
            
            async connect() {
                try {
                    this.log('Connecting to unified pipeline...', 'info');
                    
                    // Start monitoring
                    this.startMonitoring();
                    
                    this.isConnected = true;
                    document.getElementById('connectBtn').textContent = 'Connected';
                    document.getElementById('connectBtn').disabled = true;
                    
                    this.log('Connected to unified pipeline monitor', 'success');
                    
                } catch (error) {
                    this.log(`Connection failed: ${error.message}`, 'error');
                }
            }
            
            startMonitoring() {
                // Refresh data every 2 seconds
                this.metricsInterval = setInterval(() => {
                    this.fetchMetrics();
                }, 2000);
                
                // Initial fetch
                this.fetchMetrics();
            }
            
            async fetchMetrics() {
                try {
                    // Fetch pipeline status
                    const pipelineResponse = await fetch('http://localhost:8015/pipeline/status');
                    const pipelineData = await pipelineResponse.json();
                    
                    // Fetch processor metrics
                    const metricsResponse = await fetch('http://localhost:8015/metrics');
                    const metricsData = await metricsResponse.json();
                    
                    // Update UI with data
                    this.updateMetrics(pipelineData, metricsData);
                    
                } catch (error) {
                    this.log(`Failed to fetch metrics: ${error.message}`, 'error');
                    
                    // Update health indicator to show error
                    this.updateHealthIndicator('failed', 'Connection Error');
                }
            }
            
            updateMetrics(pipelineData, metricsData) {
                // Pipeline health
                const health = pipelineData.pipelineState?.health || 'unknown';
                this.updateHealthIndicator(health, health.charAt(0).toUpperCase() + health.slice(1));
                
                // Processing load
                const load = pipelineData.pipelineState?.processingLoad || 0;
                this.updateMetricValue('processingLoad', `${load.toFixed(1)}%`, this.getLoadClass(load));
                
                // Memory usage
                const memory = pipelineData.pipelineState?.memoryUsage || 0;
                this.updateMetricValue('memoryUsage', `${memory.toFixed(0)} MB`, this.getMemoryClass(memory));
                
                // Uptime
                const uptime = metricsData.uptime_seconds || 0;
                this.updateMetricValue('uptime', this.formatUptime(uptime));
                
                // Performance metrics
                const avgFrameTime = pipelineData.performanceMonitor?.averageFrameTime || 0;
                this.updateMetricValue('frameProcessingTime', `${avgFrameTime.toFixed(1)} ms`, 
                    this.getLatencyClass(avgFrameTime, 20));
                
                const throughput = pipelineData.performanceMonitor?.throughput || 0;
                this.updateMetricValue('throughput', `${throughput.toFixed(1)} fps`);
                
                const errorRate = pipelineData.performanceMonitor?.errorRate || 0;
                this.updateMetricValue('errorRate', `${errorRate.toFixed(2)}%`, this.getErrorClass(errorRate));
                
                // Session management
                const activeSessions = pipelineData.pipelineState?.sessionsActive || 0;
                this.updateMetricValue('activeSessions', activeSessions.toString());
                
                const totalConnections = metricsData.total_requests || 0;
                this.updateMetricValue('totalConnections', totalConnections.toString());
                
                const framesInQueue = pipelineData.pipelineState?.framesInQueue || 0;
                this.updateMetricValue('framesInQueue', framesInQueue.toString(), 
                    this.getQueueClass(framesInQueue));
                
                const backpressure = pipelineData.backpressureState?.isActive ? 'Active' : 'Inactive';
                this.updateMetricValue('backpressureStatus', backpressure, 
                    pipelineData.backpressureState?.isActive ? 'warning' : 'success');
                
                // Resource optimization
                const memoryEfficiency = metricsData.memory_efficiency || 100;
                this.updateMetricValue('memoryEfficiency', `${memoryEfficiency.toFixed(0)}%`,
                    this.getEfficiencyClass(memoryEfficiency));
                
                // Update performance history
                this.updatePerformanceHistory(load, memory);
                
                // Update sessions table
                this.updateSessionsTable(pipelineData.sessionMetrics || {});
                
                // Log significant events
                if (health !== 'healthy') {
                    this.log(`Pipeline health: ${health} (load: ${load.toFixed(1)}%)`, 'warning');
                }
            }
            
            updateHealthIndicator(health, text) {
                const indicator = document.getElementById('healthIndicator');
                const status = document.getElementById('healthStatus');
                
                indicator.className = `health-indicator ${health}`;
                status.textContent = text;
            }
            
            updateMetricValue(elementId, value, className = '') {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = value;
                    element.className = `metric-value ${className}`;
                }
            }
            
            updatePerformanceHistory(load, memory) {
                this.performanceData.loadHistory.push(load);
                this.performanceData.memoryHistory.push(memory);
                
                // Keep data size manageable
                if (this.performanceData.loadHistory.length > this.performanceData.maxDataPoints) {
                    this.performanceData.loadHistory.shift();
                    this.performanceData.memoryHistory.shift();
                }
                
                // Update charts (simplified - real implementation would use Chart.js)
                this.updateCharts();
            }
            
            updateCharts() {
                // Simplified chart updates
                const loadChart = document.getElementById('loadChart');
                const memoryChart = document.getElementById('memoryChart');
                
                const currentLoad = this.performanceData.loadHistory.slice(-1)[0] || 0;
                const currentMemory = this.performanceData.memoryHistory.slice(-1)[0] || 0;
                
                loadChart.textContent = `Current Load: ${currentLoad.toFixed(1)}%`;
                memoryChart.textContent = `Current Memory: ${currentMemory.toFixed(0)}MB`;
                
                // Color code based on values
                loadChart.style.backgroundColor = this.getLoadColor(currentLoad);
                memoryChart.style.backgroundColor = this.getMemoryColor(currentMemory);
            }
            
            updateSessionsTable(sessionMetrics) {
                const tbody = document.getElementById('sessionsTableBody');
                tbody.innerHTML = '';
                
                if (Object.keys(sessionMetrics).length === 0) {
                    const row = tbody.insertRow();
                    row.innerHTML = '<td colspan="7" style="text-align: center; color: #666; font-style: italic;">No active sessions</td>';
                    return;
                }
                
                for (const [sessionId, metrics] of Object.entries(sessionMetrics)) {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${sessionId.substring(0, 12)}...</td>
                        <td>${this.formatTime(Date.now() - (metrics.connectedAt || Date.now()))}</td>
                        <td>${metrics.framesProcessed || 0}</td>
                        <td>${(metrics.averageLatency || 0).toFixed(1)}ms</td>
                        <td>${metrics.transcriptionsCompleted || 0}</td>
                        <td>${metrics.interruptionsHandled || 0}</td>
                        <td><span class="metric-value success">Active</span></td>
                    `;
                }
            }
            
            async refreshData() {
                this.log('Refreshing pipeline data...', 'info');
                await this.fetchMetrics();
                this.log('Data refreshed', 'success');
            }
            
            async triggerOptimization() {
                try {
                    this.log('Triggering pipeline optimization...', 'info');
                    
                    // This would call an optimization endpoint
                    // For now, just simulate
                    setTimeout(() => {
                        this.log('Pipeline optimization completed', 'success');
                    }, 1000);
                    
                } catch (error) {
                    this.log(`Optimization failed: ${error.message}`, 'error');
                }
            }
            
            // Utility methods for styling
            getLoadClass(load) {
                if (load > 80) return 'error';
                if (load > 60) return 'warning';
                return 'success';
            }
            
            getMemoryClass(memory) {
                if (memory > 400) return 'error';
                if (memory > 300) return 'warning';
                return 'success';
            }
            
            getLatencyClass(latency, target) {
                if (latency > target * 2) return 'error';
                if (latency > target) return 'warning';
                return 'success';
            }
            
            getErrorClass(rate) {
                if (rate > 5) return 'error';
                if (rate > 1) return 'warning';
                return 'success';
            }
            
            getQueueClass(size) {
                if (size > 100) return 'error';
                if (size > 50) return 'warning';
                return 'success';
            }
            
            getEfficiencyClass(efficiency) {
                if (efficiency < 70) return 'error';
                if (efficiency < 85) return 'warning';
                return 'success';
            }
            
            getLoadColor(load) {
                if (load > 80) return '#ffebee';
                if (load > 60) return '#fff3e0';
                return '#e8f5e8';
            }
            
            getMemoryColor(memory) {
                if (memory > 400) return '#ffebee';
                if (memory > 300) return '#fff3e0';
                return '#e8f5e8';
            }
            
            formatUptime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) {
                    return `${hours}h ${minutes}m`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }
            
            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                
                if (minutes > 0) {
                    return `${minutes}m ${seconds % 60}s`;
                } else {
                    return `${seconds}s`;
                }
            }
            
            updateUI() {
                // Initial UI state
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = {
                    timestamp,
                    message,
                    type
                };
                
                this.logEntries.push(entry);
                
                // Limit log size
                if (this.logEntries.length > this.maxLogEntries) {
                    this.logEntries = this.logEntries.slice(-this.maxLogEntries / 2);
                }
                
                // Update log display
                this.updateLogDisplay();
                
                console.log(`[Pipeline Monitor] ${message}`);
            }
            
            updateLogDisplay() {
                const logContent = document.getElementById('logContent');
                const recentEntries = this.logEntries.slice(-50);  // Show last 50 entries
                
                logContent.innerHTML = recentEntries.map(entry => 
                    `<div class="log-entry ${entry.type}">[${entry.timestamp}] ${entry.message}</div>`
                ).join('');
                
                logContent.scrollTop = logContent.scrollHeight;
            }
            
            clearLogs() {
                this.logEntries = [];
                this.updateLogDisplay();
                this.log('Logs cleared', 'info');
            }
        }
        
        // Initialize the pipeline monitor
        const monitor = new PipelineMonitor();
        
        // Auto-connect on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                monitor.connect();
            }, 1000);
        });
    </script>
</body>
</html>
